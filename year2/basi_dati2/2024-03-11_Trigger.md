# Trigger

I Trigger sono una alternativa alla mancanza dei check con sotto-query e alle assertion.


**I trigger sono delle azioni che si attivano automaticamente al verificarsi di una modifica ad una tabella**

I trigger seguono un paradigma **Evento-Condizione-Azione**:
- Il trigger è associato ad un **evento** che ne determina l'attivazione, ad esempio INSERT, DELETE, UPDATE
- Una volta attivato il trigger controlla una **condizione**, se tale condizione è falsa allora il trigger termina
- Se la condizione è vera allora viene eseguita una **azione**

## Trigger per riga e per statement

SQL fornisce due tipi di trigger:

- **Trigger per riga**: eseguiti per ogniuna delle righe coinvolte dall'evento. 
	Ci si riferisce alla riga coinvolta all'evento prima della sua attivazione `OLD ROW`
	Ci si riferisce alla riga coinvolta all'evento dopo della sua attivazione `NEW ROW`
- **Trigger per statement**: eseguiti una sola volta per evento.
	Ci si riferisce a tutte le righe coinvolte dall'evento prima della sua attivazione `OLD TABLE`
	Ci si riferisce a tutte le righe coinvolte dall'evento dopo la sua attivazione con `NEW TABLE`


## Before trigger e after trigger

In fase di definizione del trigger è possibile specificare se l'azione debba essere eseguita prima o dopo l'evento

- **Before trigger**: attivati prima dell'evento. Utilizzati solitamente per impedire l'esecuzione di una operazione o per modificarne preventivamente il comportamento
- **After trigger**: attivati dopo l'evento. Vedono lo stato dopo l’esecuzione di un’operazione e quindi sono talvolta necessari per motivi di espressività.

Un AFTER trigger performare un rollback dello stato della base di dati.
In generale l’uso di BEFORE trigger è preferibile.


## Esempio 1

I trigger forniscono un modo indiretto per mantenere **invarianti globali**: senza lo stile dichiarativo delle asserzioni.

Bisogna porsi certe domande per determinare come definire il trigger:

Supponiamo di volere utilizzare un trigger per garantire che non sia mai possibile abbassare uno stipendio:

1. **Quali operazioni possono violare l’invariante?**
	L’invariante può essere violata da un’operazione di aggiornamento
2. **Il mantenimento dell’invariante può essere controllato per ogni riga coinvolta dall’operazione oppure no?**
	Si, perché l’informazione è contestuale alla riga modificata
4. **Cosa bisogna fare prima o dopo dell’operazione per garantire il
mantenimento dell’invariante?**
Impedire l’aggiornamento della riga (BEFORE) oppure riportare lo stipendio al valore originale (AFTER)


```sql
CREATE TRIGGER MyTrigger
AFTER UPDATE OF stipendio ON MovieExec
REFERENCING OLD ROW AS OldTuple, NEW ROW AS NewTuple
FOR EACH ROW
WHEN (OldTuple.stipendio > NewTuple.stipendio)
	UPDATE MovieExec
	SET stipendio = OldTuple.stipendio
	WHERE code = NewTuple.code;
```


## Esempio 2

Supponiamo di volere utilizzare un trigger per garantire che la media degli stipendi non scenda mai sotto 500.000:

1. **Quali operazioni possono violare l’invariante?**
	L’invariante può essere violata da un’operazione di inserimento, aggiornamento o cancellazione
2. **Il mantenimento dell’invariante può essere controllato per ogni riga coinvolta dall’operazione oppure no?**
	Visto che la media è un’informazione globale della tabella, non possiamo ricorrere ad un controllo puntuale per riga. Optiamo per un trigger per statement
3. **Cosa bisogna fare prima o dopo dell’operazione per garantire il
mantenimento dell’invariante?**
Possiamo mantenere l’invariante annullando l’operazione che l’ha violata, cioè riportando la tabella allo stato originale (AFTER)


```sql
CREATE TRIGGER AvgNetWorthTrigger
AFTER UPDATE ON MovieExec
REFERENCING OLD TABLE AS OldStuff, NEW TABLE AS NewStuff
FOR EACH STATEMENT
WHEN (500000 > (SELECT AVG(netWorth) FROM MovieExec))
BEGIN
	DELETE FROM MovieExec
	WHERE (name, address, code, netWorth)
		IN (SELECT * FROM NewStuff);
	INSERT INTO MovieExec (SELECT * FROM OldStuff);
END;
```
questo trigger è per l'operazione di UPDATE, bisognerebbe aggiungere anche quelle per la DELETE e INSERT


## Trigger attivi e passivi


- **Trigger passivi**: tali trigger provocano il fallimento di un’operazione sotto determinate condizioni. 
	Usi tipici:
	- Definizione di vincoli di integrità (es. impedire l'abbassamento degli stipendio)
	- Controlli dinamici di autorizzazione (es. si possono inserire dati solo se il codice del dipartimento coincide con quello dell’utente che ha richiesto l’operazione)

- **Trigger attivi**: tali trigger modificano, anche in modo complesso, lo stato della base di dati in corrispondenza di certi eventi.
Usi tipici:
	- Definizione di vincoli di integrità (es. CASCADE)
	- Meccanismi di auditing e logging
	- Definizione di business rules (regole aziendali)


## Vantaggi e svantaggi

**Vantaggi**:

- I trigger sono gestite internamente dal DBMS, quindi non è possibile raggirarli
- Per il precedente motivo è più robusto centralizzare un’invariante in un trigger che sparpagliare i controlli all’interno del codice applicativo
- Per fare auditing e logging, i trigger sono l’unico strumento veramente robusto per tali compiti, dato che il DBMS ha completa visibilità delle operazioni effettuate sulle tabelle

**Svantaggi**:

- dato che sono stati implementati prima nei sistemi commerciali e poi nello standard SQL, i sistemi commerciali non seguono lo standard e spesso sono diversi tra loro. (non considerano di cambiare perché romperebbe la compatibilità con le vecchie versioni)
- I trigger sono difficili da debuggare e poco visibili in generale.

### Vincoli vs trigger

Generalmente è conveniente fare uso dei vincoli fornite dal DBMS quando possibile al posto dei trigger. I vincoli sono più semplici, brevi e gestiti meglio dal DBMS.

I trigger sono necessari quando le invarianti coinvolgono più tabelle oppure più righe di una tabella
