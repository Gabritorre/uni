# Algoritmo di Dijkstra

Possiamo descrivere l'algoritmo di Dijkstra nel seguente modo:
**Viene estratto un vertice alla volta, ad ogni estrazione si rilassano gli archi uscenti dal vettore estratto.**

Dijkstra fa uso di una coda di priorità $Q$ contenente le informazioni sul campo $d$ per ogni **nodo** del grafo **ancora da estrarre**.
Utilizza anche un insieme $S$ dove vengono mantenuti i **nodi già estratti**

Nota: L'algoritmo funziona solamente con archi con **pesi positivi**.
Inoltre risolve la categoria di problemi a **sorgente singola**

```c
dijkstra(G, w, s)
	init_ss(G, s)
	Q = V[G]
	S = ∅ 
	while Q != ∅
		u = extract_min(Q)
		S = S ∪ {u}
		for-each v in Adj[u]
			relax(u, v, w(u, v))
	return (d, Gπ)
```

L'algoritmo termina in quanto:
Ad ogni iterazione del `while` l'insieme `Q` diminuisce.
Mentre il ciclo for avrà sempre un numero finito di iterazioni in quanto ci sarà sempre un numero finito di archi.

## Complessità

La complessità dell'algoritmo dipende dall'implementazione dell'insieme `Q`, possiamo infatti implementarlo come:
1. Heap binario
2. Array lineare

## Complessità con Heap binario

- `init_ss` avrà tempo lineare, dipendente dal numero di nodi $n$
- la `extract_min(Q)` avrà tempo $\log(n)$ in quanto va mantenuta la proprietà dell'heap, tale metodo verrà chiamato $n$ volte dal ciclo, quindi in totale si avrà una complessità $n \log (n)$
- la `relax` ha complessità $\log(n)$ in quanto va mantenuta la proprietà dell'heap, tale metodo verrà chiamato $\text{out-degree}(u)$ volte che abbiamo già osservato essere la sommatoria di tutti i gradi dei nodi è $m$, quindi in totale si avrà una complessità $m \log (n)$

La complessità totale dell'algoritmo sarà quindi

$$T(n) = n + n\log(n) + m\log(n)$$

Assumendo che il grafo sia **connesso** allora $m \geq n-1$ e quindi

$$T(n) = O(m\log(n))$$


## Complessità con array lineare

- `init_ss` avrà tempo lineare, dipendente dal numero di nodi $n$
- la `extract_min(Q)` avrà tempo $n$ in quanto va cercato il minimo, tale metodo verrà chiamato $n$ volte dal ciclo, quindi in totale si avrà una complessità $n^2$
- la `relax` ha complessità costante in quanto va aggiornato direttamente un valore dell'array, tale metodo verrà chiamato $\text{out-degree}(u)$ volte che abbiamo già osservato essere la sommatoria di tutti i gradi dei nodi è $m$, quindi in totale si avrà una complessità $m$

La complessità totale dell'algoritmo sarà quindi

$$T(n) = n + n^2 + m$$

$$T(n) = O(n^2)$$

## Confronto

Seppur a primo impatto possa sembrare sempre migliore l'implementazione con Heap binari, in realtà dipende dalla densità del grafo.
Se assumiamo che un grafo **sparso** abbia $m \approx n$
e un grafo **denso** abbia $m \approx n^2$

allora possiamo schematizzare nel seguente modo:

|  | Heap | Array |
|--|--|--|
| **Grafo sparso** | $n\log(n)$ | $n^2$ | 
| **Grafo denso** | $n^2\log(n)$ | $n^2$ |

Notiamo come per grafi **sparsi** è più conveniente utilizzare l'implementazione con **Heap** binario.
Mentre con grafi **densi** è più conveniente utilizzare l'implementazione con **Array** lineare
