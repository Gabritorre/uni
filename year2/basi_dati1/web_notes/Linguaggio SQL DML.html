<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2023-11-10_Linguaggio SQL_DML</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#linguaggio-sql">Linguaggio SQL</a></li>
<li><a href="#dml">DML</a>
<ul>
<li><a href="#select">Select</a></li>
<li><a href="#giunzione">Giunzione</a></li>
<li><a href="#notazione-con-il-punto">Notazione con il punto</a></li>
<li><a href="#alias">Alias</a></li>
<li><a href="#ridenominazione">Ridenominazione</a></li>
<li><a href="#funzioni-di-aggregazione">Funzioni di aggregazione</a></li>
<li><a href="#order-by">Order by</a></li>
<li><a href="#operatori-insiemistici">Operatori insiemistici</a></li>
<li><a href="#il-valore-null">Il valore NULL</a></li>
<li><a href="#between">Between</a></li>
<li><a href="#like">Like</a></li>
<li><a href="#clausola-where">Clausola where</a></li>
<li><a href="#raggruppamento">Raggruppamento</a></li>
<li><a href="#insert">INSERT</a></li>
<li><a href="#delete">DELETE</a></li>
<li><a href="#update">UPDATE</a></li>
<li><a href="#case-when-then-else">CASE WHEN THEN ELSE</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="linguaggio-sql">Linguaggio SQL</h1>
<p>SQL (<em>Structured Query Language</em>) è un linguaggio dichiarativo che serve per interrogare una base di dati. È suddiviso in due parti principali:</p>
<ul>
<li><strong>DML (Data Manipulation Language)</strong>: Per leggere, inserire, modificare e cancellare dei dati (<strong>SELECT</strong>,  <strong>INSERT</strong>,  <strong>UPDATE</strong>,  <strong>DELETE</strong>).</li>
<li><strong>DDL (Data Definition Language)</strong>: Per la definizione della struttura dei dati, delle regole di integrità e dei privilegi degli utenti (<strong>CREATE</strong>,  <strong>ALTER</strong>,  <strong>DROP</strong>).</li>
</ul>
<h1 id="dml">DML</h1>
<p>Generalmente in questa categoria andiamo a fare delle operazioni su delle tabelle in input e in output viene restituita una tabella.</p>
<p>Le query si baseranno sul seguente esempio</p>
<p><img src="https://i.ibb.co/92qdhR2/image.png" alt="enter image description here"></p>
<h2 id="select">Select</h2>
<p>Il comando <strong>select</strong> serve per selezionare degli attributi da delle tabelle.<br>
La struttura generale è la seguente:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">&lt;</span>attributi<span class="token operator">&gt;</span>
<span class="token keyword">FROM</span> <span class="token operator">&lt;</span>tabelle<span class="token operator">&gt;</span>
<span class="token punctuation">[</span><span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>condizioni<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre>
<p>esempi</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> Nome<span class="token punctuation">,</span> Cognome<span class="token punctuation">,</span> Matricola
<span class="token keyword">FROM</span> Studenti<span class="token punctuation">;</span>
</code></pre>
<p>la clausola <strong>where</strong> serve per applicare una restrizione ai dati</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Esami
<span class="token keyword">WHERE</span> Voto <span class="token operator">&gt;</span> <span class="token number">26</span><span class="token punctuation">;</span>
</code></pre>
<p>(l’asterico significa seleziona tutti i campi delle tabelle)</p>
<p>possiamo utilizzare la keyword <strong>DISTINCT</strong> per rimuovere i duplicati dalle righe</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> Provincia
<span class="token keyword">FROM</span> Studenti<span class="token punctuation">;</span>
</code></pre>
<h2 id="giunzione">Giunzione</h2>
<p>Vediamo i vari modi di fare giunzioni tra tabelle in SQL:</p>
<h3 id="prodotto-cartesiano">Prodotto cartesiano</h3>
<p>è possibile combinare tutte le righe di due tabelle (prodotto cartesiano) semplicemente facendo:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Studenti<span class="token punctuation">,</span> Esami<span class="token punctuation">;</span>
</code></pre>
<p>oppure più esplicitamente</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Studenti <span class="token keyword">CROSS</span> <span class="token keyword">JOIN</span> Esami<span class="token punctuation">;</span>
</code></pre>
<h3 id="giunzione-classica">Giunzione classica</h3>
<p>realizzata con il comando <code>INNER JOIN</code> o più semplicemente <code>JOIN</code> si fa nel seguente modo:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Studenti <span class="token keyword">JOIN</span> Esami <span class="token keyword">ON</span> Matricola <span class="token operator">=</span> Candidato<span class="token punctuation">;</span>
</code></pre>
<h3 id="natural-join">Natural join</h3>
<p>La join naturale si va nel seguente modo</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Studenti <span class="token keyword">NATURAL</span> <span class="token keyword">JOIN</span> Esami<span class="token punctuation">;</span>
</code></pre>
<p>È possibile specificare le colonne su cui effettuare la natural join utilizzando la keyword <code>USING()</code> specificando al suo interno le colonne</p>
<h3 id="left-right-e-full-outer-join">left, right e full outer join</h3>
<p>left join:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Studenti <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> Esami<span class="token punctuation">;</span>
</code></pre>
<p>right join:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Studenti <span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> Esami<span class="token punctuation">;</span>
</code></pre>
<p>full outer join:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Studenti <span class="token keyword">FULL</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> Esami<span class="token punctuation">;</span>
</code></pre>
<h2 id="notazione-con-il-punto">Notazione con il punto</h2>
<p>Quando si lavora con più di una tabella spesso è conveniente (in altri casi è necessario) specificare la tabella da cui si riferisce l’attributo.<br>
Per fare ciò utilizziamo la seguente sintassi</p>
<p><code>Tabella.Attributo</code></p>
<p>Es. generare una tabella che riporti Codice, Nome, Cognome dei docenti e Codice degli esami corrispondenti</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> Docenti<span class="token punctuation">.</span>CodDoc<span class="token punctuation">,</span> Docenti<span class="token punctuation">.</span>Nome<span class="token punctuation">,</span> Docenti<span class="token punctuation">.</span>Cognome<span class="token punctuation">,</span> Esami<span class="token punctuation">.</span>Codice
<span class="token keyword">FROM</span> Esami <span class="token keyword">JOIN</span> Docenti <span class="token keyword">ON</span> Docenti<span class="token punctuation">.</span>CodDoc <span class="token operator">=</span> Esami<span class="token punctuation">.</span>CodDoc<span class="token punctuation">;</span>
</code></pre>
<p>In quel esempio sia <code>Docenti</code> che <code>Esami</code> hanno una colonna chiamata <code>CodDoc</code> quindi è necessario specificare la tabella a cui si riferisce.</p>
<h2 id="alias">Alias</h2>
<p>Possiamo attribuire degli alias alle tabelle della clausola <code>FROM</code> questo torna particolarmente utile per migliorare la leggibilità delle query, quando però si lavora con tabelle ricorsive è necessario utilizzare gli alias.</p>
<p>Es. generare una tabella che contenga cognomi e matricole degli studenti e dei loro tutor</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> s<span class="token punctuation">.</span>Cognome<span class="token punctuation">,</span> s<span class="token punctuation">.</span>Matricola<span class="token punctuation">,</span> t<span class="token punctuation">.</span>Cognome<span class="token punctuation">,</span> t<span class="token punctuation">.</span>Matricola
<span class="token keyword">FROM</span> Studenti s <span class="token keyword">JOIN</span> Studenti t <span class="token keyword">ON</span> s<span class="token punctuation">.</span>Tutor <span class="token operator">=</span> t<span class="token punctuation">.</span>Matricola<span class="token punctuation">;</span>
</code></pre>
<h2 id="ridenominazione">Ridenominazione</h2>
<p>possiamo ridenominare le nostre colonne nella clausola <code>SELECT</code>, questo torna utile per rendere la tabella di output più chiara.<br>
Viene utilizzata la <em>keyword</em> <strong>AS</strong> e può essere usato per rinominare un attributo, un attributo calcolato oppure una funzione</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> Nome<span class="token punctuation">,</span> Cognome<span class="token punctuation">,</span> date_part<span class="token punctuation">(</span>‘year’<span class="token punctuation">,</span> <span class="token keyword">current_date</span><span class="token punctuation">)</span> <span class="token operator">-</span> Nascita <span class="token keyword">AS</span> Età
<span class="token keyword">FROM</span> Studenti
<span class="token keyword">WHERE</span> Provincia<span class="token operator">=</span>’VE’<span class="token punctuation">;</span>
</code></pre>
<p>come si vede abbiamo un campo calcolato <code>date_part(‘year’, current_date) - Nascita</code> che possiamo chiamare semplicemente <code>Età</code></p>
<h2 id="funzioni-di-aggregazione">Funzioni di aggregazione</h2>
<p>Le funzioni di aggregazione prendono in input tutte le righe di una o più colonne e restituiscono una riga oppure nessuna. Alcuni esempi di queste funzioni sono:</p>
<ul>
<li><strong>COUNT()</strong>: conta il numero di righe che non sono <code>NULL</code> (se tutte le righe sono <code>NULL</code> allora ritorna zero)</li>
<li><strong>SUM()</strong>: somma i valori numerici delle righe (se tutte le righe sono <code>NULL</code> allora ritorno <code>NULL</code>)</li>
<li><strong>AVG()</strong>: media dei valori numerici delle righe (se tutte le righe sono <code>NULL</code> allora ritorno <code>NULL</code>)</li>
<li><strong>MIN()</strong>: restituisce il minimo valore numerico delle righe (se tutte le righe sono <code>NULL</code> allora ritorno <code>NULL</code>)</li>
<li><strong>MAX()</strong>: restituisce il massimo valore numerico delle righe (se tutte le righe sono <code>NULL</code> allora ritorno <code>NULL</code>)</li>
</ul>
<p>queste funzioni possono solo essere utilizzate nel <code>SELECT</code> oppure nel <code>HAVING</code> ma <strong>non</strong> nel <code>WHERE</code></p>
<h2 id="order-by">Order by</h2>
<p>Tramite il comando <code>ORDER BY</code> è possibile ordinare i risultati di una query seguendo un ordine lessicografico.<br>
l’ordinamento crescente si indica con <code>ASC</code>, ed è impostato di default<br>
mentre l’ordinamento decrescente si indica con <code>DESC</code></p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> Nome<span class="token punctuation">,</span> Cognome
<span class="token keyword">FROM</span> Studenti
<span class="token keyword">WHERE</span> Provincia <span class="token operator">=</span> <span class="token string">'Ve'</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Cognome <span class="token keyword">DESC</span><span class="token punctuation">,</span> Nome <span class="token keyword">DESC</span><span class="token punctuation">;</span>
</code></pre>
<p>In questa query le righe vengono prima ordinate per cognome in ordine decrescente, e nel caso di righe con cognomi uguali si ordina per nome in ordine decrescente.</p>
<h2 id="operatori-insiemistici">Operatori insiemistici</h2>
<p>SQL permette di fare le basilari operazioni tra gli insiemi: unione, intersezione e differenza.<br>
Nota che è fondamentale che le colonne abbiano lo stesso nome e tipo per poter funzionare.</p>
<h3 id="unione">Unione</h3>
<p>Es. Nome, cognome e matricola degli studenti di Venezia e di quelli che hanno preso più di 28 in qualche esame</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> Nome<span class="token punctuation">,</span> Cognome<span class="token punctuation">,</span> Matricola
<span class="token keyword">FROM</span> Studenti
<span class="token keyword">WHERE</span> Provincia <span class="token operator">=</span> <span class="token string">'Ve'</span>
<span class="token keyword">UNION</span>
<span class="token keyword">SELECT</span> Nome<span class="token punctuation">,</span> Cognome<span class="token punctuation">,</span> Matricola
<span class="token keyword">FROM</span> Studenti <span class="token keyword">JOIN</span> Esami <span class="token keyword">ON</span> Matricola <span class="token operator">=</span> candidato
<span class="token keyword">WHERE</span> Voto <span class="token operator">&gt;</span> <span class="token number">28</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="differenza">Differenza</h3>
<p>Es. Le matricole degli studenti che non sono tutor</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> Matricola
<span class="token keyword">FROM</span> Studenti
<span class="token keyword">Except</span>
<span class="token keyword">SELECT</span> Tutor <span class="token keyword">AS</span> Matricola
<span class="token keyword">FROM</span> Studenti<span class="token punctuation">;</span>
</code></pre>
<h3 id="intersezione">Intersezione</h3>
<p>Es. Nome e cognome degli studenti che hanno preso in un esame 18 e in un altro esame 30</p>
<p>Nota che è importante aggiungere anche la matricola in questo caso per identificare le righe (anche se non è esplicitamente richiesto dalla consegna)</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> Nome<span class="token punctuation">,</span> Cognome<span class="token punctuation">,</span> Matricola
<span class="token keyword">FROM</span> Studenti <span class="token keyword">JOIN</span> Esami <span class="token keyword">ON</span> Matricola <span class="token operator">=</span> Candidato
<span class="token keyword">WHERE</span> Voto <span class="token operator">=</span> <span class="token number">18</span>
<span class="token keyword">INTERSECT</span>
<span class="token keyword">SELECT</span> Nome<span class="token punctuation">,</span> Cognome<span class="token punctuation">,</span> Matricola
<span class="token keyword">FROM</span> Studenti <span class="token keyword">JOIN</span> Esami <span class="token keyword">ON</span> Matricola <span class="token operator">=</span> Candidato
<span class="token keyword">WHERE</span> Voto <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="il-valore-null">Il valore NULL</h2>
<p>Il valore NULL si utilizza quando non si hanno informazioni a sufficienza per determinare il valore della colonna.</p>
<p>È importante <strong>non utilizzare l’uguale per comparare un valore con NULL</strong></p>
<p>NULL introduce un altro valore logico oltre a <code>true</code> e <code>false</code>, che è <code>unknown</code></p>
<p><code>NULL = 0</code> restituisce <code>unknown</code></p>
<p>Vediamo le tabelle di verità con il valore unknown:</p>
<p>Negazione:</p>

<table>
<thead>
<tr>
<th>p</th>
<th><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi></mrow><annotation encoding="application/x-tex">\lnot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord">¬</span></span></span></span></span>p</th>
</tr>
</thead>
<tbody>
<tr>
<td>U</td>
<td>U</td>
</tr>
</tbody>
</table><p>operazioni di AND e OR</p>

<table>
<thead>
<tr>
<th align="center">p</th>
<th align="center">q</th>
<th align="center">p <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\land</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.55556em; vertical-align: 0em;"></span><span class="mord">∧</span></span></span></span></span> q</th>
<th align="center">p <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∨</mo></mrow><annotation encoding="application/x-tex">\lor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.55556em; vertical-align: 0em;"></span><span class="mord">∨</span></span></span></span></span> q</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">T</td>
<td align="center">U</td>
<td align="center">U</td>
<td align="center">T</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">U</td>
<td align="center">F</td>
<td align="center">U</td>
</tr>
<tr>
<td align="center">U</td>
<td align="center">U</td>
<td align="center">U</td>
<td align="center">U</td>
</tr>
</tbody>
</table><p>Nei costrutti <code>WHERE</code> bisogna usare <code>IS</code> oppure <code>IS NOT</code> per il confronto con valori NULL</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Studenti
<span class="token keyword">WHERE</span> Tutor <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>
</code></pre>
<p>È possibile utilizzare <code>expr IS [NOT] DISTINCT FROM expr</code> per paragonare due espressioni considerando anche NULL:<br>
Infatti ritorna vero se entrambi i valori sono diversi, oppure quando uno dei due è NULL<br>
mentre è falso se i due valori sono uguali oppure quando entrambi sono NULL</p>
<p>è possibile anche utilizzare la funzione <code>COALESCE(expr1, expr2)</code> per attribuire un valore personalizzato al posto di NULL: la prima espressione della funzione dovrebbe essere il valore della riga che ci interessa, se quel valore dovesse essere NULL, verrà utilizzato il prossimo valore non null specificato come parametro.</p>
<h2 id="between">Between</h2>
<p>possiamo utilizzare la clausola <code>Between</code> per verificare che un valore sia in un determinato range</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Studenti
<span class="token keyword">WHERE</span> Matricola <span class="token operator">BETWEEN</span> <span class="token number">71000</span> <span class="token operator">AND</span> <span class="token number">72000</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="like">Like</h2>
<p>Questa clausola è molto utile per verificare se una stringa segue un determinato pattern</p>
<p>utilizziamo:</p>
<ul>
<li>“%” per indicare una sequenza di 0 o più caratteri</li>
<li>“_” per un singolo carattere</li>
</ul>
<p>Es. Studenti con il nome di almeno due caratteri che inizia per A</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Studenti
<span class="token keyword">WHERE</span> Nome <span class="token operator">LIKE</span> <span class="token string">'A_%'</span>
</code></pre>
<h2 id="clausola-where">Clausola where</h2>
<p>Vediamo nel dettaglio cosa è possibile fare con la clausola <code>WHERE</code></p>
<p>Abbiamo visto l’utilizzo più semplice in cui <strong>si compara una espressione con un’altra</strong><br>
ma possiamo fare anche delle comparazioni <strong>tra una espressione e una sottoselect</strong>.<br>
In fine abbiamo delle keyword che ci permettono di esprimere espressioni universali ed esistenziali, che sono <strong>EXIST, IN, ANY, ALL</strong></p>
<h3 id="sottoselect">Sottoselect</h3>
<p>Vediamo subito un esempio di sottoselect</p>
<p>“Studenti che vivono nella stessa provincia dello studente con matricola 71346, escluso lo studente stesso”</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Studenti
<span class="token keyword">WHERE</span> <span class="token punctuation">(</span>Matricola <span class="token operator">&lt;&gt;</span> <span class="token string">'71346'</span><span class="token punctuation">)</span> <span class="token operator">AND</span>
	   Provincia <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> Provincia
				    <span class="token keyword">FROM</span> Studenti
					<span class="token keyword">WHERE</span> Matricola <span class="token operator">=</span> <span class="token string">'71346'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>fare le sottoselect non è molto elegante infatti in molti casi è possibile fare la stessa cosa tramite le giunzioni.</p>
<h3 id="universale-e-esistenziale">Universale e esistenziale</h3>
<p>Può capitare che nella clausola where venga richiesta la presenza di almeno un valore (esistenziale) oppure la presenza di solamente uno specifico valore (universale)</p>
<p>è importante considerare le seguenti proprietà:</p>
<ul>
<li><strong>esistenziale = universale negata</strong><br>
ad esempio: esiste un voto diverso da 30 (esistenziale) = Non tutti i voti sono uguali 30 (universale)</li>
<li><strong>universale = esistenziale negata</strong><br>
ad esempio: Tutti i voti sono uguali a 30 (universale) = Non esiste un voto diverso da 30 (esistenziale)</li>
</ul>
<h3 id="exists">Exists</h3>
<p>L’utilizzo di <code>EXISTS</code> rappresenta <strong>l’esistenziale</strong>, segue la seguente forma:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">FROM</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>sottoselect<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<ul>
<li>Nota 1: Quando si utilizza <code>EXISTS</code> è necessario avere una <strong>correlazione</strong> tra le <strong>tabelle</strong> della select <strong>esterna</strong> e le <strong>tabelle nella sottoselect</strong></li>
<li>Nota 2: non è importante cosa viene selezionato nella sottoselect</li>
</ul>
<p>esempio: “La query studenti con almeno un voto &gt; 27”</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Studenti s
<span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>
			  <span class="token keyword">FROM</span> Esami <span class="token number">e</span>
			  <span class="token keyword">WHERE</span> <span class="token number">e</span><span class="token punctuation">.</span>Candidato <span class="token operator">=</span> s<span class="token punctuation">.</span>Matricola <span class="token operator">AND</span>
					<span class="token number">e</span><span class="token punctuation">.</span>Voto <span class="token operator">&gt;</span> <span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Spesso è possibile sostituire l’utilizzo della <code>EXISTS</code> con le giunzioni, la query precedente verrebbe così:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> s<span class="token punctuation">.</span><span class="token operator">*</span>
<span class="token keyword">FROM</span> Studenti s <span class="token keyword">JOIN</span> Esami <span class="token keyword">ON</span> <span class="token number">e</span><span class="token punctuation">.</span>Candidato <span class="token operator">=</span> s<span class="token punctuation">.</span>Matricola
<span class="token keyword">WHERE</span> <span class="token number">e</span><span class="token punctuation">.</span>voto <span class="token operator">&gt;</span> <span class="token number">27</span><span class="token punctuation">;</span>
</code></pre>
<p>nota che il <code>DISTINCT</code> è fondamentale in quanto non vogliamo che uno stesso studente venga selezionato tante volte quanti sono i suoi esami &gt; 27, ma lo vogliamo selezionare solo una volta</p>
<h3 id="any">ANY</h3>
<p>L’utilizzo di <code>ANY</code> rappresenta <strong>l’esistenziale</strong>, segue la seguente forma:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">FROM</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>expr<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>comparativo<span class="token operator">&gt;</span> <span class="token keyword">ANY</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>sottoselect<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Verifica se l’espressione soddisfa la comparazione con almeno un elemento della sottoselect</p>
<ul>
<li>Nota 1: Quando si utilizza <code>ANY</code> <strong>non è necessario</strong> avere una <strong>correlazione</strong> tra le tabelle della select esterna e le tabelle nella sottoselect</li>
<li>Nota 2: è importante cosa viene selezionato nella sottoselect</li>
<li>Nota 3: se la sottoselect è vuota restituisce falso</li>
</ul>
<p>realizziamo lo stesso esempio: “La query studenti con almeno un voto &gt; 27”</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Studenti s
<span class="token keyword">WHERE</span> s<span class="token punctuation">.</span>Matricola <span class="token operator">=</span><span class="token keyword">ANY</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">e</span><span class="token punctuation">.</span>Candidato
					    <span class="token keyword">FROM</span> Esami <span class="token number">e</span>
					    <span class="token keyword">WHERE</span> <span class="token number">e</span><span class="token punctuation">.</span>Voto <span class="token operator">&gt;</span> <span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>La <code>ANY</code> e la <code>EXISTS</code> sono semanticamente equivalenti, la differenza sta nel fatto che nella <code>ANY</code> facciamo il confronto nel where esterno, mentre nell’<code>EXISTS</code> il confronto viene spostato nella where della sottoselect</p>
<p>la <code>ANY</code> restituisce:</p>
<ul>
<li>true: se esiste un valore che rende vero il confronto tra l’espressione e la sottoselect</li>
<li>false: se nella sottoselect tutti i valori non sono NULL ed non esiste nessun valore che rende vero il confronto</li>
<li>unknown: se nella sottoselect ci sono valori NULL e per tutti i valori non null il confronto risulta falso</li>
</ul>
<h3 id="in">IN</h3>
<p>L’utilizzo di <code>IN</code> rappresenta <strong>l’esistenziale</strong>, segue la seguente forma:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">FROM</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>expr<span class="token operator">&gt;</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>sottoselect<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>La <code>IN</code> non è altro che una <code>=ANY</code></p>
<p>Infatti la precedente query la possiamo scrivere come</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Studenti s
<span class="token keyword">WHERE</span> s<span class="token punctuation">.</span>Matricola <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">e</span><span class="token punctuation">.</span>Candidato
					    <span class="token keyword">FROM</span> Esami <span class="token number">e</span>
					    <span class="token keyword">WHERE</span> <span class="token number">e</span><span class="token punctuation">.</span>Voto <span class="token operator">&gt;</span> <span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>si può utilizzare anche per verificare che una espressione sia contenuta in una lista di valori</p>
<p>es. “Gli studenti di Padova, Venezia e Belluno”</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Studenti
<span class="token keyword">WHERE</span> Provincia <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'PD'</span><span class="token punctuation">,</span> <span class="token string">'VE'</span><span class="token punctuation">,</span> <span class="token string">'BL'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="not-exists">Not Exists</h3>
<p>L’utilizzo di <code>NOT EXISTS</code> rappresenta <strong>l’universale</strong>, segue la seguente forma:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">FROM</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">WHERE</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>sottoselect<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Sfruttando la proprietà che abbiamo detto in precedenza possiamo rappresentare un universale facendo la negazione dell’esistenziale e negando anche la proprietà da verificare.</p>
<p>Vediamo un esempio:</p>
<p>“Gli studenti che hanno preso solo 30”</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Studenti s
<span class="token keyword">WHERE</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>
				  <span class="token keyword">FROM</span> Esami <span class="token number">e</span>
				  <span class="token keyword">WHERE</span> <span class="token number">e</span><span class="token punctuation">.</span>Candidato <span class="token operator">=</span> s<span class="token punctuation">.</span>Matricola <span class="token operator">AND</span> <span class="token number">e</span><span class="token punctuation">.</span>Voto <span class="token operator">&lt;&gt;</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="all">ALL</h3>
<p>L’utilizzo di <code>ALL</code> rappresenta <strong>l’universale</strong>, segue la seguente forma:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">FROM</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>expr<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>comparativo<span class="token operator">&gt;</span> <span class="token keyword">ALL</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>sottoselect<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>è il corrispettivo di <code>ANY</code> ma per l’universale.</p>
<ul>
<li>Nota 1: Quando si utilizza <code>ALL</code> è necessario avere una <strong>correlazione</strong> tra le <strong>tabelle</strong> della select <strong>esterna</strong> e le <strong>tabelle nella sottoselect</strong></li>
<li>Nota 3: se la sottoselect è vuota restituisce true</li>
</ul>
<p>Vediamo l’esempio precedente:</p>
<p>“Gli studenti che hanno preso solo 30”</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Studenti s
<span class="token keyword">WHERE</span> s<span class="token punctuation">.</span>Matricola <span class="token operator">&lt;&gt;</span><span class="token keyword">ALL</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">e</span><span class="token punctuation">.</span>Candidato
					     <span class="token keyword">FROM</span> Esami <span class="token number">e</span>
					     <span class="token keyword">WHERE</span> <span class="token number">e</span><span class="token punctuation">.</span>Voto <span class="token operator">&lt;&gt;</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>la <code>ALL</code> restituisce:</p>
<ul>
<li>true: se tutti i valore della sottoselect sono diversi da NULL e ogni elemento della sottoselect rende vero il confronto</li>
<li>false: se esiste un elemento della sottoselect che rende false il confronto</li>
<li>unknown: se nella sottoselect ci sono dei NULL e tutti quelli che non sono NULL rendono vero il confronto.</li>
</ul>
<p>il fatto che se la sottoselect restituisce tutti valori NULL allora l’universale restituisce true potrebbe non essere quello che vogliamo veramente:</p>
<p>la query precedente oltre a selezionare gli studenti che hanno preso solo 30, seleziona anche gli studenti che non hanno sostenuto alcun esame.<br>
Per poter selezionare esclusivamente gli studenti che hanno sostenuto almeno un esame dobbiamo modificare la query nel seguente modo</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Studenti s
<span class="token keyword">WHERE</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>
				  <span class="token keyword">FROM</span> Esami <span class="token number">e</span>
				  <span class="token keyword">WHERE</span> <span class="token number">e</span><span class="token punctuation">.</span>Candidato <span class="token operator">=</span> s<span class="token punctuation">.</span>Matricola <span class="token operator">AND</span> <span class="token number">e</span><span class="token punctuation">.</span>Voto <span class="token operator">&lt;&gt;</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	  <span class="token operator">AND</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>
				  <span class="token keyword">FROM</span> Esami <span class="token number">e</span>
				  <span class="token keyword">WHERE</span> <span class="token number">e</span><span class="token punctuation">.</span>Candidato <span class="token operator">=</span> s<span class="token punctuation">.</span>Matricola<span class="token punctuation">)</span>
</code></pre>
<h2 id="raggruppamento">Raggruppamento</h2>
<p>Con il raggruppamento creiamo dei gruppi composte da rige su cui possiamo fare delle operazioni mirate all’intero gruppo.</p>
<p>La forma di utilizzo è la seguente</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">FROM</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">WHERE</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token keyword">HAVING</span> <span class="token operator">&lt;</span>condizione<span class="token operator">&gt;</span><span class="token punctuation">]</span>
</code></pre>
<p>dove having permette di fare delle operazioni sui gruppi, diversamente dalla clausola <code>WHERE</code> in questo caso è possibile usare le funzioni di aggregazione</p>
<p>Vediamo subito un esempio:</p>
<p>“Per ogni materia, trovare nome della materia e voto medio degli esami in quella materia (selezionando solo le materie per le quali sono stati sostenuti più di tre esami)”</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token number">e</span><span class="token punctuation">.</span>Materia<span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span><span class="token number">e</span><span class="token punctuation">.</span>Voto<span class="token punctuation">)</span>
<span class="token keyword">FROM</span> Esami <span class="token number">e</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token number">e</span><span class="token punctuation">.</span>Materia
<span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">3</span><span class="token punctuation">;</span>
</code></pre>
<p>Nota che gli attributi che non sono argomento di una funzione di aggregazione nella <code>select</code> e nel <code>having</code>, vanno messi nel <code>GROUP BY</code></p>
<p>mentre gli attributi presenti nelle funzioni di aggregazione non devono essere presenti nel group by</p>
<h2 id="insert">INSERT</h2>
<p>con il comando <code>INSERT INTO</code> possiamo aggiungere una riga ad una tabella. La sintassi è la seguente:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> tabella<span class="token punctuation">(</span>colonna_1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> colonna_n<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span>valore_1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> valore_n<span class="token punctuation">)</span>
</code></pre>
<p>Alternativamente è anche possibile inserire dei valori che sono il risultato di una select:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> tabella<span class="token punctuation">(</span>nome<span class="token punctuation">,</span> cognome<span class="token punctuation">)</span>
	<span class="token keyword">SELECT</span> nome<span class="token punctuation">,</span> cognome <span class="token keyword">FROM</span> tabella
</code></pre>
<h2 id="delete">DELETE</h2>
<p>la <code>DELETE</code> serve per eliminare righe dalle tabelle.<br>
La sintassi è la seguente:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> tabella
<span class="token keyword">WHERE</span> condizione
</code></pre>
<p>Vengono eliminate le righe che rispettano la condizione.</p>
<p>Nota che fare:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> tabella
</code></pre>
<p>cancella tutte le righe della tabella, la tabella rimane comunque presente</p>
<h2 id="update">UPDATE</h2>
<p>con <code>UPDATE</code> è possibile aggiornare i valori di una o più righe esistenti.<br>
La sintassi è la seguente:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">UPDATE</span> tabella
<span class="token keyword">SET</span> attributo_1<span class="token operator">=</span>valore_1<span class="token punctuation">,</span> attributo_n<span class="token operator">=</span>valore_n
<span class="token keyword">WHERE</span> condizione
</code></pre>
<h2 id="case-when-then-else">CASE WHEN THEN ELSE</h2>
<p>In sql abbiamo il corrispettivo del costrutto if-then-else della classica programmazione.<br>
La sintassi è la seguente:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">CASE</span>
	<span class="token keyword">WHEN</span> condizione_1 <span class="token keyword">THEN</span> valore_1
	<span class="token keyword">WHEN</span> condizione_2 <span class="token keyword">THEN</span> valore_2
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">ELSE</span> valore_default
<span class="token keyword">END</span> <span class="token keyword">AS</span> alias
</code></pre>
<p>può avere vari utilizzi, ad esempio nella select:</p>
<pre class=" language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> Matricola<span class="token punctuation">,</span>
	<span class="token keyword">CASE</span>  
		<span class="token keyword">WHEN</span> YEAR<span class="token punctuation">(</span><span class="token keyword">CURRENT_DATE</span><span class="token punctuation">)</span> <span class="token operator">-</span> Nascita <span class="token operator">&gt;=</span> <span class="token number">18</span>  <span class="token keyword">THEN</span>  <span class="token string">'Maggiorenne'</span>  
		<span class="token keyword">ELSE</span>  <span class="token string">'Minorenne'</span>  
	<span class="token keyword">END</span> <span class="token keyword">AS</span> maggiore_età
<span class="token keyword">FROM</span> Studenti<span class="token punctuation">;</span>
</code></pre>

    </div>
  </div>
</body>

</html>
