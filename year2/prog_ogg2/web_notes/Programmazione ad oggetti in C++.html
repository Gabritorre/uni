<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2024-04-23_Programmazione ad oggetti in C++</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#programmazione-ad-oggetti-in-c">Programmazione ad oggetti in C++</a>
<ul>
<li><a href="#concetto-di-dichiarazione-in-c">Concetto di “dichiarazione” in C++</a></li>
<li><a href="#costruttori">Costruttori</a></li>
<li><a href="#passaggio-dei-parametri-valore-e-reference">Passaggio dei parametri, valore e reference</a></li>
<li><a href="#costruttori-di-conversione-e-explicit">Costruttori di conversione e “explicit”</a></li>
<li><a href="#copy-constructor">Copy constructor</a></li>
<li><a href="#this">This</a></li>
<li><a href="#const">Const</a></li>
<li><a href="#virtual">Virtual</a></li>
<li><a href="#ereditarietà">Ereditarietà</a></li>
<li><a href="#modi-di-istanziare-un-oggetto">Modi di istanziare un oggetto</a></li>
<li><a href="#template">Template</a></li>
<li><a href="#override-degli-operatori">Override degli operatori</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="programmazione-ad-oggetti-in-c">Programmazione ad oggetti in C++</h1>
<p>C++ è un linguaggio fortemente tipato capace di supportare</p>
<ul>
<li>programmazione funzionale</li>
<li>programmazione ad oggetti</li>
<li>programmazione generica</li>
</ul>
<p>Utilizza una convenzione di stile di tipo <em>snake_case</em></p>
<p>La definizione di nuovi tipi di dato può avvenire con due parole chiave: <code>struct</code> e <code>class</code>.</p>
<p>La differenza tra la due è la visibilità di default:</p>
<ul>
<li><code>struct</code> la visibilità di default del suo contenuto è <code>public</code></li>
<li><code>class</code> la visibilità di default del suo contenuto è <code>private</code></li>
</ul>
<p>Le uniche visibilità presenti in C++ sono le seguenti:</p>
<ul>
<li><strong>public</strong>: visibile a chiunque</li>
<li><strong>protected</strong>: visibile solo all’interno della classe e ai propri figli</li>
<li><strong>private</strong>: visibile solo all’interno della classe</li>
</ul>
<h2 id="concetto-di-dichiarazione-in-c">Concetto di “dichiarazione” in C++</h2>
<p>In C++ non esiste un vero e proprio concetto di dichiarazione di variabili come avviene in C:</p>
<ul>
<li>in C si può parlare di dichiarazione perché quello che accade è che una zona di memoria viene riservata e gli viene dato un nome</li>
<li>in C++ ogni volta che si crea una variabile la si “costruisce” tramite il proprio costruttore di default (questo vale anche per i tipi primitivi), quindi oltre a riservare la zona di memoria tale zona viene anche inizializzata ad un valore di default</li>
</ul>
<p>Scrivere la seguente cosa in C++</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token keyword">int</span> a<span class="token punctuation">;</span>
</code></pre>
<p>equivale a chiamare il costruttore di default sulla variabile:</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token keyword">int</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>In C++ si chiama <strong>oggetto</strong> una area di memoria dotata di un tipo.</p>
<p>Quindi nel caso precedente <code>a</code> è un <strong>oggetto di tipo int</strong><br>
è quindi possibile fare anche</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token keyword">int</span> <span class="token function">var</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//viene chiamato il copy constructor di int</span>
</code></pre>
<h2 id="costruttori">Costruttori</h2>
<p>I costruttori vanno realizzati con le <strong>liste di inizializzazione</strong> quando possibile:</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">class</span> <span class="token class-name">animal</span><span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> weight<span class="token punctuation">;</span>
	<span class="token keyword">int</span> speed<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>		<span class="token comment">//senza lista di inizalizzazione</span>
		weight <span class="token operator">=</span>  <span class="token number">10</span><span class="token punctuation">;</span>
		speed <span class="token operator">=</span>  <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">weight</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">speed</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span><span class="token punctuation">}</span>		<span class="token comment">//con lista di inizializzazione</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Entrambi i costruttori fanno la stessa cosa, il secondo però fa utilizzo delle liste di inizializzazione.</p>
<p>L’utilizzo delle liste di inizializzazione è consigliato per due motivi principali:</p>
<ul>
<li>
<p><strong>Ottimizzazione</strong>: Nel primo caso quando viene chiamato il costruttore prima vengono create le variabile inizializzate con il loro valore di default (tramite il <em>default constructor</em>) e successivamente gli vengono assegnati i valori da noi decisi.<br>
Nel secondo caso invece le variabili vengono dichiarate e inizializzate direttamente con i valori da noi decisi (utilizzando il <em>copy constructor</em> della variabile).</p>
</li>
<li>
<p><strong>Inizializzazione di costanti</strong>: se nel codice di prima al posto di  <code>int a</code>  fosse stato  <code>const int a</code>  in quel caso solo il secondo metodo funzionerebbe, in quanto una assegnazione successiva all’inizializzazione tramite il <em>default constructor</em> non sarebbe permessa.</p>
</li>
</ul>
<h2 id="passaggio-dei-parametri-valore-e-reference">Passaggio dei parametri, valore e reference</h2>
<p>Vediamo 3 modi in cui si può passare un oggetto ad una funzione</p>
<ul>
<li>passaggio per copia: viene creato un nuovo oggetto creato tramite il <strong>copy constructor</strong> dell’oggetto originale<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">void</span> <span class="token function">f</span> <span class="token punctuation">(</span>my_obj<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre>
</li>
<li>passaggio del puntatore: viene passata la copia del puntatore dell’oggetto<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">void</span> <span class="token function">f</span> <span class="token punctuation">(</span>my_obj<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre>
</li>
<li>passaggio della reference: viene passato la reference, cioè un alias, della variabile originale. In questo caso si sta usando direttamente l’oggetto originale<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">void</span> <span class="token function">f</span> <span class="token punctuation">(</span>my_obj<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre>
</li>
</ul>
<h2 id="costruttori-di-conversione-e-explicit">Costruttori di conversione e “explicit”</h2>
<p>Un costruttore con un singolo parametro che non ha un valore di default  e che <strong>non</strong> viene dichiarato <code>explicit</code> è chiamato <strong>costruttore di conversione</strong>.</p>
<p>Un costruttore di conversione esegue una conversione implicita che converte un oggetto cha ha il tipo del primo parametro del costruttore di conversione in un oggetto del tipo della classe a cui il costruttore di conversione appartiene.</p>
<p>La keyword <em>explicit</em> associata ad un costruttore di conversione impedisce il comportamento appena descritto, forzando il chiamante ad usare i costruttori con i tipi corretti.</p>
<p>Vediamo il comportamento dei costruttori di conversione:</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">class</span> <span class="token class-name">Y</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span><span class="token operator">:</span>
	  <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
	  <span class="token keyword">char</span> <span class="token operator">*</span> name<span class="token punctuation">;</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
	  <span class="token function">Y</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>	<span class="token comment">//converte int a oggetti di tipo Y</span>
	  <span class="token function">Y</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>	<span class="token comment">//converte stringhe a oggetti di tipo Y</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Y<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>		<span class="token comment">//metodo che apparentemente prende solo oggetti di tipo Y</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// equivalente a Y obj1 = Y(2)</span>
  Y obj1 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

  <span class="token comment">// equivalente a Y obj2 = Y("somestring",0)</span>
  Y obj2 <span class="token operator">=</span> <span class="token string">"somestring"</span><span class="token punctuation">;</span>

  <span class="token comment">// equivalente a add(Y(5))</span>
  <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>È interessante la chiamata al metodo <code>add</code> che nonostante chieda un oggetto di tipo Y, passandogli un intero la chiamata avviene correttamente comunque in quanto il compilatore chiama implicitamente il costruttore di <code>Y</code> che prende un intero, creando così un oggetto di tipo <code>Y</code></p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>      <span class="token comment">// converting constructor</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token comment">// converting constructor (C++11)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">struct</span> B <span class="token punctuation">{</span>
    <span class="token keyword">explicit</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token keyword">explicit</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    A a1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment">// OK: copy-initialization selects A::A(int)</span>
    A <span class="token function">a2</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// OK: direct-initialization selects A::A(int)</span>
    A a3 <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">// OK: direct-list-initialization selects A::A(int, int)</span>
    A a4 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// OK: copy-list-initialization selects A::A(int, int)</span>
    A a5 <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// OK: explicit cast performs static_cast</span>
 
<span class="token comment">//  B b1 = 1;      // error: copy-initialization does not consider B::B(int)</span>
    B <span class="token function">b2</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// OK: direct-initialization selects B::B(int)</span>
    B b3 <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">// OK: direct-list-initialization selects B::B(int, int)</span>
<span class="token comment">//  B b4 = {4, 5}; // error: copy-list-initialization does not consider B::B(int, int)</span>
    B b5 <span class="token operator">=</span> <span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// OK: explicit cast performs static_cast</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="copy-constructor">Copy constructor</h2>
<p>Il copy constructor è un costruttore che utilizza una altro oggetto gemello inizializzare i propri valori con i suoi.</p>
<p>Si realizza nel seguente modo</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">class</span> <span class="token class-name">animal</span><span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> weight<span class="token punctuation">;</span>
	<span class="token keyword">int</span> speed<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">weight</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">speed</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span><span class="token punctuation">}</span>		<span class="token comment">//constructor</span>
	<span class="token function">animal</span><span class="token punctuation">(</span><span class="token keyword">const</span> animal<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token function">weight</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">speed</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>speed<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>	<span class="token comment">//copy constructor</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Il <code>const</code> sta ad indicare che il parametro non viene modificato all’interno della funzione<br>
la reference è necessaria perché altrimenti si genererebbe una ricorsione infinita, se venisse passato per copia verrebbe chiamato il copy constructor, ma noi in questo lo stiamo definendo in questo momento.</p>
<h2 id="this">This</h2>
<p><code>this</code> in questo caso è un pointer all’oggetto e quindi lo si usa sempre con <code>-&gt;</code> invece che con <code>.</code></p>
<p>Come dimostrazione vediamo che la seguente assegnazione non genera errori:</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">class</span> <span class="token class-name">animal</span><span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> weight<span class="token punctuation">;</span>
	<span class="token keyword">int</span> speed<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">weight</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">speed</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span><span class="token punctuation">}</span>		<span class="token comment">//constructor</span>
	<span class="token function">animal</span><span class="token punctuation">(</span><span class="token keyword">const</span> animal<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token function">weight</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">speed</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>speed<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>	<span class="token comment">//copy constructor</span>
	
	<span class="token keyword">int</span> <span class="token function">get_weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		animal<span class="token operator">*</span> a <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>	<span class="token comment">//funziona</span>
		<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>weight<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="const">Const</h2>
<p>Il <code>const</code> ha sia il significato che non è modificabile sia che può interagire solo con costrutti a loro volta dichiarati <code>const</code>.</p>
<p>Una buona regola quando si dichiarano le funzioni è di partire sempre da metodi <code>const variabile&amp;</code> questo perché è l’approccio più restrittivo.<br>
Nel caso si avesse bisogno di modificare la variabile allora si toglie il <code>const</code>.<br>
Qual ora si volesse una copia e non la variabile originale si toglie la <code>&amp;</code>.</p>
<p>il <code>const</code> si può anche mettere alla fine della firma di un metodo, e sta ad indicare che all’interno di quel metodo non si modificano i campi della classe.</p>
<p>Questo ci porta a definire <strong>due tipi di getter</strong> in C++, uno passato in sola lettura e uno anche in scrittura</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">class</span> <span class="token class-name">animal</span><span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> weight<span class="token punctuation">;</span>
	<span class="token keyword">int</span> speed<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">weight</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">speed</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span><span class="token punctuation">}</span>		<span class="token comment">//constructor</span>
	<span class="token function">animal</span><span class="token punctuation">(</span><span class="token keyword">const</span> animal<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token function">weight</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">speed</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>speed<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>	<span class="token comment">//copy constructor</span>
	
	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">get_weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>		<span class="token comment">//getter che restituisce il campo in sola lettura</span>
		<span class="token keyword">return</span> weight<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">get_weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>					<span class="token comment">//getter che restituisce il campo anche in scrittura</span>
		<span class="token keyword">return</span> weight<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Il const alla fine della firma permette di separare le due firme e quindi di fare un <strong>overload</strong></p>
<h2 id="virtual">Virtual</h2>
<p>I metodi che si vuole permettere di far sovrascrivere ai propri figli si devono marcare come <code>virtual</code></p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">class</span> <span class="token class-name">animal</span><span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> weight<span class="token punctuation">;</span>
	<span class="token keyword">int</span> speed<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">weight</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">speed</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span><span class="token punctuation">}</span>
	<span class="token function">animal</span><span class="token punctuation">(</span><span class="token keyword">const</span> animal<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token function">weight</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">speed</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>speed<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
	
	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">get_weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>		<span class="token comment">//getter che restituisce il campo in sola lettura</span>
		<span class="token keyword">return</span> weight<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">get_weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>					<span class="token comment">//getter che restituisce il campo anche in scrittura</span>
		<span class="token keyword">return</span> weight<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token keyword">const</span> animal<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">//metodo overridabile dai figli</span>
		weight <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="ereditarietà">Ereditarietà</h2>
<p>La sintassi per ereditare da una classe è la seguente</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">class</span> <span class="token class-name">dog</span> <span class="token operator">:</span> <span class="token keyword">public</span> animal <span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Il tag della visibilità ha il seguente significato:</p>
<ul>
<li>se <strong>public</strong> significa che chiunque può vedere che sono figlio di quella classe, per cui chiunque può sostituirmi al posto di mio padre</li>
<li>se <strong>protected</strong> significa che solo i miei figli sono al corrente che sono figlio di quella classe e quindi solo loro possono sostituirmi al posto di mio padre</li>
<li>se <strong>private</strong> significa che nessuno può sostituirmi al posto di mio padre</li>
</ul>
<p>La classe figlio ha un puntatore al padre come campo privato.</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">class</span> <span class="token class-name">dog</span> <span class="token operator">:</span> <span class="token keyword">public</span> animal <span class="token punctuation">{</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		<span class="token keyword">bool</span> has_pedigree<span class="token punctuation">;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">dog</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">double</span> sp<span class="token punctuation">,</span> <span class="token keyword">bool</span> ped<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">animal</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> sp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">has_pedigree</span><span class="token punctuation">(</span>ped<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

		<span class="token comment">//in c++11 si può mettere "override" alla fine della firma per specificare che si tratta di override</span>
		<span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token keyword">const</span> animal<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> override <span class="token punctuation">{</span>
			<span class="token comment">// weight += a.weight / 2;			//il weight di a non è accessibile perche è esterno e non è quello ereditato</span>
			weight <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">get_weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>		<span class="token comment">//modifica diretta</span>
			<span class="token function">get_weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">get_weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>	<span class="token comment">//modifica tramite il getter in scrittura</span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>Nota: diversamente da Java, se ricevi come parametro un oggetto dello stesso tipo della classe in cui stai lavorando non è comunque possibile accedere ai suoi campi privati, vanno usati i getter.</p>
<p>Se si vuole permettere ai propri figli di sovrascrivere un metodo già sovrascritto va aggiunto ancora il <code>virtual</code></p>
<h2 id="modi-di-istanziare-un-oggetto">Modi di istanziare un oggetto</h2>
<p>Vediamo 3 modi per istanziare un oggetto</p>
<ol>
<li>tramite la keyword <code>new</code>, che ritorna un puntatore al nuovo oggetto che è stato creato nell’heap</li>
<li>istanziamento direttamente nello stack</li>
<li>instanziamento tramite <em>reference</em> di un altro oggetto</li>
</ol>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">class</span> <span class="token class-name">animal</span><span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> weight<span class="token punctuation">;</span>
	<span class="token keyword">int</span> speed<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">weight</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">speed</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span><span class="token punctuation">}</span>
	<span class="token function">animal</span><span class="token punctuation">(</span><span class="token keyword">const</span> animal<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token function">weight</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">speed</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>speed<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
	
	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">get_weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> weight<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">get_weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> weight<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token keyword">const</span> animal<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		weight <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">dog</span> <span class="token operator">:</span> <span class="token keyword">public</span> animal <span class="token punctuation">{</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		<span class="token keyword">bool</span> has_pedigree<span class="token punctuation">;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">dog</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">double</span> sp<span class="token punctuation">,</span> <span class="token keyword">bool</span> ped<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">animal</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> sp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">has_pedigree</span><span class="token punctuation">(</span>ped<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

		<span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token keyword">const</span> animal<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> override <span class="token punctuation">{</span>
			weight <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">get_weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	animal<span class="token operator">*</span> a1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">animal</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//istanziamento nell'heap</span>
	animal <span class="token function">a2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">//istanziamento nello stack</span>

	animal <span class="token function">a3</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span>						<span class="token comment">//copy constructor</span>
	animal a4<span class="token punctuation">;</span>						<span class="token comment">//default constructor</span>

	dog <span class="token function">fido</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">45.2</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	animal <span class="token function">a5</span><span class="token punctuation">(</span>fido<span class="token punctuation">)</span><span class="token punctuation">;</span>
	a5<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">//no dynamic dispatch</span>

	animal<span class="token operator">&amp;</span> a6 <span class="token operator">=</span> fido<span class="token punctuation">;</span>					<span class="token comment">//instanziamento tramite reference</span>
	a6<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">//si dynamic dispatch</span>

	animal<span class="token operator">*</span> a7 <span class="token operator">=</span> <span class="token operator">&amp;</span>fido<span class="token punctuation">;</span>
	a7<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">eat</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">//si dynamic dispatch</span>
	
<span class="token punctuation">}</span>
</code></pre>
<p>Nota che il dynamic dispatch si ha solo con puntatori e reference, questo perche con l’istanziazione di <code>a5</code> vengono copiati i valori dei campi ma il suo tipo rimane sempre un animal, anche a <em>runtime</em>.</p>
<p>Mentre con reference e puntatori il tipo dinamico a runtime cambia da quello statico e il dynamic dispatch funziona</p>
<h2 id="template">Template</h2>
<p>approfondimento: <a href="https://gabritorre.github.io/uni/year1/prog_lab/web_notes/Templates.html">template (corso PEL)</a></p>
<p>I template sono la trasposizione dei tipi generici visti in Java.</p>
<p>Una particolarità dei template è che posticipano la compilazione del codice che usa i template fino a quando non verrà utilizzato tale codice passandogli il tipo reale.</p>
<p>Ad esempio se definiamo una funzione che fa uso di template, tale funzione non verrà compilata fino a che non viene chiamata da qualcuno che gli passerà il tipo da sostituire al tipo generico, a quel punto viene compilata.</p>
<h2 id="override-degli-operatori">Override degli operatori</h2>
<p>In C++ tutti gli operatori: <code>+ - * / &lt; &lt;= &gt; &gt;= != () =</code> ecc… eseguiti su oggetti non <em>built-in</em><br>
sono in realtà delle <strong>chiamate a funzioni</strong> e come tali si possono overridare.</p>
<p>Vediamo un esempio:</p>
<pre class=" language-cpp"><code class="prism  language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">matrix</span> <span class="token punctuation">{</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		size_t cols<span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">matrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">v</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
		<span class="token function">matrix</span><span class="token punctuation">(</span><span class="token keyword">const</span> matrix<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> m<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">v</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

		matrix<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> matrix<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			cols <span class="token operator">=</span> m<span class="token punctuation">.</span>cols<span class="token punctuation">;</span>
			v <span class="token operator">=</span> m<span class="token punctuation">.</span>v<span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> 


<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	matrix<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	matrix<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">m2</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	m <span class="token operator">=</span> m2<span class="token punctuation">;</span> 	<span class="token comment">//equivalente a: m.operator=(m2);</span>

	m <span class="token operator">=</span> m2 <span class="token operator">=</span> m<span class="token punctuation">;</span> <span class="token comment">//	m.operator=(m2.operator=(m));</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Per sovrascrivere un operatore bisogna ridefinire la funzione chiamata “operator” concatenato al simbolo dell’operatore, nel caso precedente <code>operator=</code></p>
<p>Quando facciamo <code>m = m2</code> implicitamente stiamo facendo <code>m.operator=(m2)</code>, cioè una chiamata a funzione che prende in input il membro di sinistra dell’operatore di assegnamento.</p>
<p>Nota il tipo di ritorno è arbitrario, si potrebbe anche lasciare <code>void</code>, però restituire una reference dell’oggetto stesso ci permette di annestare le chiamate a tale funzione, cioè rende possibile fare:</p>
<pre class=" language-c"><code class="prism ++ language-c">m <span class="token operator">=</span> m2 <span class="token operator">=</span> m<span class="token punctuation">;</span> <span class="token comment">//equivalente a:	m.operator=(m2.operator=(m));</span>
</code></pre>
<p>funziona in quanto <code>m2.operator=(m)</code> ritorna un oggetto che viene usato a sua volta nella successiva chiamata alla funzione.</p>

    </div>
  </div>
</body>

</html>
