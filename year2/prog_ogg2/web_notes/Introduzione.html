<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2024-02-13_Introduzione</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#note-introduttive">Note introduttive</a>
<ul>
<li><a href="#classificazione-dei-linguaggi">Classificazione dei linguaggi</a></li>
<li><a href="#linguaggio-orientato-agli-oggetti">Linguaggio orientato agli oggetti</a></li>
<li><a href="#classe-e-oggetto">Classe e oggetto</a></li>
<li><a href="#tipi-statici-e-dinamici">Tipi statici e dinamici</a></li>
<li><a href="#classi-astratte-e-interfacce">Classi astratte e interfacce</a></li>
<li><a href="#tipi-generici-vs-object">Tipi generici vs Object</a></li>
<li><a href="#parametri-formali-e-attuali">Parametri formali e attuali</a></li>
<li><a href="#tipo-argomento-e-tipo-parametro">Tipo argomento e tipo parametro</a></li>
<li><a href="#eccezioni-checked-e-unchecked">Eccezioni checked e unchecked</a></li>
<li><a href="#dimensione-di-un-oggetto">Dimensione di un oggetto</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="note-introduttive">Note introduttive</h1>
<p>Ripassiamo alcuni concetti che abbiamo affrontato nel modulo 1.</p>
<h2 id="classificazione-dei-linguaggi">Classificazione dei linguaggi</h2>
<p>differenza tra: inizializzazione, dichiarazione, assegnamento</p>
<ul>
<li>dichiarazione: creare una nuova variabile specificando il <strong>tipo</strong> e il <strong>nome</strong>.</li>
<li>assegnamento: dare un valore ad una variabile già creata in precedenza</li>
<li>Inizializzazione: consiste nel dichiarare una variabile e assegnargli subito un valore</li>
</ul>
<p>I linguaggi di programmazione si dividono principalmente in <strong>imperativi e funzionali</strong>:<br>
si differenziano dalla presenza o meno dell’operatore di <strong>assegnazione</strong>, infatti nei linguaggi funzionali non è possibile fare assegnazioni, ma solo inizializzazioni.</p>
<h2 id="linguaggio-orientato-agli-oggetti">Linguaggio orientato agli oggetti</h2>
<p>Java è un linguaggio imperativo orientato agli oggetti e basato sulle classi (sei obbligato a mettere il codice all’interno di una classe, anche se non vuoi utilizzare le classi)</p>
<p>La caratteristica distintiva tra un linguaggio orientato agli oggetti da uno che non è orientato agli oggetti è <strong>il polimorfismo</strong>, in particolare la Subsumption: “qualunque oggetto di una data classe X è anche istanza della superclasse di X.”<br>
Ad esempio, una istanza della classe Rettangolo può essere sempre usata dove ci si aspetti una qualunque FiguraGeometrica poiché un rettangolo <strong>è</strong> una figura geometrica.</p>
<h2 id="classe-e-oggetto">Classe e oggetto</h2>
<p>la Classe definisce come deve essere un tipo di dato, un oggetto è l’istanza di una classe cioè un valore con il tipo definito dalla sua classe.</p>
<h2 id="tipi-statici-e-dinamici">Tipi statici e dinamici</h2>
<p>Tipo statico e dinamico in Java:</p>
<ul>
<li>il tipo statico è deciso in <strong>compile time</strong>, cioè quello messo nella fase di dichiarazione della variabile (senza assegnarla)</li>
<li>il tipo dinamico è deciso in <strong>runtime</strong>, cioè il tipo dell’oggetto nella fase di assegnamento</li>
</ul>
<p>In Java possiamo dire di avere un <strong>dispatch dinamico sul ricevitore</strong> su cui è chiamata la funzione mentre abbiamo un <strong>dispatch statico sui parametri</strong> delle funzioni.</p>
<h2 id="classi-astratte-e-interfacce">Classi astratte e interfacce</h2>
<p>il significato di classi astratte e interfacce è molto simile tra loro, sono entrambi dei sistemi per creare dei sottotipi. La necessità di avere questa distinzione viene dal fatto che Java è un linguaggi in cui <strong>non è presente l’ereditarietà multipla</strong>, quindi puoi ereditare da una sola classe e poi implementare più interfacce.</p>
<h2 id="tipi-generici-vs-object">Tipi generici vs Object</h2>
<p>Da una analisi superficiale potrebbe sembrare che usare i tipi generici oppure Object sia la stessa cosa, in parte è vero in quanto entrambi permettono di poter mettere qualsiasi cosa come tipo di dato. Il problema di Object è che se venisse come tipo di dato per una collezione di dati, in tale collezione ci potrebbero finire dentro qualsiasi oggetto però noi saremo abbastanza limitati sulle operazioni che possiamo fare su tali oggetti:</p>
<ul>
<li>o utilizziamo solo metodi della classe Object.</li>
<li>o facciamo dei cast, con il rischio però di fare errori non conoscendo i veri tipi degli oggetti.</li>
</ul>
<p>Usando i tipi dinamici questo problema non si pone in quanto al momento della inizializzazione della collezione viene specificato il tipo dei dati che ci andremo ad inserire.</p>
<p>Nella documentazione di Java ci sono vari metodi che nonostante questo utilizzano comunque Object (vedi il metodo <code>contains</code> di ArrayList), questo perché Java ha introdotto i tipi dinamici svariate versioni dopo il rilascio iniziale e quindi per mantenere la compatibilità con le vecchie versioni Java utilizza ancora Object.</p>
<h2 id="parametri-formali-e-attuali">Parametri formali e attuali</h2>
<ul>
<li>Parametri formali: variabili presenti nella dichiarazione dei parametri dei metodi e che vengono poi utilizzati all’interno del metodo</li>
<li>parametri attuali: gli argomenti usati nella chiamata della funzione</li>
</ul>
<h2 id="tipo-argomento-e-tipo-parametro">Tipo argomento e tipo parametro</h2>
<ul>
<li>Tipi parametro: sono i nomi dei tipi generici messi nella fase di dichiarazione della classe o del metodo, che conterranno i tipi reali che verranno passati.</li>
<li>Tipi argomento: sono i tipi reali che vengono passati nella fase di dichiarazione di una classe oppure di chiamata di un metodo</li>
</ul>
<h2 id="eccezioni-checked-e-unchecked">Eccezioni checked e unchecked</h2>
<p>Quando stiamo implementando delle nostre classi,  facciamo un metodo che può non andare a buon fine, come gestiamo quel caso?</p>
<ul>
<li>ritornare <code>null</code></li>
<li>lanciare una eccezione checked</li>
<li>lanciare una eccezione unchecked</li>
</ul>
<p>Prendiamo ad esempio un metodo <code>get(int indice)</code> di una collezione di oggetti, esso può fallire nel caso si dia un indice al di fuori del limite della collezione.</p>
<ul>
<li>ritornare <code>null</code> non è una buona soluzione in quanto non esprime chiaramente che si è andati fuori dal limite dell’array e soprattutto bisognerebbe fare un <code>if</code> ogni volta che si chiama il metodo</li>
<li>lanciare una eccezione è la soluzione migliore, ma come decidere se usare una eccezione chekced oppure unckecked? scegliere una eccezione checked implica di costruire una propria eccezione (è una operazione raccomandata ma non obbligatoria), e dichiararla nella firma del metodo e poi il chiamante dovrà occuparsi di gestirla.<br>
Scegliere una unchecked risulta più comoda ma anche meno esplicativa in quanto sono eccezioni generiche.</li>
</ul>
<p>Per capire quale usare possiamo chiederci: “Se un utente cattura la mia eccezione checked può fare qualcosa di utile?”, “l’eccezione che lancio fa parte di un possibile risultato del metodo oppure rappresenta un errore raro”</p>
<p>Nel nostro caso, se il chiamante fa del codice corretto, è molto inusuale uscire dai limiti della collezione, inoltre se il chiamante prende l’eccezione non può fare niente di utile, inoltre gestire ogni get con dei try-catch risulta essere molto scomodo e allunga inutilmente il codice. Quindi si opta per una eccezione unchecked.</p>
<h3 id="sottotipo-di-una-eccezione-unchecked">Sottotipo di una eccezione unchecked</h3>
<p>potremmo chiederci se ha senso creare un sottotipo di una eccezione unchecked, la risposta è che non ha molto senso in quanto con una eccezione unchecked si prevede che il chiamante non gestirà le eccezioni con un try catch, quindi creare il proprio tipo speciale non avrebbe molto senso perche non verrebbe catturata mai.</p>
<h2 id="dimensione-di-un-oggetto">Dimensione di un oggetto</h2>
<p>la dimensione in byte di un oggetto è determinata da vari fattori della sua classe:</p>
<ul>
<li>la somma della dimensione degli attributi primitivi</li>
<li>per ogni attributo <em>reference type</em> (oggetto) si aggiunge la dimensione di un puntatore</li>
<li>per ogni metodo si aggiunge la dimensione di un puntatore</li>
<li>se si tratta di una sottoclasse si considerano anche gli attributi ereditati e i metodi ereditati non sovrascritti</li>
<li>attributi e metodi statici non vanno contati</li>
</ul>

    </div>
  </div>
</body>

</html>
