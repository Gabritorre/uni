<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2023-10-25_Gestione della memoria</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#gestione-della-memoria">Gestione della memoria</a>
<ul>
<li><a href="#modi-di-organizzare-i-programmi-in-memoria">Modi di organizzare i programmi in memoria</a></li>
<li><a href="#multiprogrammazione-a-partizioni-fisse">Multiprogrammazione a partizioni fisse</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="gestione-della-memoria">Gestione della memoria</h1>
<p>La memoria di un computer è divisa principalmente in tre livelli:</p>
<ul>
<li>memoria cache
<ul>
<li>molto costosa</li>
<li>molto veloce</li>
<li>molto piccola (da pochi KB fino ad un centinaio di MB)</li>
<li>spesso all’interno del processore o nelle immediate vicinanze</li>
</ul>
</li>
<li>memoria principale (RAM)
<ul>
<li>abbastanza costosa</li>
<li>velocità alta</li>
<li>dimensioni medie (svariati GB)</li>
</ul>
</li>
<li>memoria secondaria (HDD, SSD)
<ul>
<li>economica</li>
<li>lenta</li>
<li>molto grande (fino a vari TB)</li>
</ul>
</li>
</ul>
<p>La memoria principale è quella su cui ci concentreremo maggiormente e che richiede una attenta gestione</p>
<p>Generalmente ad ogni processo viene assegnata una porzione della memoria, questa porzione può essere allocata staticamente o dinamicamente. Il <strong>gestore della memoria</strong> è il componente del sistema operativo che si occupa di ottimizzare le porzioni di memoria assegnate ai processi decidendo:</p>
<ol>
<li>quanta memoria assegnare ad un processo</li>
<li>dove posizionare in memoria un processo</li>
<li>quale processo mandare in memoria (su richiesto o tramite previsione)</li>
<li>decidere quale processo sostituire quando la memoria si sta saturando</li>
<li>gestire gli scambi di memoria tra i vari livelli</li>
</ol>
<p>Nella <strong>memoria secondaria</strong> solitamente teniamo <strong>dati e programmi che non ci servono al momento</strong>.<br>
Nella <strong>memoria primaria</strong> teniamo <strong>i programmi necessari</strong> che potremmo usare al momento<br>
Nella <strong>memoria cache</strong> teniamo <strong>i dati utilizzati nell’immediato passato</strong></p>
<h2 id="modi-di-organizzare-i-programmi-in-memoria">Modi di organizzare i programmi in memoria</h2>
<p>Abbiamo principalmente due modi di organizzare la memoria dei processi:</p>
<ul>
<li>
<p><strong>allocazione contigua</strong><br>
un programma viene memorizzato come un blocco unico di indirizzi contigui in memoria.<br>
Basso overhead ma può essere che non sia possibili trovare un blocco abbastanza grande</p>
<p>ad esempio una allocazione contigua con un solo utente:<br>
<img src="https://i.ibb.co/TTftdVr/contigua.png" alt="enter image description here"></p>
</li>
<li>
<p><strong>allocazione non contigua</strong><br>
in programma viene diviso in blocco chiamati <strong>segmenti</strong>.<br>
ogni segmento può essere in parti diverse della memoria, questo permette di avere più processi in memoria contemporaneamente, ma ha anche un overhead maggiore.</p>
<p><strong>overlay</strong> è una tecnica di allocazione non contigua in cui un <strong>programma</strong> grande viene <strong>suddiviso in segmenti logici indipendenti</strong> che vengono caricate in memoria man mano che il programma è in esecuzione (non tutte insieme), in modo che i vari segmenti si sovrappongano in memoria (overlay).</p>
<p><img src="https://i.ibb.co/T8J4sFL/overlay.png" alt="enter image description here"></p>
</li>
</ul>
<h3 id="protezione-dellambiente">Protezione dell’ambiente</h3>
<p>in entrambi i metodi precedenti dobbiamo adottare delle tecniche per evitare che i processi danneggino in qualche modo il sistema, non vogliamo che un processo occupi o acceda alla memoria riservata al sistema operativo.<br>
Viene utilizzato un <strong>registro limite</strong> che contiene l’indirizzo da dove comincia la parte di memoria per l’utente e ogni tentativo di accesso oltre quel limite è negato.<br>
È comunque possibile interagire con il sistema operativo tramite le apposite chiamate di sistema.</p>
<h2 id="multiprogrammazione-a-partizioni-fisse">Multiprogrammazione a partizioni fisse</h2>
<p>Quando abbiamo un singolo processo in memoria (come nei sistemi batch) nel caso in cui il processo faccio delle richieste di I/O la CPU rimarrebbe libera in attesa che il processo completi la richiesta. Con la multiprogrammazione vogliamo evitare questo tempo morto di CPU, infatti avendo più processi in memoria ,quando un processo fa richieste di I/O ne mandiamo in esecuzione un altro mentre l’altro attende di soddisfare la richiesta.</p>
<p>nel seguente grafico vediamo il rapporto tra l’utilizzo della CPU in funzione del grado di quanti processi posso tenere in memoria contemporaneamente</p>
<p><img src="https://i.ibb.co/qJy0jMS/mutiprog.png" alt="enter image description here"></p>
<p>Notiamo come quando ho tanta attesa di I/O (ad esempio 80%) è conveniente avere in memoria tanti processi pronti per essere eseguiti per mantenere sempre impegnata la CPU.<br>
Quando invece ho programmi con poca attesa di I/O (ad esempio 20%) già avere due processi in memoria è sufficiente per saturare l’utilizzo della CPU.</p>
<p>è possibile calcolare l’utilizzo della CPU con la seguente formula</p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>U</mi><mrow><mi>C</mi><mi>P</mi><mi>U</mi></mrow></msub><mo>=</mo><mn>1</mn><mo>−</mo><msup><mi>p</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">U_{CPU} = 1-p^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.10903em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.13889em;">CP</span><span class="mord mathnormal mtight" style="margin-right: 0.10903em;">U</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.908832em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.714392em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>dove:<br>
<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">n =</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span></span></span></span></span> numero di processi in memoria<br>
<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">p =</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span></span></span></span></span> frazione di tempo di attesa I/O</p>
<h3 id="funzionamento-multiprogrammazione-a-partizioni-fisse">Funzionamento multiprogrammazione a partizioni fisse</h3>
<p>Ad ogni processo attivo viene assegnato un blocco di memoria di dimensione fissa. Abbiamo quindi bisogno di più registri per sapere dove inizia e finisce ogni blocco, <strong>registro base e registri limite</strong>. Questo per evitare conflitti tra sistema operativo e processi e anche tra i processi stessi.</p>
<p>La memoria viene divisa in questi blocchi (o partizioni) di dimensioni anche diverse e <strong>ogni processo sarà assegnato al più piccolo blocco che lo contiene</strong>. Ovviamente avendo più processi abbiamo bisogno di una coda di attesa per attendere che il blocco si liberi prima di far entrare un nuovo processo.</p>
<p><img src="https://i.ibb.co/zNXpVdd/partizioni-fisse.png" alt="enter image description here"></p>
<p>Il problema è che si possono verificare casi in cui un blocco piccolo (<em>partition 1</em>) abbiano una coda lunga e un blocco grande (<em>partition 3</em>) sia libero, Abbiamo quindi un grande spreco di memoria.</p>
<p>Una soluzione potrebbe essere quella di avere una singola coda, e appena un blocco si libera si assegna un processo a quel blocco, andando così ad utilizzare tutti i blocchi.</p>
<p><img src="https://i.ibb.co/dcxYMwd/single-queue.png" alt="enter image description here"></p>
<p>Gli svantaggi di questo sistema che l’anno portato ad non essere più utilizzato sono:</p>
<ol>
<li>non è detto che un processo occupi tutta la partizione, creando così degli spazi di memoria non utilizzabili (frammentazione interna)</li>
<li>la possibilità che non ci sia una partizione abbastanza grande per un processo</li>
</ol>

    </div>
  </div>
</body>

</html>
