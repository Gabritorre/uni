<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2023-10-27_Ereditarietà</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#ereditarietà">Ereditarietà</a>
<ul>
<li><a href="#esempio">Esempio</a></li>
<li><a href="#visibilità">Visibilità</a></li>
<li><a href="#super">super</a></li>
<li><a href="#abstract">Abstract</a></li>
<li><a href="#override-e-overload">Override e overload</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="ereditarietà">Ereditarietà</h1>
<p>L’ereditarietà è una tecnica che permette di creare delle gerarchie tra le classi, portando il vantaggio di avere un codice più organizzato e meno ripetuto.</p>
<p>Abbiamo quindi una classe figlio e una classe padre (o <strong>superclasse</strong>). La classe figlio <strong>eredita</strong> dal padre i <strong>metodi e i campi</strong>. La classe figlio può estendere (aggiungendo altri metodi) oppure specializzare (sovrascrivendo i metodi del padre) il comportamento del padre.</p>
<h2 id="esempio">Esempio</h2>
<p>Un padre può avere più classi figlie. Possiamo rappresentare la gerarchia graficamente come:</p>
<p><img src="https://i.ibb.co/7G8cLfX/ereditariet.png" alt="enter image description here"></p>
<p>le classe figlie idealmente diventano più grandi e complesse perché avranno man mano più codice, comprendendo il codice dei padri e il suo stesso codice aggiuntivo.</p>
<p>mentre un figlio può avere un <strong>singolo padre</strong></p>
<p>in codice possiamo esprimere questa ereditarietà tramite la <em>keyword</em> <code>extends</code></p>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Automobile</span> <span class="token keyword">extends</span> <span class="token class-name">Veicoli4ruote</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="visibilità">Visibilità</h2>
<p>I figli possono vedere campi e metodi del padre solo se:</p>
<ul>
<li>i metodi/campi del padre sono pubblici o protected</li>
<li>i metodi/campi del padre sono default e il figlio è nello stesso package</li>
</ul>
<p>Se un metodo/campo è protected la classe di un altro package può accedere quei membri solo se diventa una sottoclasse</p>
<p>nel caso i <strong>metodi/campi</strong> siano <strong>privati</strong> allora il <strong>figlio non può vederli</strong></p>
<h2 id="super">super</h2>
<p>la <em>keyword</em> <code>super</code> serve per riferirsi a metodi oppure campi della superclasse.</p>
<p>Abbiamo due utilizzi principali di <code>super</code></p>
<ol>
<li>
<p>chiamare il costruttore del padre all’interno del costruttore del figlio.</p>
<p>è molto probabile che quando si chiama il costruttore di una classe figlia si voglia inizializzare anche i campi derivati dal padre tramite il suo costruttore, è possibile fare ciò chiamando <code>super()</code> come prima istruzione del costruttore figlio</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Operazioni di inizializzazione della classe genitore</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Chiamata al costruttore della classe genitore</span>
        <span class="token comment">// Altre operazioni specifiche della classe figlia</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li>
<p>Accedere ai membri della classe padre</p>
<p>è possibile riferirsi ai metodi e ai campi della superclasse tramite <code>super.&lt;nome_metodo&gt;()</code> oppure <code>super.&lt;nome_campo&gt;</code></p>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Metodo della classe genitore"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Chiamata al metodo della classe genitore</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Metodo della classe figlia"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
</li>
</ol>
<h2 id="abstract">Abstract</h2>
<p><code>abstract</code> è una keyword che si applica ai metodi e alle classi.</p>
<h3 id="metodi-abstract">metodi abstract</h3>
<p>Quando un metodo è abstract si sta dicendo che quel metodo è presente nella classe ma non è implementato (c’è solo la firma), sarà compito di chi eredita la classe di implementarlo.<br>
Un metodo astratto può essere presente solo in una classe che è anch’essa astratta.</p>
<h3 id="classe-abstract">classe abstract</h3>
<p>Una classe astratta è una classe che ha solo parte dei suoi metodi implementati.<br>
Una classe astratta non può essere istanziata, può essere solo ereditata</p>
<p>Una classe che eredita una classe astratta deve implementare tutti i metodi <code>abstract</code> per essere istanziata, altrimenti deve essere astratta anche lei.</p>
<h2 id="override-e-overload">Override e overload</h2>
<p>prima di spiegare i concetti di overriding e overloading bisogna chiarire i concetti di <strong>firma e definizione</strong> di un metodo</p>
<p>con <strong>firma</strong> si intende tutto quello che è disponibile in fase di chiamata del metodo:</p>
<ul>
<li>nome del metodo</li>
<li>l’oggetto su cui è chiamato</li>
<li>la lista di parametri</li>
</ul>
<p>mentre con <strong>definizione</strong> si intende tutto quello che è disponibile quando si crea il metodo:</p>
<ul>
<li>comprende tutto quello che ha la firma</li>
<li>tipo di ritorno</li>
<li>la visibilità</li>
<li>altri modificatori (static, abstract, final…)</li>
</ul>
<h3 id="override-e-overload-1">override e overload</h3>
<p><strong>override e overload</strong> sono due modi diversi di ridefinire il comportamento di un metodo già esistente.</p>
<ul>
<li>nel caso di override la firma del metodo rimane la stessa, cambia solo il corpo del metodo</li>
<li>nel caso di overload cambia anche la firma (il nome del metodo deve rimanere lo stesso, può cambiare il ritorno e i parametri)</li>
</ul>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">class</span> <span class="token class-name">BaseClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">printMessage</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Messaggio: "</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">OverrideClass</span> <span class="token keyword">extends</span> <span class="token class-name">BaseClass</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">void</span> <span class="token function">printMessage</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Messaggio sovrascritto: "</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">OverloadClass</span> <span class="token keyword">extends</span> <span class="token class-name">BaseClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">printMessage</span><span class="token punctuation">(</span>String message<span class="token punctuation">,</span> String prefix<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>prefix <span class="token operator">+</span> <span class="token string">": "</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
<p>nota che <code>@Override</code> è una indicazione per il compilatore in cui si vuole esplicitare che si sta facendo override di un metodo. Nel caso per un typo si sbagliasse a scrivere il nome del metodo il compilatore si accorgerebbe che non stai facendo l’override di un metodo</p>
<h3 id="visibilità-in-caso-di-override">Visibilità in caso di override</h3>
<p>quando si vuole fare override di un metodo si può usare una visibilità <strong>uguale o meno restrittiva</strong> ad esempio:</p>
<ul>
<li>Se si vuole sovrascrivere un metodo pubblico siamo obbligati a tenerlo pubblico.</li>
<li>Se il vuole sovrascrivere un metodo con visibilità default possiamo tenerlo a default oppure cambiarlo a protected oppure public, ma <strong>non private</strong></li>
</ul>

    </div>
  </div>
</body>

</html>
