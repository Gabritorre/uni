# Deadlock

Nel tentativo di sincronizzare processi o thread ci si può imbattere in degli stalli o **deadlock** cioè delle situazioni in cui dei thread rimangono in attesa reciproca gli uni degli altri, non riuscendo mai a sbloccarsi perché colui che dovrebbe causare l'evento di sblocco è in attesa (si forma quindi una **attesa circolare**).

Più formalmente possiamo dire che:
Un insieme $S$ di processi o thread è in stallo se ogni $p$ in $S$ attende un evento che può essere causato solo da processi o thread appartenenti ad $S$.


## Condizioni per generare uno stallo

Uno stallo può avvenire sotto il verificarsi ti tutte le seguenti condizioni:

- **Mutua esclusione**
	In assenza di mutua esclusione: se una risorsa può essere utilizzata contemporaneamente da più processi o thread non è necessario attendere quindi non si forma una situazione di stallo. Ad esempio la lettura simultanea di dati condivisi.
- **Possesso e attesa**
	Se i processi o thread non allocano mai le risorse in modo incrementale, cioè acquisendo una risorsa (possesso) e poi chiedendone altre in seguito (attesa) allora non può succedere che si formi un attesa circolare (e quindi uno stallo).
- **Assenza di preemption**
	Se il sistema può far rilasciare in modo forzato le risorse a thread o processi, allora è possibile risolvere situazioni di stallo tramite preemption.
- **Attesa circolare**
	Per definizione, lo stallo avviene quando c’è una attesa circolare che fa sì che nessun processo o thread uscirà mai dallo stato di attesa.


## Gestire le situazioni di stallo

Lo stallo può essere gestito in vari modi a seconda di se e quando si evidenziano (potenziali) situazioni si attesa circolare.

-   **Prevenzione**: vengono messe in atto alcune strategie che prevengono la formazione di stalli
-   **Controllo**: l’assegnamento delle risorse è consentito solo nel caso in cui il sistema possa garantire che tale assegnamento non porterà a una situazione di stallo;
-   **Riconoscimento**: il sistema individua situazioni di stallo e cerca di ripristinare uno stato precedente senza stallo;
-   **Nessuna azione**: il sistema ignora lo stallo e lascia ai programmatori l’onere di evitarlo o gestirlo.


## Prevenzione

Analizziamo il caso di prevenzione dello stallo, per prevenire uno stallo dobbiamo negare almeno una delle condizioni necessaria di prima:

### Negare la mutua esclusione

Il fatto che l’accesso a una risorsa sia in mutua esclusione dipende dalla risorsa stessa e dal tipo di accesso, quando è necessaria non possiamo evitarla per prevenire lo stallo, ne risentirebbe la correttezza del programma.

### Evitare il possesso e attesa

Possiamo evitare possesso e attesa allocando tutte le risorse assieme (vedi la raccolta atomica nei filosofi a cena). Questo non è però sempre possibile perché non è detto che si conoscano tutte le risorse necessarie a un thread o processo a priori.
Inoltre allocare tutte le risorse all’inizio può essere **inefficiente** in quanto priva gli altri thread o processi di tali risorse.
Questa soluzione può anche provocare **starvation**.

### Preemption

La preemption, come la mutua esclusione, dipende dal tipo di risorsa. Ci sono risorse per loro natura preemptable e altre no. Tipicamente, se la risorsa può salvare completamente il proprio stato e ripristinarlo può essere preemptable come la CPU.
Non possiamo quindi imporre la preemption a priori.


### Prevenire l'attesa circolare

È possibile evitare l’attesa circolare con opportune strategie di allocazione delle risorse.
Ne è un esempio la soluzione dei filosofi a cena con un filosofo mancino
