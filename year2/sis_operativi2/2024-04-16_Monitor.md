# Monitor

I monitor sono un **costrutto linguistico** (o un meccanismo di sincronizzazione) atto a risolvere due dei principali problemi che si presentano utilizzando i semafori:

1. la sincronizzazione è gestita in modo decentralizzato dai singoli thread.
2. La gestione di multipli semafori per gestire situazioni non facilmente logiche da sincronizzare, con la possibilità di creare zone critiche all'interno di zone critiche che facilmente possono creare stalli.


I monitor possono essere ricondotti a degli oggetti (nel mondo della programmazione ad oggetti) che hanno dei dati (i campi) e delle procedure per accederci (i metodi).
Possiamo anche immaginarli come semafori solamente con la coda, senza il contatore.

I monitor permettono di centralizzare tutta la sincronizzazione in un unico punto (il monitor) e facilità la mutua esclusione:

1. le **procedure** del monitor vengono eseguite in **mutua esclusione**
2. I monitor forniscono delle variabili speciali chiamate *condition* sulle quali sono possibili delle operazioni speciali: 
	- **wait**: il thread si mette in attesa e va in coda, il mutex viene rilasciato per permettere agli altri thread di entrare in zona critica
	- **signal**: riattiva **immediatamente** il primo thread in attesa sulla coda, e il thread attuale va in attesa nella coda
	- **notify**: notifica il primo thread in attesa che può continuare, quando la CPU gli assegnerà il suo turno potrà proseguire. Intanto l'attuale thread continua la sua normale esecuzione

La sottile differenza tra **signal** e **notify** può essere importante in determinati casi: con **signal** siamo sicuri che il thread in attesa verrà subito eseguito, mentre con la **notify** non possiamo darlo per certo, infatti altri thread potrebbero rubargli il posto possibilmente intaccando la correttezza del programma senza i giusti controlli.


La **notify** è quindi meno restrittiva in quanto lascia lo il compito allo scheduler di sbloccare i thread, mentre la **signal** forza un cambio di thread allo scheduler.


## Produttore e consumatore con i monitor

Definiamo una pseudo-classe Monitor come segue

```c
Monitor mon {
	int buffer[MAX];
	
	int counter = 0;	//conta il numero di celle piene, da consumare
	int write_index = 0;
	int read_index = 0;

	condition piene;
	condition vuote;

	void produce (int d) {
		if (counter == MAX) {	// se non ci sono celle libere in cui scrivere
			vuote.wait();
		}
		buffer[write_index] = d;
		write_index = (write_index + 1) % MAX;
		counter++;
		piene.signal();
	}

	int consuma () {
		if (couter == 0) {		// se non ci sono celle da leggere
			piene.wait();
		}
		d = buffer[read_index];
		read_index = (read_index + 1) % MAX;
		counter--;
		vuote.signal();
		return d;
	}
}
```

Usiamo il monitor appena creato nel codice del Produttore e Consumatore:

```c
Produttore() {
  while(1) {
    /* produce un elemento d */
    mon.produce(d);
  }
}

Consumatore() {
  while(1) {
    d = mon.consuma();
    /* consuma d */
 }
}
```

### Signal vs notify

È importante l'uso della `signal()` e non della `notify()` in quanto:
immaginiamo un consumatore che lancia una `wait` perché non ci sono celle da consumare.
Arriva un produttore che incrementa il `counter` e lancia una `signal`, questo fa si che il consumatore che era nella `wait` riparta immediatamente (correttamente, infatti il counter adesso vale 1, che lui riporterà a 0).

Se usassimo la `notify()` potremmo avere il seguente comportamento:
immaginiamo un consumatore che lancia una `wait` perché non ci sono celle da consumare.
Arriva un produttore che incrementa il `counter` e lancia una `notify`, questo comunica allo scheduler che può avviare il consumatore quando possibile. Se però un altro consumatore entra in esecuzione trova il counter a 1 e quindi esegue tranquillamente portando il counter di nuovo a 0. Ma poi lo scheduler fa ripartire il consumatore che era bloccato, ma adesso non c'è più un dato da leggere! (il counter è a 0 e lui lo porterà erroneamente a -1)


### Versione corretta con notify

Una corretta implementazione con la `notify` richiede le seguenti modifiche

```c
Monitor mon {
	int buffer[MAX];
	
	int counter = 0;
	int write_index = 0;
	int read_index = 0;

	condition piene;
	condition vuote;

	void produce (int d) {
		while (counter == MAX) {		//MODIFICA
			vuote.wait();
		}
		buffer[write_index] = d;
		write_index = (write_index + 1) % MAX;
		counter++;
		piene.notify();					//MODIFICA
	}

	int consuma () {
		while (couter == 0) {			// MODIFICA
			piene.wait();
		}
		d = buffer[read_index];
		read_index = (read_index + 1) % MAX;
		counter--;
		vuote.notify();					//MODIFICA
		return d;
	}
}
```

Fare il controllo in un ciclo `while` permette di accertarsi che il counter sia effettivamente come richiesto prima di riprendere l'esecuzione.
Nota che non si tratta di *busy waiting* in quanto la `wait` sospende il thread.


## Filosofi a cena con i monitor

Vediamo come implementare i filosofi a cena con la soluzione della **raccolta atomica di entrambe le bacchette**, questa soluzione non era facile con i semafori in quanto dovremmo rilasciare il mutex nel caso una delle bacchette non fosse disponibile.
Con i monitor risolviamo questo problema:

```c
Monitor tavola {
  boolean bacchetta[5] = {true, true, true, true, true}; // presenza bacchette
  condition filosofo[5]; // code di attesa per i filosofi

  void raccogli(int i) {
    while(!bacchetta[i] || !bacchetta[(i+1)%5]) {
      filosofo[i].wait(); // attende se una delle bacchette non è disponibile
	}
    // raccoglie le bacchette in modo atomico
    bacchetta[i] = false;
    bacchetta[(i+1)%5] = false;
  }

  void deposita(int i) {
    // deposita le bacchette
    bacchetta[i] = true;
    bacchetta[(i+1)%5] = true;

    // notifica il filosofo a sx e quello a dx
    filosofo[(i+4)%5].notify();
    filosofo[(i+1)%5].notify();
  }
}
```

Utilizzo del monitor

```c
Filosofo(i) {
  while(1) {
    < pensa >

    tavola.raccogli(i);

    < mangia >
    
    tavola.deposita(i);
  }
}
```

In questo caso l'uso di `signal` o `notify` non cambia in quanto il ciclo `while` è sempre necessario metterlo.
