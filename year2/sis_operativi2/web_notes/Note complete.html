<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Note complete</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#comunicazione-tra-processi-e-thread">Comunicazione tra processi e thread</a>
<ul>
<li><a href="#competizione">Competizione</a></li>
<li><a href="#cooperazione">Cooperazione</a></li>
<li><a href="#modelli-di-comunicazione">Modelli di comunicazione</a></li>
<li><a href="#scambio-dei-messaggi">Scambio dei messaggi</a></li>
<li><a href="#comunicazione-sincrona-e-asincrona">Comunicazione sincrona e asincrona</a></li>
<li><a href="#produttore-consumatore">Produttore-consumatore</a></li>
</ul>
</li>
<li><a href="#creazione-di-processi">Creazione di processi</a>
<ul>
<li><a href="#processi-in-unix">Processi in Unix</a></li>
<li><a href="#la-system-call-fork">La system call “fork”</a></li>
<li><a href="#processi-orfani-e-zombie">Processi orfani e zombie</a></li>
</ul>
</li>
<li><a href="#esecuzione-e-terminazione">Esecuzione e terminazione</a>
<ul>
<li><a href="#exec">exec</a></li>
<li><a href="#terminazione-dei-processi">Terminazione dei processi</a></li>
<li><a href="#gestire-lo-stato-di-ritorno">Gestire lo stato di ritorno</a></li>
<li><a href="#esempio-con-exit-e-wait">Esempio con exit e wait</a></li>
</ul>
</li>
<li><a href="#segnali">Segnali</a>
<ul>
<li><a href="#esempio-di-utilizzo-di-un-segnale">Esempio di utilizzo di un segnale</a></li>
<li><a href="#syscall-signal">Syscall “signal”</a></li>
<li><a href="#syscall-kill">Syscall “kill”</a></li>
<li><a href="#mascherare-i-segnali">Mascherare i segnali</a></li>
</ul>
</li>
<li><a href="#pipe">Pipe</a>
<ul>
<li><a href="#pipe-senza-nome">Pipe senza nome</a></li>
<li><a href="#pipe-con-nome">Pipe con nome</a></li>
<li><a href="#esempio-lettore-e-scrittore">Esempio lettore e scrittore</a></li>
</ul>
</li>
<li><a href="#thread">Thread</a>
<ul>
<li><a href="#memoria-condivisa">Memoria condivisa</a></li>
<li><a href="#produttore-e-consumatore">Produttore e consumatore</a></li>
<li><a href="#implementazione-con-i-processi">Implementazione con i processi</a></li>
<li><a href="#implementazione-con-i-thread">Implementazione con i thread</a></li>
<li><a href="#interferenza">Interferenza</a></li>
</ul>
</li>
<li><a href="#sezione-critica">Sezione critica</a>
<ul>
<li><a href="#soluzioni-software">Soluzioni software</a></li>
<li><a href="#tentativo-1-lock">Tentativo 1: Lock</a></li>
<li><a href="#tentativo-2-turno">Tentativo 2: Turno</a></li>
<li><a href="#tentativo-3-pronto">Tentativo 3: Pronto</a></li>
<li><a href="#algoritmo-di-peterson">Algoritmo di Peterson</a></li>
<li><a href="#conclusione-soluzione-software">Conclusione soluzione software</a></li>
<li><a href="#soluzioni-hardware">Soluzioni hardware</a></li>
<li><a href="#xchg">XCHG</a></li>
</ul>
</li>
<li><a href="#thread-in-posix">Thread in POSIX</a>
<ul>
<li><a href="#esempio-1">Esempio 1</a></li>
<li><a href="#esempio-2">Esempio 2</a></li>
</ul>
</li>
<li><a href="#semafori">Semafori</a>
<ul>
<li><a href="#semafori-1">Semafori</a></li>
<li><a href="#produttore-e-consumatore-1">Produttore e consumatore</a></li>
<li><a href="#tanti-produttori-e-consumatori">Tanti produttori e consumatori</a></li>
<li><a href="#semafori-in-posix">Semafori in POSIX</a></li>
<li><a href="#implementazione-completa-produttore-e-consumatore">Implementazione completa produttore e consumatore</a></li>
</ul>
</li>
<li><a href="#programmazione-con-i-semafori">Programmazione con i semafori</a>
<ul>
<li><a href="#sincronizzazione-molti-a-uno">Sincronizzazione molti a uno</a></li>
<li><a href="#lettori-e-scrittori">Lettori e scrittori</a></li>
<li><a href="#filosofi-a-cena">Filosofi a cena</a></li>
</ul>
</li>
<li><a href="#monitor">Monitor</a>
<ul>
<li><a href="#produttore-e-consumatore-con-i-monitor">Produttore e consumatore con i monitor</a></li>
<li><a href="#filosofi-a-cena-con-i-monitor">Filosofi a cena con i monitor</a></li>
<li><a href="#lettori-e-scrittori-notifyall">Lettori e scrittori, notifyAll</a></li>
</ul>
</li>
<li><a href="#thread-in-java">Thread in Java</a>
<ul>
<li><a href="#estendendo-la-classe-thread">Estendendo la classe Thread</a></li>
<li><a href="#creazione-interruzione-e-attesa">Creazione, Interruzione e attesa</a></li>
<li><a href="#monitor-1">Monitor</a></li>
<li><a href="#esempio">Esempio</a></li>
</ul>
</li>
<li><a href="#deadlock">Deadlock</a>
<ul>
<li><a href="#condizioni-per-generare-uno-stallo">Condizioni per generare uno stallo</a></li>
<li><a href="#gestire-le-situazioni-di-stallo">Gestire le situazioni di stallo</a></li>
<li><a href="#prevenzione">Prevenzione</a></li>
<li><a href="#controllo">Controllo</a></li>
<li><a href="#grafo-di-assegnazione">Grafo di assegnazione</a></li>
<li><a href="#algoritmo-con-grafo-di-assegnazione">Algoritmo con grafo di assegnazione</a></li>
<li><a href="#algoritmo-del-banchiere">Algoritmo del banchiere</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="comunicazione-tra-processi-e-thread">Comunicazione tra processi e thread</h1>
<p>Nel sistema operativo girano molti processi e tra di loro ci possono essere casi di <strong>competizione e cooperazione</strong></p>
<h2 id="competizione">Competizione</h2>
<p><strong>La competizione</strong> si ha quando più processi vogliono la stessa risorsa (sia hardware che software).<br>
Queste competizioni posso creare delle interferenze con il normale funzionamento del sistema come cali di prestazioni e nei casi più estremi il crash del sistema.</p>
<p>Il sistema operativo deve gestire le competizioni al fine di rendere il sistema più fluido possibile all’utente e allo stesso tempo deve illudere i processi di avere tutto il sistema disponibile per loro.</p>
<h2 id="cooperazione">Cooperazione</h2>
<p>In altri casi abbiamo la cooperazione tra processi, cioè processi che contribuiscono e comunicano tra loro per raggiungere un obiettivo in comunque.</p>
<p>In questo caso abbiamo dei vantaggi quali:</p>
<ul>
<li><strong>condivisione</strong>: i processo comunicano, si sincronizzano e si scambiano informazioni</li>
<li><strong>parallelismo</strong>: sfruttare un sistema multi-core per eseguire in parallelo un programma</li>
<li><strong>modularità</strong>: suddividere un compito complesso in attività più semplici che verranno eseguite da processi diversi</li>
<li><strong>multitasking</strong>: può risultare comodo eseguire un’attività mentre un’altra continua in background.</li>
<li><strong>replicazione</strong>: quando è necessaria l’esecuzione simultanea su istanze diverse, è possibile replicare l’istanza su più processi</li>
</ul>
<h2 id="modelli-di-comunicazione">Modelli di comunicazione</h2>
<p>Vediamo i due modelli principali per la comunicazione tra processi:</p>
<ul>
<li><strong>message passing</strong> i processi comunicano scambiandosi direttamente dei messaggi (tecnica utilizzata dai processi)</li>
<li><strong>shared memory</strong> i processi possiedono una memoria condivisa a cui accedono in lettura e scrittura (tecnica utilizzata dai thread).</li>
</ul>
<p>Inizialmente ci occuperemo della comunicazione con scambio di messaggi.</p>
<h2 id="scambio-dei-messaggi">Scambio dei messaggi</h2>
<p>I processi dispongono di due operazioni principali:</p>
<ul>
<li><code>send(messaggio)</code></li>
<li><code>receive(&amp;messaggio)</code></li>
</ul>
<p>esse vengono realizzate tramite delle <em>system call</em> al sistema operativo dette <strong>IPC</strong> (InterProcess Communication)</p>
<p>Il mittente e il destinatario del messaggio possono essere indicati direttamente o indirettamente:</p>
<h3 id="nominazione-diretta">Nominazione diretta</h3>
<p>Il mittente e il destinatario sono indicati esplicitamente:</p>
<ul>
<li><code>send(destinatario, messaggio)</code></li>
<li><code>receive(mittente, &amp;message)</code></li>
</ul>
<p>il <strong>vantaggio</strong> di questa comunicazione è la <em>semplicità</em></p>
<p>Lo <strong>svantaggio</strong> sta nel fatto che è necessario un accordo tra i processi per potersi identificare, e questo accordo non è facile da implementare.</p>
<h3 id="nominazione-indiretta">Nominazione indiretta</h3>
<p>In questa tecnica vengono utilizzate delle <strong>porte</strong>, cioè delle memorie temporanee che contengono i messaggi. I processi che puntano alla stessa porta la possono utilizzare per comunicare tra loro.</p>
<ul>
<li><code>send(porta, messaggio)</code></li>
<li><code>receive(porta, &amp;message)</code></li>
</ul>
<p>In Unix le <strong>pipe</strong> utilizzano questa implementazione</p>
<h2 id="comunicazione-sincrona-e-asincrona">Comunicazione sincrona e asincrona</h2>
<p>Le operazioni di invio e ricezione possono essere di tipo sincrono o asincrono:</p>
<ul>
<li><strong>send sincrona</strong>: la <em>send</em> attende fino a quando non avviene una <em>receive</em> dal destinatario</li>
<li><strong>send asincrona</strong>: la <em>send</em> non attende che avvenga una <em>receive</em></li>
<li><strong>receive sincrona</strong>: la <em>receive</em> attende attivamente l’arrivo di messaggi</li>
<li><strong>receive asicrona</strong>: la <em>receive</em> controlla ad intervalli regolari la presenza di nuovi messaggi (ritornando NULL se non ce ne sono di nuovi)</li>
</ul>
<h2 id="produttore-consumatore">Produttore-consumatore</h2>
<p>La tecnica di scambio di messaggi è utile nella situazione in cui un programma “produce” un dato e un altro programma “consuma” il dato.</p>
<p>Vediamo degli esempi con la shell di linux:</p>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token function">ls</span> -la <span class="token operator">|</span> <span class="token function">grep</span> <span class="token operator">&lt;</span>stringa<span class="token operator">&gt;</span>
</code></pre>
<p>Il precedente comando utilizza due programmi (<code>ls</code> e <code>grep</code>) e utilizza una <em>pipe</em> per far comunicare i due processi. In questo particolare esempio abbiamo una <strong>comunicazione con nominazione indiretta con send asincrona e receive sincrona</strong>.</p>
<p>La <em>pipe</em> viene creata dal processo padre prima di avviare i due processi, in modo che possa essere referenziata da entrambi i processi durante la loro creazione.<br>
Il processo che esegue <code>ls -la</code> genera un output che mette nel buffer della <em>pipe</em>, successivamente il processo che esegue <code>grep &lt;stringa&gt;</code> legge il dato e genera un nuovo output.</p>
<p>Per mostrare visivamente che la send è asincrona modifichiamo il comando nel seguente modo:</p>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token punctuation">(</span>ls -al<span class="token punctuation">;</span> <span class="token keyword">echo</span> <span class="token string">"DONE ls"</span>  1<span class="token operator">&gt;</span><span class="token operator">&amp;</span>2<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>sleep 10<span class="token punctuation">;</span> <span class="token function">grep</span> <span class="token operator">&lt;</span>stringa<span class="token operator">&gt;</span><span class="token punctuation">)</span>
</code></pre>
<p>Descrizione: subito dopo l’esecuzione di <code>ls</code> viene fatta una stampa “DONE ls” che viene deviata sullo <em>standard error</em> con la sintassi <code>1&gt;&amp;2</code> perché vogliamo stamparla e non darla in pasto a <code>grep</code>.<br>
Contemporaneamente nel blocco destro di istruzioni avviene uno sleep di 10 secondi e poi viene fatta la <code>grep</code>.<br>
Il comportamento che otteniamo eseguendo il comando è quello della stampa immediata di “DONE ls”, una attesa di 10 secondi e poi l’output della grep.<br>
Questo significa che il comando <code>ls</code> non ha atteso che la <code>grep</code> ricevesse il messaggio (questo lo intuiamo perché viene eseguita la stampa di <code>DONE ls</code> immediatamente), concludiamo quindi che il comando <code>ls</code> fa una send asincrona.</p>
<p>La pipe, di default, rende la <strong>ricezione sincrona</strong>: il processo ricevente attende attivamente la presenza di messaggi in arrivo.</p>
<p>ad esempio, la seguente riga:</p>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token punctuation">(</span>sleep 2<span class="token punctuation">;</span><span class="token function">ls</span> -al<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>echo <span class="token string">"START"</span><span class="token punctuation">;</span> <span class="token function">grep</span> parola<span class="token punctuation">;</span> <span class="token keyword">echo</span> <span class="token string">"DONE"</span><span class="token punctuation">)</span>
</code></pre>
<p>dobbiamo immaginare che i due blocchi di istruzioni vengono eseguiti contemporaneamente, e quando il blocco di destra necessità di un input si interrompe la sua esecuzione e rimane in attesa.</p>
<p>Infatti quello che accade è:<br>
la stampa immediata di “START” <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">→</span></span></span></span></span> la <code>grep</code> rimane in attesa di un input <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">→</span></span></span></span></span> attesa di 2 secondi <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">→</span></span></span></span></span> esecuzione della <code>ls</code> che scrive nel buffer il dato <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">→</span></span></span></span></span> la <code>grep</code> viene eseguita <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">→</span></span></span></span></span> l’esecuzione può proseguire e viene stampato “DONE”</p>
<h1 id="creazione-di-processi">Creazione di processi</h1>
<p>Quando si crea un nuovo processo il sistema operativo di occupa di:</p>
<ul>
<li>Creare un nuovo PID</li>
<li>Allocare la memoria richiesta dal processo</li>
<li>Allocare altre risorse (come dispositivi di IO)</li>
<li>Decidere le varie informazioni del processo che saranno contenute nel PCB</li>
<li>Creare il PCB (<em>Process Control Block</em>)</li>
</ul>
<h2 id="processi-in-unix">Processi in Unix</h2>
<p>Vediamo la fase di creazione di un processo in un sistema Unix:</p>
<p>Un processo viene sempre creato da un altro processo, tramite una chiamata a sistema.</p>
<p>Il processo creante viene detto <strong>parent</strong> (genitore oppure padre), mentre il processo creato viene detto <strong>child</strong> (figlio).<br>
Le varie creazioni di processi creano una <strong>struttura ad albero</strong> che rappresenta le relazioni di parentela tra i processi.</p>
<h3 id="relazioni-dinamiche">Relazioni dinamiche</h3>
<ul>
<li>
<p>La relazione di default tra padre e figlio è quella in cui il <strong>padre attende l’esecuzione del figlio</strong>, ad esempio eseguendo il seguente comando da shell</p>
<pre><code>  $ sleep 5
</code></pre>
<p>il processo padre è il processo <code>bash</code> che gestire i vari comandi che gli diamo. Quando lanciamo <code>sleep 5</code> viene creato un processo figlio che esegue il programma <code>sleep</code> (che semplicemente aspetta per una data quantità di secondi).<br>
Durante l’attesa noi non possiamo lanciare altri comandi, questo perché il processo padre (bash) sta attendendo la terminazione del figlio</p>
</li>
<li>
<p>Un altro tipo di relazione è quella dell’esecuzione in <em>background</em>, quindi dopo la creazione del processo, <strong>padre e figlio continuano la loro normale esecuzione parallelamente</strong>, ad esempio eseguendo il seguente comando da shell</p>
<pre><code>  $ sleep 5 &amp;
</code></pre>
<p>Come prima il processo padre (<code>bash</code>) crea il processo <code>sleep</code> me lo esegue in <em>background</em> quindi anche durante l’esecuzione della <code>sleep</code> possiamo comunque interagire con il terminale.<br>
Mentre la <code>sleep</code> è in esecuzione possiamo lanciare il comando <code>ps</code> che ci mostra i processi attualmente attivi nella specifica istanza di quel terminale. Si dovrebbe ottenere un output di questo tipo</p>
<pre class=" language-bash"><code class="prism  language-bash">PID TTY          TIME CMD
14695 pts/1    00:00:00 <span class="token function">bash</span>
17589 pts/1    00:00:00 <span class="token function">sleep</span>
17590 pts/1    00:00:00 <span class="token function">ps</span>
</code></pre>
<p>Una volta che il processo <code>sleep</code> termina, viene notificata la terminazione al padre tramite un messaggio di questo tipo:</p>
<pre><code>  [1]+  Done                    sleep 5
</code></pre>
<p>Possiamo vedere meglio la relazione di parentela tra questi processi modificando il comando <code>ps</code> con il seguenti parametri</p>
<ul>
<li><code>pid</code>: id del processo</li>
<li><code>ppid</code>: id del processo padre</li>
<li><code>comm</code>: nome del comando</li>
</ul>
<p>Ad esempio:</p>
<pre><code>  ps -o pid,ppid,comm
</code></pre>
<p>Ci restituirà un output di questo tipo (nota come sia <code>ps</code>  che <code>sleep</code> sono figli di <code>bash</code>)</p>
<pre><code>PID  PPID COMMAND
 11    10 bash
 23    11 sleep
 24    11 ps
</code></pre>
</li>
</ul>
<h3 id="relazioni-di-contenuto">Relazioni di contenuto</h3>
<p>Due possibilità:</p>
<ul>
<li>Il figlio è un duplicato del genitore (ad esempio in UNIX)</li>
<li>Il figlio esegue un programma differente (ad esempio nei sistemi Windows)</li>
</ul>
<p>Questo è il comportamento standard ma ovviamente è possibile anche l’altra modalità in entrambi i sistemi.</p>
<h2 id="la-system-call-fork">La system call “fork”</h2>
<p><code>fork</code> è una chiamata a sistema nel sistema Unix che appartiene allo standard POSIX e che si occupa di creare un nuovo processo.</p>
<p>Dopo una chiamata a <code>fork</code> il processo figlio:</p>
<ul>
<li><strong>condivide l’area del codice</strong> del processo padre</li>
<li>utilizza una <strong>copia dell’area dei dati del padre</strong></li>
</ul>
<p><img src="https://i.ibb.co/cCP57w2/image.png" alt="enter image description here"></p>
<p>Dato che padre e figlio lavorano sullo stesso codice, si può riconoscere padre e figlio in base al valore di ritorno della funzione <code>fork</code>:</p>
<ul>
<li>se ritorna 0 allora si tratta del processo figlio</li>
<li>se ritorna un valore maggiore di 0 allora si tratta del processo padre</li>
</ul>
<p>Ad esempio (fatto in C)</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span> pid <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
	  <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// stampa la descrizione dell'errore</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	  <span class="token comment">// codice figlio</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">//(pid &gt; 0)</span>
	  <span class="token comment">// codice genitore</span>
	<span class="token punctuation">}</span>  
	<span class="token comment">// codice del genitore e del figlio: da usare con cautela!</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Nota 1: il tipo di dato <code>pid_t</code> è un intero la cui dimensione varia in base al sistema.<br>
Nota 2: usando la combinazione <code>Ctrl + c</code> durante l’esecuzione del programma si invia un segnale di terminazione al processo.<br>
Nota 3: se siamo sul padre il valore di ritorno della fork ci da il pid del figlio</p>
<p>Nel codice possiamo utilizzare le funzioni:</p>
<ul>
<li><code>getpid()</code> per ottenere il pid del processo stesso</li>
<li><code>getppid()</code> per ottenere il pid del processo padre</li>
</ul>
<p>Come si vedeva nel codice, quando il valore di ritorno della <code>fork</code> è negativo significa che la creazione del processo è fallita, questo solitamente accade quando non c’è sufficiente memoria per allocare il processo.</p>
<p>Un esempio per rappresentare la struttura ad albero è il seguente codice:</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  pid_t f1<span class="token punctuation">,</span>f2<span class="token punctuation">,</span>f3<span class="token punctuation">;</span>
  
  f1<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  f2<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  f3<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%i%i%i "</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>f1 <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>f2 <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>f3 <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre>
<p>Vengono eseguite 3 fork da ogni processo che creiamo (non facciamo il controllo sul valore di ritorno per separare codice figlio dal codice padre).</p>
<ul>
<li>il primo fork verrà eseguito dal primo processo, dopo la sua esecuzione si avranno 2 processi</li>
<li>il secondo fork verrà eseguito dai 2 processi, dopo la sua esecuzione si avranno 4 processi</li>
<li>il terzo fork verrà eseguito dai 4 processi, dopo la sua esecuzione si avranno 8 processi</li>
</ul>
<p>Ci aspettiamo quindi 8 stampe a schermo, che rappresentano tutte le permutazioni di 3 bit, dove <code>111</code> sarà il processo di partenza.</p>
<p>L’output sarà di questo tipo</p>
<p><code>000 001 100 101 010 011 110 111</code></p>
<p>l’ordine di apparizione dipende dallo scheduling, e quando termina il processo <code>111</code> (cioè il primo processo) la shell è pronta per accettare altri comandi (anche se i figli devono ancora finire)</p>
<p><img src="https://i.ibb.co/CzKHc43/image.png" alt="enter image description here"></p>
<h2 id="processi-orfani-e-zombie">Processi orfani e zombie</h2>
<p>In base alla versione del sistema Unix possiamo avere diversi processi che gestiscono l’avvio e l’esecuzione dell’intero sistema. Nelle prime versioni di Unix si usava <strong>SysVinit</strong>, poi si è passati a <strong>Upstart</strong>, ora nei sistemi più recenti viene usato <strong>Systemd</strong>.</p>
<p>I sistemi che utilizzano SysVinit e Upstart si riferiscono al processo che inizializza il sistema come <strong>init</strong> mentre i sistemi che utilizzano Systemd si riferiscono a tale processo come <strong>systemd</strong>.</p>
<p>Quando il processo padre termina prima del figlio, allora il figlio viene definito <strong>orfano</strong>. I processi orfani vengono adottati da <em>init</em> oppure da <em>systemd</em> (in base al sistema).<br>
Un processo orfano non viene più terminato dalla combinazione <code>Ctrl + c</code></p>
<p>I processi <strong>Zombie</strong> sono processi terminati ma in attesa che il genitore rilevi la loro terminazione e quindi che il padre riceveva il suo valore di uscita.<br>
I processi zombie possiedono ancora un PID e il PCB mentre sono in questo stato.</p>
<h1 id="esecuzione-e-terminazione">Esecuzione e terminazione</h1>
<p>È una situazione comune che quando creiamo un nuovo processo con la <code>fork</code> vogliamo far eseguire un programma diverso da quello in cui avviene la creazione, la system call <strong>exec</strong> serve proprio a questo.</p>
<p>Schematicamente possiamo rappresentare l’esecuzione di una <code>exec</code> dopo una <code>fork</code> in questo modo:</p>
<p><img src="https://i.ibb.co/7pmLNZ6/image.png" alt="enter image description here"></p>
<p>Spesso la <code>exec</code> viene chiamata subito dopo la <code>fork</code>, e siccome la <code>exec</code> butta via la copia dei dati appena fatta, risulta inutile e inefficiente fare la copia.<br>
Per ovviare a questo problema viene utilizzata la tecnica <strong>copy-on-write</strong>:</p>
<ul>
<li>viene fatta la copia solo della page table (e non dei dati/pagine effettive)</li>
<li>le pagine vengono messe in modalità <em>read only</em></li>
<li>Se avviene un tentativo di scrittura da parte di uno dei due processi, viene generato un errore particolare che il kernel gestirà nel seguente modo:
<ul>
<li>viene fatta la copia effettiva dei dati e il processo che ha fatto la modifica adesso punterà alla copia dei dati</li>
<li>vengono ripristinati i permessi a <em>read-write</em> su entrambe le copie</li>
</ul>
</li>
</ul>
<p>In questo modo se viene fatta una <em>exec</em> subito dopo la <em>fork</em> non avviene nessuna copia dei dati.</p>
<h2 id="exec">exec</h2>
<p>Il comando <code>exec</code> presenta diverse varianti:</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span> arg0<span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">execlp</span><span class="token punctuation">(</span><span class="token string">"ls"</span><span class="token punctuation">,</span> arg0<span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">execv</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">execvp</span><span class="token punctuation">(</span><span class="token string">"ls"</span><span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<ul>
<li>La presenza della <code>p</code> a fine comando rappresenta che viene utilizzata la <code>$PATH</code> di sistema per cercare il comando</li>
<li>La presenza della <code>v</code> a fine comando rappresenta che il passaggio degli argomenti viene fatto tramite un array di stringhe (che in C si traduce come un puntatore a <em>char*</em>)</li>
<li>La presenza della <code>l</code> (si contrappone a <code>v</code>) a fine comando rappresenta che il passaggio degli argomenti viene fatto elencando i parametri, con NULL come ultimo parametro (per convenzione il primo argomento è il nome stesso del programma da eseguire)</li>
</ul>
<h3 id="errori-con-exec">Errori con exec</h3>
<p>L’<code>exec</code> restituisce un valore di ritorno solo in caso di errore (con un <code>-1</code>), cioè quando non viene trovato il comando da eseguire.<br>
Se la <code>exec</code> va a buon fine allora perde ogni riferimento al vecchio codice ed eseguirà solamente il nuovo programma</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Esecuzione di ls\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span><span class="token string">"ls"</span><span class="token punctuation">,</span><span class="token string">"-l"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//il seguente codice viene eseguito solo se la exec fallisce</span>
	<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"Si è verificato un errore nell'esecuzione del codice\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>L’utilizzo di <code>perror</code> per stampare l’errore è particolarmente utile perché oltre alla stringa che gli passiamo, esso stampa anche una variabile globale che rappresenta l’errore effettivo.</p>
<p>Nel caso in cui passiamo un parametro errato ad un comando esistente, ciò <strong>non ci verrà notificato con il valore di ritorno</strong>, questo perché l’errore viene generato dal nuovo comando, e se il comando è stato eseguito allora il processo ha già perso il riferimento al vecchio programma.</p>
<h2 id="terminazione-dei-processi">Terminazione dei processi</h2>
<p>Vediamo il seguente codice che simula il comportamento di una shell:</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pid_t esito<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    <span class="token keyword">char</span> comando<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>pch<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"myshell# "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// il codice che segue separa gli argomenti e salva i puntatori in argv[]</span>
        <span class="token comment">// non serve comprendere le seguenti 7 righe codice</span>
        <span class="token function">fgets</span><span class="token punctuation">(</span>comando<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// legge l'input dell'utente</span>
        pch <span class="token operator">=</span> <span class="token function">strtok</span> <span class="token punctuation">(</span>comando<span class="token punctuation">,</span><span class="token string">" \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "parsa" il primo argomento</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> pch <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> <span class="token number">127</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pch<span class="token punctuation">;</span>
            pch <span class="token operator">=</span> <span class="token function">strtok</span> <span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">" \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "parsa" gli argomenti successivi</span>
        <span class="token punctuation">}</span>
        argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// termina l'array argv con NULL</span>
        
        
        <span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// comando vuoto, ignora</span>
            esito <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// crea un processo figlio</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>esito <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fallimento fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>esito <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">//processo figlio</span>
                <span class="token function">execvp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// esegue il comando</span>
                <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"Errore esecuzione"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>   <span class="token comment">// il processo genitore (shell) torna a leggere un altro comando</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Se eseguiamo il codice, notiamo una anomalia, quando lanciamo un comando il prompt del comando successivo appare prima dell’output del comando lanciato:</p>
<p><img src="https://i.ibb.co/ZB5B01c/image.png" alt="enter image description here"></p>
<p>Questo accade perché il <strong>processo padre</strong> (quello che rimane in attesa dei comandi) <strong>non attende la terminazione dei figli</strong> (i comandi stessi), ed avendo meno codice da eseguire è più veloce dei figli.</p>
<p>Un ulteriore problema è il fatto che una volta che i processi figli terminano, questi diventano<br>
<em>zombie</em> (lo notiamo dalla dicitura “defunct” eseguendo il comando <code>ps</code>)</p>
<p><img src="https://i.ibb.co/9yGXgdF/image.png" alt="enter image description here"></p>
<p>Capiamo la motivazione di questo problema:<br>
Quando un processo termina, esso segnala al genitore la propria terminazione con alcune informazioni che gli possono essere utili. Finché il padre non processa queste informazioni, esse rimangono in memoria in attesa che il padre le processi.</p>
<p>Alcune di queste informazioni che rimangono in memoria sono:</p>
<ul>
<li>PID</li>
<li>lo stato di terminazione</li>
<li>il tempo di CPU utilizzato dal processo</li>
</ul>
<p>Possiamo risolvere questi problemi utilizzando due chiamate a sistema:</p>
<ul>
<li><code>exit(int status)</code> usata per terminare il processo, <strong>restituendo il proprio stato di terminazione</strong> al padre.<br>
Normalmente si ritorna <code>1</code> oppure la costante <code>EXIT_FAILURE</code> per ritornare una terminazione fallimentare, altrimenti si ritorna <code>0</code> oppure la costante <code>EXIT_SUCCESS</code> per ritornare una terminazione con successo</li>
<li><code>pid = wait(int &amp;status)</code> usata per <strong>attendere la terminazione del figlio</strong>. La funzione ritorna il pid del figlio, e nella  variabile <code>status</code> viene salvato lo stato di terminazione del figlio.<br>
Se non ci sono figli ritorna <code>-1</code>.<br>
È possibile attendere un processo in particolare specificando il suo pid: <code>pid = waitpid(pid_value, &amp;stato)</code></li>
</ul>
<h2 id="gestire-lo-stato-di-ritorno">Gestire lo stato di ritorno</h2>
<p>Per gestire lo stato di ritorno di un processo figlio, vengono utilizzate delle macro.<br>
Le due principali macro sono <code>WIFEXITED</code> e <code>WIFSIGNALED</code>:</p>
<ul>
<li><code>WIFEXITED(status) == true</code> se il figlio è uscito con una <code>exit</code>, in tal caso un’altra macro <code>WEXITSTATUS(status)</code> ritorna il valore della variabile <code>status</code> messa all’interno della <code>exit</code>.</li>
<li><code>WIFSIGNALED(status) == true</code> se il figlio è stato terminato in modo anomalo, in tal caso un’altra macro <code>WTERMSIG(status)</code> ritorna un valore corrispondente al “segnale” che ha causato l’arresto anomalo</li>
</ul>
<p>Per sistemare il codice della simulazione della shell basta aggiungere il seguente codice appena prima della fine del ciclo while:</p>
<pre class=" language-c"><code class="prism  language-c">pid<span class="token operator">=</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// attende il processo figlio</span>

<span class="token comment">// esamina lo stato di uscita</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Exit status = %d\n"</span><span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFSIGNALED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ANOMALO: status = %d\n"</span><span class="token punctuation">,</span> <span class="token function">WTERMSIG</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="esempio-con-exit-e-wait">Esempio con exit e wait</h2>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> pid<span class="token punctuation">,</span> status<span class="token punctuation">;</span>
    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> pid <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"errore fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token comment">/* figlio 1: esce normalmente inviando al genitore lo stato "42" */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sono il figlio1! pid=%d ppid=%d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> pid <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"errore fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token comment">/* figlio 2: segfault, cerca di accedere alla locazione 0 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> <span class="token operator">*</span>tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> a<span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sono il figlio2! pid=%d ppid=%d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        a <span class="token operator">=</span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>	<span class="token comment">// segfault</span>
    <span class="token punctuation">}</span> 

    <span class="token comment">/* il genitore continua e attende tutti i figli ... */</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ricevuta terminazione di pid=%d\n"</span><span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"OK: status = %d\n"</span><span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFSIGNALED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ANOMALO: status = %d\n"</span><span class="token punctuation">,</span> <span class="token function">WTERMSIG</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>l’output è simile al seguente:</p>
<pre class=" language-bash"><code class="prism  language-bash">Sono il figlio1<span class="token operator">!</span> pid<span class="token operator">=</span>304 ppid<span class="token operator">=</span>303
Sono il figlio2<span class="token operator">!</span> pid<span class="token operator">=</span>305 ppid<span class="token operator">=</span>303
ricevuta terminazione di pid<span class="token operator">=</span>304
OK: status <span class="token operator">=</span> 42
ricevuta terminazione di pid<span class="token operator">=</span>305
ANOMALO: status <span class="token operator">=</span> 11
</code></pre>
<h1 id="segnali">Segnali</h1>
<p>I <strong>segnali</strong> sono una forma di <strong>comunicazione tra processi</strong> realizzati tramite interruzioni software causate da vari eventi.<br>
Gli eventi generalmente sono:</p>
<ul>
<li>Generati dal terminale (ad esempio <code>Ctrl + c</code>)</li>
<li>Generati da errori di esecuzione (divisione per 0)</li>
<li>Segnali inviati da un altro processo</li>
<li>Eventi asincroni notificati al processo</li>
</ul>
<p>Le operazioni che possono essere fatte quando un processo riceve un segnale sono:</p>
<ul>
<li>Ignorarlo</li>
<li>Gestirlo</li>
<li>Lasciare che il sistema operativo lo gestisca</li>
</ul>
<p>Vediamo alcune dei segnali supportati in Linux (lista consultabile eseguendo <code>man 7 signal</code>)<br>
<img src="https://i.ibb.co/Lt6Sp4z/image.png" alt="enter image description here"></p>
<p>Descriviamo brevemente alcuni dei segnali:</p>
<ul>
<li><code>SIGHUP</code> viene inviato a un processo quando il terminale a cui è associato viene chiuso</li>
<li><code>SIGINT</code> viene inviato a un processo digitando  <code>Ctrl-c</code>  per interromperlo</li>
<li><code>SIGQUIT</code> viene inviato per far terminare un processo tramite la sequenza  <code>ctrl-\</code></li>
<li><code>SIGILL</code>,  <code>SIGABRT</code>,  <code>SIGFPE</code>  e  <code>SIGSEGV</code> corrispondono ad azioni del processo stesso: istruzione illegale, invocazione di  <code>abort</code>, errore aritmetico, riferimento a memoria illegale</li>
<li><code>SIGKILL</code>,  <code>SIGTERM</code> sono esempi di segnale inviati da un processo a un altro, che vengono utilizzati per terminare un processo. Questi segnali si possono inviare dalla shell tramite i comando  <code>kill -9 pid</code>  oppure  <code>kill pid</code>. Si noti che  <code>SIGKILL</code> termina sempre il processo che riceve il segnale mentre  <code>SIGTERM</code>  può essere gestito o ignorato dal processo</li>
<li><code>SIGPIPE</code> viene inviato a un processo che prova a scrivere su una pipe che non ha lettori</li>
<li><code>SIGALRM</code> è un timer che “sveglia” un processo, simile al timer usato dallo scheduler per implementare il time-sharing</li>
<li><code>SIGCHLD</code> viene inviato a un processo quando un suo processo figlio termina (il segnale viene utilizzato per svegliare un processo che ha invocato la  <code>wait</code>, altrimenti viene ignorato)</li>
</ul>
<p>Nella tabella precedente è presente una colonna <code>Action</code> che rappresenta l’azione di default per ogni segnale:</p>
<ul>
<li><code>Term</code>: termina il processo</li>
<li><code>Ign</code>: viene ignorato</li>
<li><code>Core</code>: termina il processo e genera un <em>dump</em> della memoria del processo (come succede con il <em>segmentation fault</em>)</li>
<li><code>Stop</code>: ferma il processo</li>
<li><code>Cont</code>: fa continuare un processo che è stato fermato in precedenza</li>
</ul>
<h2 id="esempio-di-utilizzo-di-un-segnale">Esempio di utilizzo di un segnale</h2>
<p>L’esempio più semplice di segnale è <code>SIGALRM</code> che viene generato tramite la funzione <code>alarm(unsigned int)</code> la quale prende in input la quantità di secondi prima di lanciare il segnale <code>SIGALRM</code>. Quando questo segnale viene ricevuto, il processo viene terminato (come comportamento di default).<br>
Equivale a tutti gli effetti a impostare una sveglia che termina il processo quando scade il suo tempo.</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">alarm</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//dopo 3 secondi il processo viene terminato</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>	
<span class="token punctuation">}</span>
</code></pre>
<p>Nota che questo è un evento <strong>asincrono</strong>: mentre il timer scorre il nostro codice prosegue la sua normale esecuzione.<br>
Nota anche che dopo la terminazione viene stampato <code>Alarm clock</code> sul terminale in quanto la shell è in grado di interpretare il valore di ritorno del processo (si può vedere tale valore eseguendo <code>echo $?</code> dopo la terminazione del programma)</p>
<h2 id="syscall-signal">Syscall “signal”</h2>
<p>Tramite la <em>System call</em> <strong>signal</strong> è possibile modificare la gestione di default di un segnale, prende come input il segnale e il nome della nuova funzione che verrà utilizzata quando tale segnale si presenta.</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">alarmHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"questo me lo gestisco io!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">alarm</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ri-setta il timer a 3 secondi e riprende l'esecuzione dal punto</span>
			  <span class="token comment">//in cui si era interrotto (il ciclo while in questo caso)</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token function">signal</span><span class="token punctuation">(</span>SIGALRM<span class="token punctuation">,</span> alarmHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">alarm</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Al posto di una funzione in particolare è possibile passare alla funzione <code>signal</code> anche costanti come <code>SIG_IGN</code> per dire che il segnale va semplicemente ignorato, oppure <code>SIG_DFL</code> per dire di utilizzare il comportamento di default.</p>
<p>Il <strong>valore di ritorno</strong> di <code>signal</code> è:</p>
<ul>
<li><code>SIG_ERR</code>, in caso di errore</li>
<li>il gestore precedente, in caso di successo (utile se vogliamo ripristinare il comportamento successivamente)</li>
</ul>
<p>Vediamo un esempio:</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>old<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//firma di una funzione che prende un intero e restituisce void</span>
        
    old <span class="token operator">=</span> <span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span>SIG_IGN<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//ignora il segnale SIGINT (cioè il ctrl + c)</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sono protetto!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
    <span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span>old<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//ripristina il comportamento precedente </span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Non sono più protetto!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Il comportamento che otteniamo è che per i primi 3 secondi fare <code>ctrl + c</code> non avrà effetto, mentre nei 3 secondi successivi torna normale.</p>
<h2 id="syscall-kill">Syscall “kill”</h2>
<p>Sebbene il nome si un po’ fuorviante, la <em>system call</em> <strong>kill</strong> si occupa solamente di <strong>mandare un qualsiasi segnale ad un processo (specificandone il pid)</strong> (il nome è rimasto “kill” per ragioni storiche).<br>
Ad esempio possiamo usarlo per sospendere, ripristinare o terminare un processo</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        pid_t pid1<span class="token punctuation">,</span> pid2<span class="token punctuation">;</span>
        pid1 <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pid1 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"errore fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// primo figlio</span>
                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d è vivo !\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
        pid2 <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pid2 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"errore fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid2 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// secondo figlio</span>
                        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d è vivo !\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
        <span class="token comment">// processo genitore</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">kill</span><span class="token punctuation">(</span>pid1<span class="token punctuation">,</span>SIGSTOP<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sospende il primo figlio</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">kill</span><span class="token punctuation">(</span>pid1<span class="token punctuation">,</span>SIGCONT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// risveglia il primo figlio</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">kill</span><span class="token punctuation">(</span>pid1<span class="token punctuation">,</span>SIGINT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// termina il primo figlio</span>
        <span class="token function">kill</span><span class="token punctuation">(</span>pid2<span class="token punctuation">,</span>SIGINT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// termina il secondo figlio       </span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="mascherare-i-segnali">Mascherare i segnali</h2>
<p><strong>Mascherare i segnali significa posticiparli momentaneamente</strong>.<br>
Questo può essere utile se il programma sta facendo delle operazioni importanti come lunghe scritture su disco, o operazioni su strutture dati e non si vuole che dei segnali interferiscano con tali operazioni. Si mascherano quindi i segnali fino al termine delle operazioni critiche e successivamente i segnali posticipati vengono notificati al processo.</p>
<p>Solitamente quanto più segnali uguali vengono posticipati solamente 1 ne viene recapitato una volta sbloccati i segnali.</p>
<p>Il mascheramento dei segnali viene fatto attraverso degli <strong>insiemi di segnali</strong>, possiamo fare svariate operazioni su tali insiemi</p>
<h3 id="creare-un-insieme">Creare un insieme</h3>
<p><code>sigemptyset(sigset_t *set)</code></p>
<p>inizializza l’insieme vuoto <code>set</code></p>
<h3 id="aggiunta-di-elementi">Aggiunta di elementi</h3>
<p><code>sigaddset(sigset_t *set, int signum)</code></p>
<p>Aggiunge il segnale <code>signum</code> all’insieme <code>set</code></p>
<h3 id="rimozione-di-elementi">Rimozione di elementi</h3>
<p><code>sigdelset(sigset_t *set, int signum)</code></p>
<p>Rimuove il segnale <code>signum</code> dall’insieme <code>set</code></p>
<h3 id="mascheramento">Mascheramento</h3>
<p>Tramite la <em>system call</em> <code>sigprocmask(int action, sigset_t *newmask, sigset_t *oldmask)</code> possiamo gestire il mascheramento, che avviane in base al valore passato al parametro <code>action</code>:</p>
<ul>
<li><code>SIG_BLOCK</code>: l’insieme dei segnali  <code>newmask</code>  viene  <strong>unito</strong>  all’insieme dei segnali attualmente mascherati, che sono restituiti in  <code>oldmask</code>;</li>
<li><code>SIG_UNBLOCK</code>: l’insieme dei segnali  <code>newmask</code>  viene  <strong>sottratto</strong>  dai segnali attualmente mascherati, sempre restituiti in  <code>oldmask</code>;</li>
<li><code>SIG_SETMASK</code>: l’insieme dei segnali  <code>newmask</code>  <strong>sostituisce</strong>  quello dei segnali attualmente mascherati (<code>oldmask</code>).</li>
</ul>
<p>Vediamo un esempio in cui mascheriamo il segnale <code>SIGINT</code></p>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sigset_t newmask<span class="token punctuation">,</span> oldmask<span class="token punctuation">;</span>

        <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>newmask<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// insieme vuoto</span>
        <span class="token function">sigaddset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>newmask<span class="token punctuation">,</span> SIGINT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// aggiunge SIGINT alla "maschera"</span>
        <span class="token comment">// setta la nuova maschera e memorizza la vecchia</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>newmask<span class="token punctuation">,</span> <span class="token operator">&amp;</span>oldmask<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"errore settaggio maschera"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sono protetto!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// reimposta la vecchia maschera</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>oldmask<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"errore settaggio maschera"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Non sono piu' protetto!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Quello che otteniamo è che nei primi 3 secondi i <code>ctrl + c</code> vengono posticipati, appena scadono i 3 secondi, l’eventuale <code>ctrl + c</code> precedentemente mandato, viene subito notificato il processo il quale terminerà la sua esecuzione.</p>
<p>Tramite <code>sigpending</code> è possibile vedere i segnali che attualmente sono in attesa di essere notificati al processo.</p>
<h1 id="pipe">Pipe</h1>
<p>Le pipe sono un canale di comunicazione tra i processi, in altre parole la pipe è un buffer (cioè una zona di memoria) in cui un processo scrive dei dati e un altro processo legge i dati.</p>
<p>Questo meccanismo utilizza una <strong>scrittura asincrona</strong> e una <strong>lettura sincrona</strong> (quindi chi scrive non attende una risposta dall’altro processo. Mentre chi legge rimane in attesa che i dati arrivino)</p>
<p>Esistono due tipi di pipe in UNIX: <strong>senza nome</strong> e <strong>con nome</strong></p>
<h2 id="pipe-senza-nome">Pipe senza nome</h2>
<p>Queste pipe vengono utilizzate da processi che hanno genitori in comune, questo perché le risorse vengono ereditati dai genitori.</p>
<p>Un classico esempio di questo tipo di pipe è l’uso del simbolo <code>|</code> per collegare due programmi da shell</p>
<pre><code>$ ls -la | grep 20
</code></pre>
<p>In codice invece possiamo usare la <em>system call</em> <code>pipe(int file_descriptor[2])</code>.<br>
La funzione <code>pipe</code> prende in input un vettore di interi grande 2, in tale vettore la funzione scriverà dei valori numerici chiamati descrittori, tali che:</p>
<ul>
<li><code>file_descriptor[0]</code> usato per la lettura</li>
<li><code>file_descriptor[1]</code> usato per la scrittura</li>
</ul>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 
  <span class="token function">pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* crea la pipe */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">//figlio</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>phrase <span class="token operator">=</span> <span class="token string">"prova a inviare questo!"</span><span class="token punctuation">;</span>
 
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">/* chiude in lettura */</span>
    <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> phrase<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>phrase<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* invia anche 0x00 (terminatore della stringa) */</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">/* chiude in scrittura */</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">else</span> <span class="token punctuation">{</span>	<span class="token comment">//padre</span>
    <span class="token keyword">char</span> message<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">//alloco spazio per contenere il messaggio letto dalla pipe</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//è importante azzerare la memoria allocata quando si legge dai buffer</span>
    <span class="token keyword">int</span> bytesread<span class="token punctuation">;</span>
 
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">/* chiude in scrittura */</span>
    bytesread <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> message<span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//l'ultimo parametro indica il limite massimo di byte da leggere</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ho letto dalla pipe %d bytes: '%s' \n"</span><span class="token punctuation">,</span> bytesread<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">/* chiude in lettura */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>Osservazioni</strong>:</p>
<ul>
<li>Il programma crea due processi collegati da una pipe, un processo (il figlio) scrive dei dati e il padre li legge</li>
<li>La pipe viene creata prima della fork, ciò significa che il <strong>padre e il figlio avranno una copia ciascuno dell’array</strong> <code>fd</code></li>
<li>Un processo dovrebbe sempre <strong>scrivere oppure leggere ma mai fare entrambe le cose</strong> con la stessa pipe (se necessaria una comunicazione bidirezionale si possono usare pipe distinte per scrittura e lettura).<br>
Se un processo leggesse e scrivesse utilizzando la stessa pipe rischierebbe di leggere ciò che lui stesso ha scritto</li>
<li>Per il punto precedente è quindi raccomandato <strong>chiudere immediatamente il file descriptor che non si utilizza</strong> (infatti il figlio chiude immediatamente la lettura e il padre chiude immediatamente la scrittura)</li>
<li>Nel figlio chiudere la scrittura dopo aver terminato di scrivere è importante in quanto viene avvisto il lettore che non c’è più niente da leggere</li>
</ul>
<h3 id="importanza-della-chiusura-dei-descrittori">Importanza della chiusura dei descrittori</h3>
<p>Il sistema operativo tiene traccia di chi può scrivere o leggere nelle pipe, chiudendo la scrittura e la lettura della pipe mantiene aggiornato il sistema operativo su cosa può fare ancora il nostro processo:</p>
<ul>
<li>
<p>Cosa accade se si fa una <code>read</code> da una pipe vuota in cui la scrittura è stata chiusa?</p>
<p>Normalmente se ci sono scrittori allora la <code>read</code> rimarrebbe in attesa. Ma dal momento che i processi che condividevano la pipe hanno chiuso la scrittura (nessuno può più scrivere) allora la <code>read</code> termina l’attesa e ritorna <code>0</code>.<br>
Se gli scrittori si dimenticassero di chiudere la pipe in scrittura allora il lettore rimarrebbe in attesa fino a che i processi scrittori terminano la loro esecuzione (causando un errore al lettore)</p>
</li>
<li>
<p>Cosa accade se si fa una <code>write</code> su una pipe che è stata chiusa in lettura?</p>
<p>Viene generato un segnale <code>SIGPIPE</code> che di default termina il processo. Questo accade in quanto non ha senso scrive nel buffer se nessun altro processo può leggere i dati.</p>
</li>
</ul>
<p><strong>È quindi molto importante chiudere le risorse in lettura e scrittura quando possibile</strong></p>
<h3 id="simulazione-della-pipe-da-shell">Simulazione della pipe da shell</h3>
<p>Cerchiamo di simulare, attraverso un programma, il comportamento della pipe realizzata da shell.</p>
<p>Innanzitutto è importante capire che i descrittori di file in Unix sono dei numeri, e sono presenti 3 descrittori di base:</p>
<ul>
<li>0: <em>standard input</em></li>
<li>1: <em>standard output</em></li>
<li>2: <em>standard error</em></li>
</ul>
<p>Quando viene chiamata la <em>system call</em> <code>pipe</code> vengono selezionati numeri incrementali a partire da 3.<br>
Sapendo questo vediamo come simulare il seguente comando da shell</p>
<pre><code>$ prog1 | prog2
</code></pre>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function">pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">/* chiude in lettura */</span>
    <span class="token function">dup2</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">/* fa si che 1 (stdout) sia una copia di fd[1] */</span>
                        <span class="token comment">/* da qui in poi l'output va sulla pipe */</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">/* chiude il descrittore fd[1] */</span>
    <span class="token function">execlp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">/* esegue il comando */</span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"errore esecuzione primo comando"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">/* chiude in scrittura */</span>
    <span class="token function">dup2</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">/* fa si che 0 (stdin) sia una copia di fd[0] */</span>
                        <span class="token comment">/* da qui in poi l'input proviene dalla pipe */</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">/* chiude il descrittore fd[0] */</span>
    <span class="token function">execlp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">/* esegue il comando */</span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"errore esecuzione secondo comando"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Possiamo eseguirlo facendo</p>
<pre><code>$ ./simula_pipe whoami wc
</code></pre>
<p>notando come viene generato lo stesso output di</p>
<pre><code>$ whoami | wc
</code></pre>
<h2 id="pipe-con-nome">Pipe con nome</h2>
<p>Con questo altro metodo le pipe sono dei file presenti nel <em>file system</em> e quindi ogni processo ha il diritto di accesso alla pipe indipendentemente dai genitori.</p>
<p>Possiamo creare una pipe tramite il comando</p>
<pre><code>$ mkfifo myPipe
</code></pre>
<h2 id="esempio-lettore-e-scrittore">Esempio lettore e scrittore</h2>
<p>Consideriamo un processo <em>lettore</em> (destinatario) che accetta, su una pipe con nome, messaggi provenienti da più <em>scrittori</em> (mittenti). Gli scrittori mandano 3 messaggi e poi terminano. Quando tutti gli scrittori chiudono la pipe il lettore ottiene 0 come valore di ritorno dalla <code>read</code> ed esce.<br>
Lettori e scrittori sono processi distinti lanciati indipendentemente (non necessariamente parenti).</p>
<p><strong>Codice del lettore</strong></p>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token macro property">#<span class="token directive keyword">define</span> PNAME "/tmp/aPipe"</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
    <span class="token keyword">char</span> leggi<span class="token punctuation">;</span>
    
    <span class="token function">mkfifo</span><span class="token punctuation">(</span>PNAME<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// crea la pipe con nome, se esiste già non fa nulla</span>

    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>PNAME<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// apre la pipe in sola lettura</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"errore apertura pipe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>leggi<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// legge un carattere alla volta fino a EOF</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>leggi <span class="token operator">==</span> <span class="token string">'\0'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a capo dopo ogni stringa</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span>leggi<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// chiude il descrittore</span>
    <span class="token function">unlink</span><span class="token punctuation">(</span>PNAME<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// rimuove la pipe</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>Codice dello scrittore</strong></p>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token macro property">#<span class="token directive keyword">define</span> PNAME "/tmp/aPipe"</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">,</span> i<span class="token punctuation">,</span> lunghezza<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>message<span class="token punctuation">;</span>
    <span class="token function">mkfifo</span><span class="token punctuation">(</span>PNAME<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// crea la pipe con nome, se esiste gia' non fa nulla</span>
					     <span class="token comment">// il secondo parametro sono i permessi del file /tmp/aPipe</span>
    
    <span class="token comment">// crea la stringa</span>
    lunghezza <span class="token operator">=</span> <span class="token function">snprintf</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"Saluti dal processo %d"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    message <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>lunghezza <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">snprintf</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> lunghezza <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Saluti dal processo %d"</span> <span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>PNAME<span class="token punctuation">,</span> O_WRONLY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// apre la pipe in sola scrittura</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"errore apertura pipe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment">// scrive tre volte la stringa</span>
        <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> message<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// +1 perche include terminatore di stringa</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// chiude il descrittore</span>
    <span class="token function">free</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Eseguiamo per esempio:</p>
<pre><code>$ ./lettore &amp; ./scrittore &amp; ./scrittore &amp; ./scrittore
</code></pre>
<p>e otteniamo un output simile al seguente:</p>
<pre class=" language-bash"><code class="prism  language-bash"><span class="token punctuation">[</span>1<span class="token punctuation">]</span> 46998
<span class="token punctuation">[</span>2<span class="token punctuation">]</span> 46999
<span class="token punctuation">[</span>3<span class="token punctuation">]</span> 47000
Saluti dal processo 47000
Saluti dal processo 46999
Saluti dal processo 47001
						/*pausa di 2 secondi*/
Saluti dal processo 47000
Saluti dal processo 47001
Saluti dal processo 46999
						/*pausa di 2 secondi*/
Saluti dal processo 47000
Saluti dal processo 46999
Saluti dal processo 47001
<span class="token punctuation">[</span>1<span class="token punctuation">]</span>   Done                    ./lettore
<span class="token punctuation">[</span>2<span class="token punctuation">]</span>-  Exit 255                ./scrittore
<span class="token punctuation">[</span>3<span class="token punctuation">]</span>+  Exit 255                ./scrittore
</code></pre>
<p>le varie <code>write</code> vengono <strong>accodate nella pipe</strong>, e il lettore legge un carattere alla volta.</p>
<p>Il fatto che le scritture vengono accodate accade solo quando sono più corti di <code>PIPE_BUF</code>, solitamente 4096 byte.</p>
<p>Se eseguissimo più lettori contemporaneamente noteremmo delle interferenze nell’output in quanto vari lettori leggono caratteri in modo non sincronizzato dalla stessa pipe.</p>
<h1 id="thread">Thread</h1>
<p>Fino ad ora abbiamo visto come i <strong>processi possono comunicare solo tramite scambio di messaggi</strong>.<br>
Con i thread la comunicazione non avviene in questo modo.</p>
<p>Ricordiamo che:</p>
<ul>
<li><strong>processi</strong>: sono un contesto di esecuzione contenente tutte le informazioni necessarie al processo per funzionare (codice, dati,  <strong>memoria</strong>, I/O, ID, priorità, stato PC e registri, stack, …)</li>
<li><strong>thread</strong>: sono la parte del processo che si occupa dell’esecuzione.</li>
</ul>
<h2 id="memoria-condivisa">Memoria condivisa</h2>
<p>Un processo più avere più thread (<em>multi-threading</em>), e tutti i thread che appartengono allo stesso processo lavorano su una memoria condivisa (che è la memoria del processo).</p>
<p>Quindi con i thread la <strong>comunicazione avviene tramite la scrittura e la lettura su una memoria condivisa</strong></p>
<h2 id="produttore-e-consumatore">Produttore e consumatore</h2>
<p>Vediamo un esempio di un problema implementato con i processi e poi con i thread analizzando i vari aspetti da tenere in considerazione quando si utilizzano i thread.</p>
<p>Il problema del produttore e consumatore consiste che un processo/thread produca un dato e un altro processo/thread lo consumi:</p>
<h2 id="implementazione-con-i-processi">Implementazione con i processi</h2>
<p>Implementiamo ad un livello astratto il codice per implementare la comunicazione utilizzando i processi:</p>
<pre class=" language-c"><code class="prism  language-c">pipe A<span class="token punctuation">;</span>

<span class="token function">Produttore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// produce il dato 'd'</span>
		<span class="token function">send</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">// invia sulla pipe il dato 'd'</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">Consumatore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">receive</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>	<span class="token comment">// riceve sulla pipe il dato 'd'</span>
		<span class="token comment">// consuma il dato 'd'</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Utilizzando una <strong>send asincrona</strong> (invia il dato senza aspettare una risposta) e una <strong>receive sincrona</strong> (attendendo che arrivi il dato prima di leggere) otteniamo una soluzione soddisfacente</p>
<h2 id="implementazione-con-i-thread">Implementazione con i thread</h2>
<p>Andiamo ad implementare una soluzione <em>step-by-step</em> utilizzando i thread.</p>
<p>La memoria condivisa tra i thread si implementa solitamente tramite delle <strong>variabili globali</strong>.<br>
Avremo bisogno di:</p>
<ul>
<li>un <strong>array</strong> che farà da buffer per contenere i dati generati dal produttore</li>
<li>un <strong>indice</strong> che tiene conto di dove il produttore è arrivato a scrivere i dati nel buffer</li>
<li>un <strong>indice</strong> che tiene conto di dove il consumatore è arrivato a leggere i dati nel buffer</li>
</ul>
<p>Inizialmente immaginiamo che il nostro <strong>buffer sia di dimensione illimitata</strong><br>
<img src="https://i.ibb.co/dJy2FYn/image.png" alt="enter image description here"></p>
<pre class=" language-c"><code class="prism  language-c">data_t buffer<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">//buffer illimitato</span>
<span class="token keyword">int</span> read_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> write_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token function">Produttore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// produce il dato 'd'</span>
		buffer<span class="token punctuation">[</span>write_index<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">;</span>
		write_index<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">Consumatore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		d <span class="token operator">=</span> buffer<span class="token punctuation">[</span>read_index<span class="token punctuation">]</span><span class="token punctuation">;</span>
		read_index<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token comment">//consuma il dato 'd'</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Il problema di questa implementazione è che se il consumatore fosse più veloce del produttore esso non attenderebbe che ci siano dei dati validi nel buffer prima di leggere.</p>
<p>Un approccio potrebbe essere di creare una attesa attiva (<em>busy waiting</em>) cosicché il buffer si riempia con dati validi:</p>
<pre class=" language-c"><code class="prism  language-c">data_t buffer<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">//buffer illimitato</span>
<span class="token keyword">int</span> read_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> write_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token function">Produttore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// produce il dato 'd'</span>
		buffer<span class="token punctuation">[</span>write_index<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">;</span>
		write_index<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">Consumatore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">//impedisco che l'indice di lettura superi quello della scrittura</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>read_index <span class="token operator">==</span> write_index<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

		d <span class="token operator">=</span> buffer<span class="token punctuation">[</span>read_index<span class="token punctuation">]</span><span class="token punctuation">;</span>
		read_index<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token comment">//consuma il dato 'd'</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Questo approccio sistema le cose, però adesso dobbiamo risolvere il fatto che abbiamo assunto di avere un buffer di dimensione illimitata, che non è realistico.<br>
Possiamo implementare una soluzione che utilizza un <strong>buffer circolare con una dimensione prefissata</strong><br>
<img src="https://i.ibb.co/svDDVBg/image.png" alt="enter image description here"></p>
<pre class=" language-c"><code class="prism  language-c">data_t buffer<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">//buffer di dimensione MAX</span>
<span class="token keyword">int</span> read_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> write_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token function">Produttore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// produce il dato 'd'</span>
		buffer<span class="token punctuation">[</span>write_index<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">;</span>
		write_index <span class="token operator">=</span> <span class="token punctuation">(</span>write_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">Consumatore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>read_index <span class="token operator">==</span> write_index<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>	<span class="token comment">//impedisco che l'indice di lettura superi quello della scrittura</span>
		d <span class="token operator">=</span> buffer<span class="token punctuation">[</span>read_index<span class="token punctuation">]</span><span class="token punctuation">;</span>
		read_index <span class="token operator">=</span> <span class="token punctuation">(</span>read_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX<span class="token punctuation">;</span>
		<span class="token comment">//consuma il dato 'd'</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In questo modo il produttore quando raggiunge l’ultima cella (in posizione <code>MAX - 1</code>) ripartirà a scrivere dalla posizione <code>0</code>.<br>
Il problema è che se il <strong>produttore è più veloce del consumatore rischia di sovrascrivere delle celle ancora non lette dal consumatore</strong></p>
<p>Per ovviare a questo problema possiamo mettere in attesa il produttore quando i due indici sono a una cella di distanza:</p>
<pre class=" language-c"><code class="prism  language-c">data_t buffer<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">//buffer di dimensione MAX</span>
<span class="token keyword">int</span> read_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> write_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token function">Produttore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// produce il dato 'd'</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>write_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX <span class="token operator">==</span> read_index<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 	<span class="token comment">//se fare la scrittura corrente mi porterebbe allo stesso indice della lettura allora attendo</span>
		buffer<span class="token punctuation">[</span>write_index<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">;</span>
		write_index <span class="token operator">=</span> <span class="token punctuation">(</span>write_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">Consumatore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>read_index <span class="token operator">==</span> write_index<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>	<span class="token comment">//impedisco che l'indice di lettura superi quello della scrittura</span>
		d <span class="token operator">=</span> buffer<span class="token punctuation">[</span>read_index<span class="token punctuation">]</span><span class="token punctuation">;</span>
		read_index <span class="token operator">=</span> <span class="token punctuation">(</span>read_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX<span class="token punctuation">;</span>
		<span class="token comment">//consuma il dato 'd'</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Questa soluzione seppure accettabile ha dei difetti:</p>
<ul>
<li>spreca una cella del buffer (per sapere quando mettere in attesa il produttore)</li>
<li>spreca tempo di CPU con i cicli a vuoto (a causa del ciclo while)</li>
<li>non scala con più produttori e consumatori, in quanto interferirebbero tra loro con gli indici</li>
</ul>
<h2 id="interferenza">Interferenza</h2>
<p>Per risolvere il primo problema potremmo pensare di utilizzare una variabile condivisa tra i due thread che si occupa di contare quante celle sono presenti nel buffer che non sono ancora state lette.<br>
Quindi il produttore incrementa questo contatore mentre il consumatore lo decrementa:</p>
<pre class=" language-c"><code class="prism  language-c">data_t buffer<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">//buffer di dimensione MAX</span>
<span class="token keyword">int</span> read_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> write_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token function">Produttore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// produce il dato 'd'</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>counter <span class="token operator">==</span> MAX<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 	<span class="token comment">//se la scrittura corrente mi porterebbe allo stesso indice della lettura allora attendo</span>
		buffer<span class="token punctuation">[</span>write_index<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">;</span>
		write_index <span class="token operator">=</span> <span class="token punctuation">(</span>write_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX<span class="token punctuation">;</span>
		counter<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">Consumatore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>counter <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>	<span class="token comment">//impedisco che l'indice di lettura superi quello della scrittura</span>
		d <span class="token operator">=</span> buffer<span class="token punctuation">[</span>read_index<span class="token punctuation">]</span><span class="token punctuation">;</span>
		read_index <span class="token operator">=</span> <span class="token punctuation">(</span>read_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX<span class="token punctuation">;</span>
		counter<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token comment">//consuma il dato 'd'</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Questo codice seppur sembri corretto non lo è.<br>
Infatti è possibile che la variabile counter venga aggiornata contemporaneamente dal consumatore e dal produttore, generando una <strong>race condition</strong> che può portare ad aggiornare la variabile in modo errato:</p>
<p>Se andiamo ad analizzare a basso livello come funziona l’aggiornamento di una variabile, possiamo dividere l’operazione in 3 punti:</p>
<ol>
<li>lettura dalla memoria del valore attuale della variabile (viene salvato il valore in un registro)</li>
<li>aggiornamento al nuovo valore	(viene modificato il registro)</li>
<li>salvataggio del nuovo valore in memoria	(viene salvato il valore nel registro nella memoria)</li>
</ol>
<p>Se immaginiamo che <code>counter = 10</code> e ipotizziamo che sia il produttore che il consumatore facciano una modifica, possiamo avere 3 comportamenti diversi in base allo scheduling dei thread:</p>
<ol>
<li>Primo caso:
<ul>
<li>il consumatore esegue consecutivamente i 3 passi: <code>counter: 10 - 1 = 9</code></li>
<li>successivamente il produttore esegue consecutivamente i 3 passi: <code>counter: 9 + 1 = 10</code></li>
<li>valore finale <code>counter = 10</code></li>
<li>Questo caso risulta essere corretto in quanto prima uno decrementa e poi l’altro incrementa e ritorniamo allo stesso risultato iniziale</li>
</ul>
</li>
<li>Secondo caso:
<ul>
<li>il consumatore fa solo il passo 1 (lettura del valore dalla memoria): <code>counter: 10</code></li>
<li>poi il produttore esegue consecutivamente i 3 passi: <code>counter: 10 + 1 = 11</code></li>
<li>infine il consumatore esegue i 2 passi rimanenti: <code>counter: 10 - 1 = 9</code></li>
<li>valore finale <code>counter = 9</code></li>
<li>Questo caso non è corretto in quanto un incremento e un decremento generano un risultato diverso da quello iniziale.<br>
Questo accade perché il consumatore ha letto il dato iniziale e poi si è fermato, intanto però il produttore ha aggiornato il valore del <code>counter</code>. Quando poi il consumatore riprende l’esecuzione possiede un dato ormai obsoleto e continua a lavorare su di esso.</li>
</ul>
</li>
<li>Terzo caso (simmetrico al secondo):
<ul>
<li>il produttore fa solo il passo 1 (lettura del valore dalla memoria): <code>counter: 10</code></li>
<li>poi il consumatore esegue consecutivamente i 3 passi: <code>counter: 10 - 1 = 9</code></li>
<li>infine il produttore esegue i 2 passi rimanenti: <code>counter: 10 + 1 = 11</code></li>
<li>valore finale <code>counter = 11</code></li>
<li>Questo caso non è corretto in quanto un incremento e un decremento generano un risultato diverso da quello iniziale.<br>
Questo accade perche il produttore ha letto il dato iniziale e poi si è fermato, intanto però il consumatore ha aggiornato il valore del <code>counter</code>. Quando poi il produttore riprende l’esecuzione possiede un dato ormai obsoleto e continua a lavorare su di esso.</li>
</ul>
</li>
</ol>
<p>Per poter risolvere questo problema abbiamo bisogno di coordinare le operazioni di aggiornamento delle variabili condivise tra i thread.</p>
<h1 id="sezione-critica">Sezione critica</h1>
<p>La <strong>sezione critica</strong> è una parte del codice soggetta a <strong>race condition</strong>, cioè parti in cui più thread accedono e modificano a variabili condivise.</p>
<p>Per evitare che i thread interferiscano tra di loro nella modifica delle variabili condivise dobbiamo sincronizzare i thread in modo che la sezione critica sia eseguita in <strong>mutua esclusione</strong>: cioè un thread alla volta accede alla sezione critica.</p>
<p><strong>La mutua esclusione va garantita a prescindere dalla schedulazione dei thread</strong></p>
<p>Ottenere la mutua esclusione possiamo tentare 2 diversi approcci:</p>
<ul>
<li>Soluzioni software</li>
<li>Soluzioni hardware (chiamate a sistema)</li>
</ul>
<h2 id="soluzioni-software">Soluzioni software</h2>
<p>Vediamo dei tentativi di soluzioni software.<br>
Consideriamo per semplicità la concorrenza con solamente 2 thread.<br>
Nelle implementazioni reali solitamente non si usano implementazioni software.</p>
<h2 id="tentativo-1-lock">Tentativo 1: Lock</h2>
<p>Utilizziamo una variabile booleana globale chiamata <code>lock</code>. Tale variabile indica, quando è <code>true</code>, che la sezione critica è occupata da un thread, mentre quando è <code>false</code>indica che la sezione critica è libera.</p>
<pre class=" language-c"><code class="prism  language-c">global bool lock<span class="token punctuation">;</span>
thread T <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>	<span class="token comment">// se il lock è true attende</span>
  lock <span class="token operator">=</span> true<span class="token punctuation">;</span>
  <span class="token operator">&lt;</span> sezione critica <span class="token operator">&gt;</span>
  lock <span class="token operator">=</span> false<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>Problema</strong>: può accadere che i due thread riescano a superare entrambi il ciclo while, questo perché il primo thread che entra non fa in tempo a settare <code>lock = true</code> e un altro thread supera il while.<br>
Per questo motivo la mutua esclusione non è garantita.</p>
<h2 id="tentativo-2-turno">Tentativo 2: Turno</h2>
<p>Utilizziamo una variabile booleana globale chiamata <code>turno</code> inizializzata a <code>true</code>. Questa variabile indica quale thread può accedere alla sezione critica</p>
<pre class=" language-c"><code class="prism  language-c">global turno <span class="token operator">=</span> <span class="token number">0</span>

thread T0 <span class="token punctuation">{</span>                        thread T1 <span class="token punctuation">{</span> 
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
  <span class="token keyword">while</span><span class="token punctuation">(</span>turno <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>turno <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    
  <span class="token operator">&lt;</span> sezione critica <span class="token operator">&gt;</span>                 <span class="token operator">&lt;</span> sezione critica <span class="token operator">&gt;</span>   
  turno <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                          turno <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
<span class="token punctuation">}</span>                                   <span class="token punctuation">}</span>
</code></pre>
<p>Quindi il thread <code>T0</code> entra solo quando la variabile turno è <code>0</code> mentre <code>T1</code> entra solo quando turno è <code>1</code></p>
<p>La <strong>mutua esclusione</strong> è garantita in quanto la variabile turno non può valere <code>0</code> e <code>1</code> contemporaneamente.</p>
<p><strong>Problema</strong>: immaginiamo che il thread <code>T0</code> voglia entrare molto spesso in sezione critica mentre il thread <code>T1</code> ci accede raramente.<br>
Otteniamo che il thread <code>T0</code> si troverà spesso ad aspettare il turno di <code>T1</code> anche se la sezione critica è effettivamente libera (perché <code>T1</code> sta facendo altro)</p>
<p>Dobbiamo quindi garantire una proprietà chiamata <strong>progresso</strong>: se la sezione critica è libera e un thread vuole entrarci allora ci deve accedere subito.</p>
<h2 id="tentativo-3-pronto">Tentativo 3: Pronto</h2>
<p>Utilizziamo un array booleano globale con valori inizializzati a <code>false</code>, come nel tentativo 1 anche in questo caso gli elementi dell’array indicano che il thread i-esimo può accedere alla sezione critica</p>
<pre class=" language-c"><code class="prism  language-c">global boolean pronto<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> false

thread T0 <span class="token punctuation">{</span>                        thread T1 <span class="token punctuation">{</span> 
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
  pronto<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>                   pronto<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>pronto<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>                 <span class="token keyword">while</span><span class="token punctuation">(</span>pronto<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    
  <span class="token operator">&lt;</span> sezione critica <span class="token operator">&gt;</span>                 <span class="token operator">&lt;</span> sezione critica <span class="token operator">&gt;</span>   
  pronto<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>                  pronto<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
<span class="token punctuation">}</span>                                   <span class="token punctuation">}</span>
</code></pre>
<p>Analizziamo per esempio il thread <code>T0</code>:</p>
<ul>
<li>Con l’istruzione <code>pronto[0] = true</code> avvisa gli altri thread che lui vuole entrare nella sezione critica.</li>
<li><code>while(pronto[1]) {}</code>: finche c’è un altro thread che è già pronto allora attendo che finisca.</li>
<li>se l’altro thread non vuole accedere alla sezione critica allora ci entra il nostro thread e quando ha finito imposta <code>pronto[0] = false</code></li>
</ul>
<p>La <strong>mutua esclusione</strong> è garantita in quanto se un thread è in sezione critica la sua variabile è impostata a true e l’altro thread rimarrà fermo al while</p>
<p><strong>Problema</strong>: potrebbe capitare che entrambi impostino simultaneamente il proprio valore nell’array a true, se ciò accadesse rimarrebbero bloccati entrambi i thread nel while (si attendono a vicenda ma in realtà nessuno dei due è riuscito ad entrare in sezione critica)</p>
<h2 id="algoritmo-di-peterson">Algoritmo di Peterson</h2>
<p>Una soluzione funzionante è un algoritmo chiamato <strong>algoritmo di Peterson</strong> che è una combinazione dei due precedenti tentativi (turno e pronto)</p>
<p>Il tentativo con pronto sarebbe buono se non fosse per lo stallo, ma integrando il tentativo con turno lo possiamo evitare: effettuiamo una turnazione solamente quando siamo nel caso problematico (entrambi i thread sono pronti). Mentre se un solo thread è pronto allora può procedere tranquillamente.</p>
<pre class=" language-c"><code class="prism  language-c">global bool lock<span class="token punctuation">;</span>
global boolean pronto<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> false

thread T0 <span class="token punctuation">{</span>                              thread T1 <span class="token punctuation">{</span> 
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
  pronto<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>                         pronto<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>
  turno<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                                  turno<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>pronto<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turno <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>         <span class="token keyword">while</span><span class="token punctuation">(</span>pronto<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turno <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    
  <span class="token operator">&lt;</span> sezione critica <span class="token operator">&gt;</span>                       <span class="token operator">&lt;</span> sezione critica <span class="token operator">&gt;</span>   
  pronto<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>                        pronto<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
<span class="token punctuation">}</span>                                         <span class="token punctuation">}</span>
</code></pre>
<p>Analizziamo per esempio il thread <code>T0</code>:</p>
<ul>
<li>Con l’istruzione <code>pronto[0] = true</code> avvisa gli altri thread che lui vuole entrare nella sezione critica.</li>
<li><code>turno = 1</code> indica che il thread <code>T0</code> lascia il turno all’altro thread</li>
<li><code>while(pronto[1] &amp;&amp; turno != 0) {}</code>: rimango in attesa se l’altro thread è pronto <strong>e</strong> se il turno non è mio</li>
<li>se tale condizione non vale allora entro nella sezione</li>
</ul>
<p>La mutua esclusione è garantita in quanto se un thread riesce ad entrare nella sezione critica allora il suo valore nell’array è <code>true</code> e il turno sarà del thread che è in sezione critica (altrimenti non avrebbe superato il while).<br>
La varibile <code>turno</code> ci garantisce che in caso di entrambi i thread pronti solamente uno dei due possa entrare in quanto non può valere <code>0</code> e <code>1</code> contemporaneamente.</p>
<p>Nota che se la sezione critica è libera allora il thread che ci vuole accedere può entrare immediatamente in quanto la prima condizione del while risulterà falsa e quindi la seconda condizione viene direttamente ignorata.</p>
<h2 id="conclusione-soluzione-software">Conclusione soluzione software</h2>
<p>In generale seppur fattibili le soluzioni software presentano dei problemi:</p>
<ol>
<li>i cicli a vuoto consumano tempo di CPU</li>
<li>Sono richieste variabili globali ed è necessaria una precisa sequenza di istruzioni.<br>
I moderni compilatori spesso riordinano le istruzioni per ottimizzare le prestazioni, ma non tengono conto della possibile esecuzione parallela del codice, un riordinamento potrebbe portare e non sincronizzare più i thread correttamente.<br>
Tali ottimizzazioni fatte dal compilatore andrebbero quindi disattivate per mantenere la correttezza, perdendo però delle possibili performance in più.</li>
</ol>
<h2 id="soluzioni-hardware">Soluzioni hardware</h2>
<p>Esistono delle istruzioni speciali implementate in linguaggio macchina in modo che sia garantita la mutua esclusione su un pezzo di codice.</p>
<p>Un esempio potrebbe essere l’istruzione <strong>test_and_set</strong>, che permette di testare un valore ed assegnarlo tramite una sequenza di istruzioni indivisibili.<br>
Possiamo immaginare che sia implementata in un modo del genere:</p>
<pre class=" language-c"><code class="prism  language-c">boolean <span class="token function">test_and_set</span><span class="token punctuation">(</span>boolean <span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    boolean ret <span class="token operator">=</span> <span class="token operator">*</span>x<span class="token punctuation">;</span>
    <span class="token operator">*</span>x <span class="token operator">=</span> true<span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Pone a true la variabile <code>x</code> (che viene passata per indirizzo) e poi ritorna il suo vecchio valore.</p>
<p>Potremmo usare questa istruzione per implementare il nostro primo tentativo con <code>lock</code> nella soluzione software:</p>
<pre class=" language-c"><code class="prism  language-c">global boolean lock<span class="token punctuation">;</span>
thread T <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">test_and_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token operator">&lt;</span> sezione critica <span class="token operator">&gt;</span>
  lock <span class="token operator">=</span> false<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Se <code>lock</code> è <code>false</code> viene ritornato dalla funzione <code>false</code> ma viene comunque settato <code>lock</code> a <code>true</code>, il thread riesce quindi a superare il ciclo ed entra in sezione critica.<br>
Se <code>lock</code> è <code>true</code> viene ritornato dalla funzione <code>true</code> e il valore di <code>lock</code> rimane <code>true</code>, il thread rimane quindi in attesa nel ciclo while.</p>
<p>Questa soluzione prende il nome di <strong>spin-lock</strong></p>
<h2 id="xchg">XCHG</h2>
<p>Un’altra istruzione che ha la stessa funzionalità del <code>test_and_set</code> è l’istruzione (dell’architettura Intel) XCHG (pronunciata come “exchange”).</p>
<p>A differenza di <code>test_and_set</code>, l’istruzione XCHG scambia in modo atomico il contenuto di due variabili booleane, possiamo immaginare l’implementazione come segue:</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token function">XCHG</span><span class="token punctuation">(</span>boolean <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token operator">*</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    boolean tmp <span class="token operator">=</span> <span class="token operator">*</span>x<span class="token punctuation">;</span>
    <span class="token operator">*</span>x <span class="token operator">=</span> <span class="token operator">*</span>y<span class="token punctuation">;</span>
    <span class="token operator">*</span>y <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Possiamo immaginare una esecuzione mutualmente esclusiva nel seguente modo</p>
<pre class=" language-c"><code class="prism  language-c">global bool lock <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

thread T0 <span class="token punctuation">{</span>                              thread T1 <span class="token punctuation">{</span> 
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
  turno<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                                  turno<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>turno <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">XCHG</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> turno<span class="token punctuation">)</span><span class="token punctuation">}</span>         <span class="token keyword">while</span><span class="token punctuation">(</span>turno <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">XCHG</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> turno<span class="token punctuation">)</span><span class="token punctuation">}</span>    
  <span class="token operator">&lt;</span> sezione critica <span class="token operator">&gt;</span>                       <span class="token operator">&lt;</span> sezione critica <span class="token operator">&gt;</span>   
  <span class="token function">XCHG</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> turno<span class="token punctuation">)</span>                      	<span class="token function">XCHG</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> turno<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  
<span class="token punctuation">}</span>                                         <span class="token punctuation">}</span>
</code></pre>
<h1 id="thread-in-posix">Thread in POSIX</h1>
<p>Vediamo come utilizzare i thread su un sistema UNIX, utilizzando lo standard POSIX.</p>
<p>Elenchiamo le principali funzioni che la libreria mette a disposizione:</p>
<ul>
<li>
<p><code>pthread_create(pthread_t *thread, pthread_attr_t *attr, void *(*start_routine)(void *), void *arg)</code><br>
Serve per creare un nuovo thread e prende i seguente 4 argomenti:</p>
<ul>
<li><code>thread</code> è un puntatore ad una variabile di tipo <code>pthread_t</code> che è il corrispettivo di <code>pid_t</code>, cioè un identificativo del thread</li>
<li><code>attr</code> attributi del nuovo thread per abilitare comportamenti specifici, nella maggior parte dei casi non servono ed è sufficiente passare NULL</li>
<li><code>start_routine</code>: è il nome della funzione da far eseguire al thread, in C il nome di una funzione è un puntatore al suo codice.<br>
Quella sintassi <code>void *(*start_routine)(void *)</code> indica che si deve passare un indirizzo di funzione che ritorna un puntatore a void e prende in input un puntatore a void</li>
<li><code>arg</code>: argomenti da passare alla funzione che assegnata al thread, NULL se non sono necessari parametri</li>
</ul>
</li>
<li>
<p><code>pthread_exit(void *retval)</code><br>
termina l’esecuzione del thread, verrà restituito al padre del thread un puntatore a void <code>retval</code></p>
</li>
<li>
<p><code>pthread_join(pthread_t th, void **thread_return)</code><br>
attende la terminazione di un thread specificato da <code>th</code>. Se la chiamata ha successo ritorna 0 e in <code>thread_return</code> sarà contenuto il valore generato dalla <code>pthread_exit</code> del thread</p>
</li>
<li>
<p><code>pthread_detach(pthread_t th)</code><br>
usato se non si vuole attendere la terminazione del thread, lo si mette in disparte e appena termina le sue risorse verranno rilasciate.<br>
Se viene fatta una <code>exit()</code> dal processo principale comunque un <em>thread detachato</em> verrà terminato all’istante</p>
</li>
<li>
<p><code>pthread_t pthread_self()</code><br>
ritorna l’ID del thread assegnato dalla libreria pthread. Nota che l’ID che il sistema operativo assegna al thread è diverso rispetto a quello ritornato da questa funzione</p>
</li>
</ul>
<h2 id="esempio-1">Esempio 1</h2>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/syscall.h&gt;</span>   </span><span class="token comment">/* For SYS_xxx definitions */</span>

<span class="token comment">// codice dei thread. Notare che e' una funzione che prende </span>
<span class="token comment">// un puntatore e ritorna un puntatore (a void)</span>
<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">codice_thread</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pthread_t tid<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ptid<span class="token punctuation">;</span>
    
    tid  <span class="token operator">=</span> <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// library tid</span>
    ptid <span class="token operator">=</span> <span class="token function">syscall</span><span class="token punctuation">(</span>SYS_gettid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// tid assegnato dal SO (funziona solo in Linux)</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sono il thread %lu (%i) del processo %i\n"</span><span class="token punctuation">,</span> tid<span class="token punctuation">,</span> ptid<span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pthread_t tid<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> err<span class="token punctuation">;</span>

    <span class="token comment">// crea i thread (ritorna 0 quando ha successo)</span>
    <span class="token comment">// - gli attributi sono quelli di default (il secondo parametro e' NULL)</span>
    <span class="token comment">// - codice_thread e' il nome della funzione da eseguire</span>
    <span class="token comment">// - non vegnono passati parametri (quarto parametro e' NULL)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> codice_thread<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errore create [%i]\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// attende i thread. Non si legge il valore di ritorno (secondo parametro NULL)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">=</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span>tid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errore join [%i]\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I thread hanno terminato l'esecuzione correttamente\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Compilazione ed esecuzione (nota la presenza dell’opzione <code>-pthread</code> per poter linkare la libreria dei thread di POSIX):</p>
<pre><code>$ gcc test1.c -pthread -o test1
$ ./test1
Sono il thread 140072330872576 (14335) del processo 13793
Sono il thread 140072322479872 (14336) del processo 13793
I thread hanno terminato l'esecuzione correttamente
</code></pre>
<h2 id="esempio-2">Esempio 2</h2>
<p>Relizziamo questo esercizio: passare a due thread un intero letto dalla linea di comando (rispettivamente <code>argv[1]</code> e <code>argv[2]</code>). I due thread calcolano il quadrato del numero intero e il thread principale, infine, stampa la somma dei due valori ottenuti.</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/syscall.h&gt;</span>   </span><span class="token comment">/* For SYS_xxx definitions */</span>

<span class="token keyword">void</span> <span class="token operator">*</span> <span class="token function">codice_thread</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
    <span class="token comment">// ottiene un puntatore a int passato dal main</span>
    <span class="token comment">// *num punta a num[i] dove i è il numero del thread</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>num <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span> 
    
    pthread_t tid  <span class="token operator">=</span> <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// library tid</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sono il thread %lu del processo %i e ho letto %i\n"</span><span class="token punctuation">,</span> tid<span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// calcola il quadrato di num[i] puntato da num e mette il risultato</span>
    <span class="token comment">// direttamente in num[i].</span>
    <span class="token comment">// In questo modo dopo le join il main può trovare il quadrato direttamente in num[i]</span>
    <span class="token operator">*</span>num <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>num<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pthread_t tid<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> err<span class="token punctuation">;</span>
    <span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// array per passaggio parametri</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage: %s num1 num2\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// crea i thread: passa i parametri ai thread copiando argv[i+i]</span>
    <span class="token comment">// in num[i] e facendo un cast a (void *) di &amp;num[i]. </span>
    <span class="token comment">// In questo modo ogni thread lavora su una variabile distinta</span>
    num<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    num<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// crea i thread passando come parametro (void *)&amp;num[i]</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token operator">=</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> codice_thread<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errore create [%i]\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// attende i thread. </span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">=</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span>tid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errore join [%i]\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// il risultato è direttamente in num[i]!</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I thread hanno terminato l'esecuzione correttamente: %d + %d = %d\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> num<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> num<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> num<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="semafori">Semafori</h1>
<p>Fino ad ora abbiamo visto un modo software e istruzioni speciali implementate in hardware per sincronizzare i thread, ma questi metodi presentano dei problemi alla base:</p>
<ul>
<li>Generano una attesa tramite di cicli che girano a vuoto, sprecando tempo di CPU</li>
<li>Le istruzioni hardware hanno una realizzazione complessa, soprattutto nelle architetture multi-core.</li>
</ul>
<p>Il sistema operativo ci fornisce delle soluzioni più semplici ed efficaci, uno dei questi metodi è l’utilizzo dei <strong>semafori</strong>.</p>
<h2 id="semafori-1">Semafori</h2>
<p>Un semaforo è un contatore intero con l’aggiunta di una coda di thread:</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">struct</span> semaphore <span class="token punctuation">{</span>
	<span class="token keyword">int</span> value<span class="token punctuation">;</span>
	thread <span class="token operator">*</span>queue<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<ul>
<li><code>value &gt; 0</code> indica che l’accesso alla sezione critica è consentito e il suo valore indica il <strong>numero di accessi disponibili</strong> prima di diventare non più accessibile</li>
<li><code>value &lt;= 0</code> indica che l’accesso alla sezione critica non è consentito e il suo valore indica <strong>quanti thread sono in attesa</strong> di accedere (tali thread saranno nella coda <code>queue</code>)</li>
</ul>
<p>Un esempio utile può essere quello di un parcheggio con, ad esempio, 10 posti auto (la risorsa desiderata dai thread, che saranno le macchine).<br>
Inizialmente il parcheggio sarà completamente vuoto, quindi <code>value = 10</code>,<br>
le prima macchine (i thread) possono entrare senza problemi fintanto che <code>value &gt; 0</code>, una volta raggiunto lo <code>0</code> le macchine si accodano e una volta che si libera un parcheggio la macchina arrivata per prima può entrare.</p>
<p>I semafori vengono incrementati e decrementati attraverso due funzioni speciali:</p>
<ul>
<li><code>P(S)</code> o <code>wait(S)</code> decrementa il valore del semaforo, se il semaforo era già rosso allora il thread si accoda</li>
<li><code>V(S)</code> o <code>post(S)</code> incrementa il valore del semaforo, se il semaforo era rosso viene sbloccato il primo thread in coda</li>
</ul>
<p>Possiamo immaginare l’implementazione delle due funzioni nel seguente modo:</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token function">P</span><span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  S<span class="token punctuation">.</span>valore<span class="token operator">--</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>valore <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token operator">&lt;</span> Metti il thread corrente in attesa su S<span class="token punctuation">.</span>queue <span class="token operator">&gt;</span>
<span class="token punctuation">}</span>

<span class="token function">V</span><span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  S<span class="token punctuation">.</span>valore<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>valore <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token operator">&lt;</span> Sblocca il primo thread in attesa su S<span class="token punctuation">.</span>queue <span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>All’interno del codice di un thread possiamo utilizzare il semaforo nel seguente modo:</p>
<pre class=" language-c"><code class="prism  language-c">Semaphore S <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>empty_queue<span class="token operator">&gt;</span><span class="token punctuation">}</span>	<span class="token comment">//solo un thread alla volta può accedere alla sez. critica</span>

thread T <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">P</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">&lt;</span> Sezione critica <span class="token operator">&gt;</span>
  <span class="token function">V</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Vediamo l’esecuzione di 3 thread che girano in parallelo su 3 <em>core</em> diversi<br>
<img src="https://i.ibb.co/CtWdz4b/image.png" alt="enter image description here"></p>
<p>dove i trattini indicano la normale esecuzione del thread, mentre li due linee continue rappresentano l’esecuzione in sezione critica.</p>
<h2 id="produttore-e-consumatore-1">Produttore e consumatore</h2>
<p>Vediamo l’implementazione del produttore e consumatore tramite l’uso di semafori.</p>
<p>Abbiamo necessariamente bisogno di 2 semafori in quanto:</p>
<ul>
<li>quando il buffer è pieno il produttore deve attendere</li>
<li>quando il buffer è vuoto il consumatore deve attendere</li>
</ul>
<p>Un semaforo conterà il numero di celle vuote, mentre l’altro conterà quante celle sono piene.</p>
<p>Assumiamo che la grandezza del buffer sia <code>10</code></p>
<pre class=" language-c"><code class="prism  language-c">Semaphore piene <span class="token operator">=</span> <span class="token number">0</span>
Semaphore vuote <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>	<span class="token comment">//inizialmente tutte le celle sono vuote</span>

Produttore <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">&lt;</span> produce d <span class="token operator">&gt;</span>
    <span class="token function">P</span><span class="token punctuation">(</span>vuote<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// richiede una cella vuota</span>
    buffer<span class="token punctuation">[</span>inserisci<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">;</span>
    inserisci <span class="token operator">=</span> <span class="token punctuation">(</span>inserisci<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>piene<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// rilascia una cella piena</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
Consumatore <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">P</span><span class="token punctuation">(</span>piene<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// richiede una cella piena</span>
    d <span class="token operator">=</span> buffer<span class="token punctuation">[</span>preleva<span class="token punctuation">]</span><span class="token punctuation">;</span>
    preleva <span class="token operator">=</span> <span class="token punctuation">(</span>preleva<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">:</span>
    <span class="token function">V</span><span class="token punctuation">(</span>vuote<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// rilascia una cella vuota</span>
    <span class="token operator">&lt;</span> consuma d <span class="token operator">&gt;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="tanti-produttori-e-consumatori">Tanti produttori e consumatori</h2>
<p>In caso avessimo più produttori e più consumatori potremmo avere delle interferenze dovute al buffer condiviso tra i thread: due consumatori potrebbero leggere dalla stessa cella, oppure due produttori potrebbero scrivere sulla stessa cella sovrascrivendo i dati.<br>
Anche l’incremento dell’indice <code>inserisci</code> potrebbe causare interferenze.</p>
<p>La soluzione è utilizzare un ulteriore semaforo per rendere mutualmente esclusivo l’aggiornamento delle variabili condivise:</p>
<pre class=" language-c"><code class="prism  language-c">Semaphore piene <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
Semaphore vuote <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span>
Semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

Produttore <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">&lt;</span> produce d <span class="token operator">&gt;</span>
    <span class="token function">P</span><span class="token punctuation">(</span>vuote<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// richiede una cella vuota</span>
    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// entra in sezione critica</span>
    buffer<span class="token punctuation">[</span>inserisci<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">;</span>
    inserisci <span class="token operator">=</span> <span class="token punctuation">(</span>inserisci<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// esce dalla sezione critica</span>
    <span class="token function">V</span><span class="token punctuation">(</span>piene<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// rilascia una cella piena</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token function">Consumatore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token punctuation">{</span>
    <span class="token function">P</span><span class="token punctuation">(</span>piene<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// richiede una cella piena</span>
    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// entra in sezione critica</span>
    d <span class="token operator">=</span> buffer<span class="token punctuation">[</span>preleva<span class="token punctuation">]</span><span class="token punctuation">;</span>
    preleva <span class="token operator">=</span> <span class="token punctuation">(</span>preleva<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">:</span>
    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// esce dalla sezione critica</span>
    <span class="token function">V</span><span class="token punctuation">(</span>vuote<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// rilascia una cella vuota</span>
    <span class="token operator">&lt;</span> consuma d <span class="token operator">&gt;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="semafori-in-posix">Semafori in POSIX</h2>
<p>Le varie funzioni per utilizzare i semafori dello standard POSIX sono definiti nella libreria <code>semephore.h</code>principalmente i seguenti:</p>
<ul>
<li><code>sem_t sem_name</code><br>
dichiara una variabile di tipo semaforo;</li>
<li><code>int sem_init(sem_t *sem, int pshared, unsigned int value)</code><br>
inizializza il semaforo  <code>sem</code>  al valore  <code>value</code>.<br>
la variabile  <code>pshared</code>  indica se il semaforo è condiviso tra thread (uguale a 0) o processi (diverso da 0), lo useremo quindi sempre con 0.</li>
<li><code>int sem_wait(sem_t *sem)</code><br>
esegue una P(sem);</li>
<li><code>int sem_post(sem_t *sem)</code><br>
esegue una V(sem);</li>
<li><code>int sem_getvalue(sem_t *sem, int *val)</code><br>
legge il valore del semaforo e lo copia in  <code>val</code>;</li>
<li><code>sem_destroy(sem_t *sem)</code><br>
elimina il semaforo. Da NON usare se ci sono processi in attesa sul semaforo (comportamento non specificato).</li>
</ul>
<h2 id="implementazione-completa-produttore-e-consumatore">Implementazione completa produttore e consumatore</h2>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token macro property">#<span class="token directive keyword">define</span> SIZE 10</span>

<span class="token keyword">int</span> buffer<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> inserisci <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> preleva <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

sem_t mutex<span class="token punctuation">;</span> <span class="token comment">// semaforo mutua esclusione</span>
sem_t vuote<span class="token punctuation">;</span>
sem_t piene<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">print_buffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> buffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">produttore</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	pthread_t tid <span class="token operator">=</span> <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">13</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span>
		<span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vuote<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">[</span>inserisci<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errore di sincronizzazione (produttore)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		buffer<span class="token punctuation">[</span>inserisci<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">;</span>
		inserisci <span class="token operator">=</span> <span class="token punctuation">(</span>inserisci <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> SIZE<span class="token punctuation">;</span>

		<span class="token comment">//stampe di debug</span>
		<span class="token comment">//printf("prodotto (thread %ld)\n", tid);</span>
		<span class="token comment">//print_buffer();</span>
		<span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>piene<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">consumatore</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	pthread_t tid <span class="token operator">=</span> <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">13</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">int</span> d<span class="token punctuation">;</span>
		<span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>piene<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">[</span>preleva<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errore di sincronizzazione (consumatore)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		d <span class="token operator">=</span> buffer<span class="token punctuation">[</span>preleva<span class="token punctuation">]</span><span class="token punctuation">;</span>
		buffer<span class="token punctuation">[</span>preleva<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		preleva <span class="token operator">=</span> <span class="token punctuation">(</span>preleva <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> SIZE<span class="token punctuation">;</span>

		<span class="token comment">//stampe di debug</span>
		<span class="token comment">//printf("consumato (thread %ld)\n", tid);</span>
		<span class="token comment">//print_buffer();</span>
		<span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vuote<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pthread_t tid_prod<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">//5 produttori</span>
    pthread_t tid_cons<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">//5 consumatori</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>
    <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>piene<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vuote<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>


	<span class="token comment">//inizializzazione dei valori del buffer a -1</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		buffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//lancio produttori e consumatori</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>err <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid_prod<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> produttore<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errore create [%i]\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>err <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid_cons<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> consumatore<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errore create [%i]\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>


    <span class="token comment">// attende i thread. Non si legge il valore di ritorno (secondo parametro NULL)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>err <span class="token operator">=</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span>tid_prod<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errore join [%i]\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>err <span class="token operator">=</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span>tid_cons<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errore join [%i]\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// destroy</span>
    <span class="token function">sem_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sem_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>piene<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sem_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vuote<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="programmazione-con-i-semafori">Programmazione con i semafori</h1>
<p>Vediamo, oltre al problema dei produttori e consumatori, altri classici problemi di sincronizzazione risolubili con i semafori:</p>
<ul>
<li>sincronizzazione molti a uno</li>
<li>lettori e scrittori</li>
<li>filosofi a cena</li>
</ul>
<h2 id="sincronizzazione-molti-a-uno">Sincronizzazione molti a uno</h2>
<p>Consideriamo una variante del problema produttori e consumatori in cui ci sono <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span></span></span></span></span> produttori e un solo consumatore.<br>
Ogni produttore avrà una propria coda in cui metterà i suoi dati.<br>
Il consumatore consumerà un dato alla volta a turno dalle code dei produttori</p>
<p>Possiamo vedere il problema graficamente nel seguente modo<br>
<img src="https://i.ibb.co/D4vsBD5/image.png" alt="enter image description here"></p>
<p>Partiamo da un pseudocodice di questo tipo</p>
<pre class=" language-c"><code class="prism  language-c">queue dato_produttore<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">//array di code</span>

<span class="token function">Produttore</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token operator">&lt;</span> produce d <span class="token operator">&gt;</span>
		
		dato_produttore<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token function">Consumatore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dato_produttore<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token operator">&lt;</span> consuma d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> d<span class="token punctuation">[</span>N<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Per poter sincronizzarli abbiamo bisogno di:</p>
<ul>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span></span></span></span></span> semafori di celle piene (uno per ogni coda)</li>
<li><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span></span></span></span></span> semafori di celle vuote (uno per ogni coda)</li>
<li>un mutex (per la versione meno efficiente) oppure <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span></span></span></span></span> mutex (per la versione più efficiente)</li>
</ul>
<pre class=" language-c"><code class="prism  language-c">queue dato_produttore<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> 
semaphore vuote<span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>MAX<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> MAX<span class="token punctuation">}</span><span class="token punctuation">;</span> 
semaphore piene<span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
semaphore mutex<span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">Produttore</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">&lt;</span> produce d <span class="token operator">&gt;</span>

    <span class="token function">P</span><span class="token punctuation">(</span>vuote<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dato_produttore<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>piene<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">Consumatore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">P</span><span class="token punctuation">(</span>piene<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dato_produttore<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">V</span><span class="token punctuation">(</span>vuote<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token operator">&lt;</span> consuma d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> d<span class="token punctuation">[</span>N<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>L’ottimizzazione del mutex è la seguente:<br>
utilizzando un solo mutex si è più sicuri della sincronizzazione in quanto avviene sempre o una scrittura o una lettura e mai insieme.<br>
Sfruttando però il fatto che i produttori scrivono sulla propria coda, l’unica interferenza è che il produttore scriva sulla propria coda e il consumatore legga da quella stessa coda contemporaneamente, quindi possiamo usare un mutex per ogni coda in modo da sincronizzarle singolarmente, così facendo le scritture su code diverse avverranno parallelamente.</p>
<h2 id="lettori-e-scrittori">Lettori e scrittori</h2>
<p>Abbiamo dei dati in memoria condivisa.<br>
Abbiamo alcuni thread che accedono a questa memoria in sola lettura (thread chiamati <strong>lettori</strong>) e dei thread che modificano i dati in questa memoria (thread chiamati <strong>scrittori</strong>)</p>
<p>Quello che vogliamo sincronizzare è che se uno scrittore sta modificando i dati non ci deve essere nessun lettore che sta leggendo e nessun altro scrittore che sta scrivendo.<br>
È invece possibile avere più lettori contemporaneamente in lettura.</p>
<p>In sostanza vogliamo <strong>un solo scrittore oppure più lettori</strong></p>
<p>Esistono più soluzioni, alcune più ottimizzate di altre. Quella che vedremo sarà la più semplice, che rispetta la proprietà ma che potrebbe soffrire di <em>starvation</em>.</p>
<p>Il codice dello scrittore è una classica sincronizzazione di una sezione critica dove ci accede solo un thread alla volta.</p>
<p>Codice <strong>scrittore</strong>:</p>
<pre class=" language-c"><code class="prism  language-c">semaphore scrittura<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token function">Scrittore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">P</span><span class="token punctuation">(</span>scrittura<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token operator">&lt;</span> modifica i dati <span class="token operator">&gt;</span>

    <span class="token function">V</span><span class="token punctuation">(</span>scrittura<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Per implementare i lettori è utile utilizzare un contatore per tenere traccia di quanti lettori stanno leggendo:<br>
se non è presente alcun scrittore in zona critica allora:</p>
<ul>
<li>il primo lettore che arriva deve impedire l’entrata di uno scrittore</li>
<li>l’ultimo lettore ad uscire deve sbloccare lo scrittore</li>
<li>tutti i lettori nel mezzo possono passare liberamente</li>
</ul>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">int</span> num_lettori <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token function">Lettore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// protegge l'aggiornamento di num_lettori e accoda i lettori</span>
    num_lettori<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>num_lettori <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">// se è il primo lettore</span>
      <span class="token function">P</span><span class="token punctuation">(</span>scrittura<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// blocca lo scrittore</span>
    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token operator">&lt;</span> legge i dati <span class="token operator">&gt;</span>

    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// protegge l'aggiornamento di num_lettori</span>
    num_lettori<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>num_lettori <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">// se è l'ultimo lettore </span>
      <span class="token function">V</span><span class="token punctuation">(</span>scrittura<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// sblocca lo scrittore</span>
    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Il mutex è necessario per due ragioni:</p>
<ol>
<li>l’aggiornamento della variabile <code>num_lettori</code> è una <em>race condition</em></li>
<li>il primo lettore che arriva si bloccherà su <code>P(scrittura)</code> se c’è uno scrittore attivo, così facendo tutti gli altri lettori rimarranno in attesa su <code>P(mutex)</code>. Solo quando lo scrittore avrà finito allora il lettore eseguirà <code>V(mutex)</code> e lascerà passare tutti gli altri lettori (e se stesso). Vale lo stesso per il decremento finale</li>
</ol>
<p>Problema della <em><strong>starvation</strong></em>: se i lettori continuano ad arrivare, non si sbloccherà più il semaforo della scrittura e lo scrittore potrebbe rimanere in una attesa potenzialmente infinita.<br>
Alcune soluzioni più complesse implementano il fatto che se lo scrittore vuole scrivere allora mette in attesa tutti i nuovi lettori in arrivo e attende che tutti i lettori già entrati in sezione critica finiscano.</p>
<h2 id="filosofi-a-cena">Filosofi a cena</h2>
<p>Ci sono 5 filosofi seduti su un tavolo rotondo, ognuno ha davanti a sé un piatto, e tra ogni piatto ci sono 2 bacchette condivise tra i filosofi che sono adiacenti.<br>
Ogni filosofo ha bisogno di due bacchette per mangiare e quindi non è possibile che due filosofi vicini possano mangiare contemporaneamente.</p>
<p><img src="https://i.ibb.co/PDz9c5C/image.png" alt="enter image description here"></p>
<p>Schematizziamo il codice di un filosofo nel seguente modo:</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token function">Filosofo</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">&lt;</span> pensa <span class="token operator">&gt;</span>

    <span class="token operator">&lt;</span> raccoglie le bacchette sx e dx <span class="token operator">&gt;</span> 
    <span class="token operator">&lt;</span> mangia <span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span> deposita le bacchette sx e dx <span class="token operator">&gt;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Ogni bacchetta è una risorsa condivisa tra due specifici filosofi, non possiamo quindi utilizzare un unico semaforo inizializzato a 5 in quanto significherebbe ai filosofi andrebbero bene due qualsiasi bacchette.</p>
<p>Utilizziamo un array di 5 semafori inizializzati a 1.</p>
<p>Nota anche che l’<code>i</code>-esimo filosofo utilizza la bacchetta con indice <code>i</code> e quella con indice <code>i+1</code> (ovviamente con modulo 5 in quanto il quinto filosofo utilizzerà la bacchetta <code>0</code>)</p>
<pre class=" language-c"><code class="prism  language-c">semaphore bacchette<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">Filosofo</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">&lt;</span> pensa <span class="token operator">&gt;</span>

    <span class="token function">P</span><span class="token punctuation">(</span>bacchette<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">P</span><span class="token punctuation">(</span>bacchette<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&lt;</span> mangia <span class="token operator">&gt;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>bacchette<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>bacchette<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Il codice <strong>sembra</strong> corretto, però può andare in <strong>stallo</strong> (deadlock).<br>
Uno stallo è uno stato del programma in cui si è permanentemente bloccati in quanto i thread si aspettano a vicenda. In questi casi l’unico modo di uscire dallo stallo è uccidere il processo.</p>
<p>In questo caso lo stallo si verifica nel caso in cui tutti i filosofi prendono la prima bacchetta contemporaneamente.</p>
<p>Per prevenire lo stallo in questo caso abbiamo varie soluzioni:</p>
<h3 id="quattro-filosofi-a-tavola">quattro filosofi a tavola</h3>
<p>Un primo approccio è quello di limitare il numero di filosofi che possono mangiare a 4. Così facendo ci sarà sempre almeno una bacchetta libera.<br>
Per implementare questo metodo facciamo uso di altro semaforo <code>posti</code> inizializzato a 4</p>
<pre class=" language-c"><code class="prism  language-c">semaphore bacchette<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
semaphore posti <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>

<span class="token function">Filosofo</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">&lt;</span> pensa <span class="token operator">&gt;</span>

    <span class="token function">P</span><span class="token punctuation">(</span>posti<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">P</span><span class="token punctuation">(</span>bacchette<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">P</span><span class="token punctuation">(</span>bacchette<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&lt;</span> mangia <span class="token operator">&gt;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>bacchette<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>bacchette<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>posti<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Se tutti e 5 vogliono prendere la bacchetta di sinistra, solo i primi 4 ci riusciranno mentre l’altro rimarrà in attesa su <code>P(posti)</code></p>
<h3 id="raccolta-atomica">raccolta atomica</h3>
<p>possiamo utilizzare un mutex in modo da permettere ad un filosofo alla volta di raccogliere le proprie bacchette</p>
<pre class=" language-c"><code class="prism  language-c">semaphore bacchette<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token function">Filosofo</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">&lt;</span> pensa <span class="token operator">&gt;</span>

    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">P</span><span class="token punctuation">(</span>bacchette<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">P</span><span class="token punctuation">(</span>bacchette<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&lt;</span> mangia <span class="token operator">&gt;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>bacchette<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>bacchette<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Questa soluzione non è ottimale in quanto sincronizza troppo: se un filosofo prende la prima bacchetta ma ha la seconda bacchetta occupata rimarrà in attesa bloccando anche gli altri filosofi che in realtà potrebbero mangiare.</p>
<h3 id="filosofo-mancino">Filosofo mancino</h3>
<p>Una terza opzione è quella forzare un filosofo a prendere prima la bacchetta di destra e poi quella di sinistra.<br>
Così facendo rompiamo l’attesa circolare (lo stallo) che si verificava inizialmente.</p>
<p>Supponiamo di mettere il quinto filosofo che prende prima quella di destra.</p>
<pre class=" language-c"><code class="prism  language-c">semaphore bacchette<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">Filosofo</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">&lt;</span> pensa <span class="token operator">&gt;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">P</span><span class="token punctuation">(</span>bacchette<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// destra</span>
      <span class="token function">P</span><span class="token punctuation">(</span>bacchette<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// sinistra</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">P</span><span class="token punctuation">(</span>bacchette<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// sinistra</span>
      <span class="token function">P</span><span class="token punctuation">(</span>bacchette<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// destra</span>
    <span class="token punctuation">}</span>

    <span class="token operator">&lt;</span> mangia <span class="token operator">&gt;</span>

    <span class="token comment">// rilascia le bacchette, non importa l'ordine in quanto la V non è bloccante</span>
    <span class="token function">V</span><span class="token punctuation">(</span>bacchette<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>bacchette<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="monitor">Monitor</h1>
<p>I monitor sono un <strong>costrutto linguistico</strong> (o un meccanismo di sincronizzazione) atto a risolvere due dei principali problemi che si presentano utilizzando i semafori:</p>
<ol>
<li>la sincronizzazione è gestita in modo decentralizzato dai singoli thread.</li>
<li>gestire multipli semafori in certe situazioni non è comodo, è comune la possibilità di creare stalli.</li>
</ol>
<p>I monitor possono essere ricondotti a degli oggetti (nel mondo della programmazione ad oggetti) che hanno dei dati (i campi) e delle procedure per accederci (i metodi).<br>
Possiamo anche immaginarli come semafori solamente con la coda, senza il contatore.</p>
<p>I monitor permettono di centralizzare tutta la sincronizzazione in un unico punto (il monitor) e facilità la mutua esclusione:</p>
<ol>
<li>le <strong>procedure</strong> del monitor vengono eseguite in <strong>mutua esclusione</strong></li>
<li>I monitor forniscono delle variabili speciali chiamate <em>condition</em> sulle quali sono possibili delle operazioni speciali:
<ul>
<li><strong>wait</strong>: il thread si mette in attesa e va in coda, il mutex viene rilasciato per permettere agli altri thread di entrare in zona critica</li>
<li><strong>signal</strong>: riattiva <strong>immediatamente</strong> il primo thread in attesa sulla coda, e il thread attuale va in attesa nella coda</li>
<li><strong>notify</strong>: notifica il primo thread in attesa che può continuare, quando la CPU gli assegnerà il suo turno potrà proseguire. Intanto l’attuale thread continua la sua normale esecuzione</li>
</ul>
</li>
</ol>
<p>La sottile differenza tra <strong>signal</strong> e <strong>notify</strong> può essere importante in determinati casi: con <strong>signal</strong> siamo sicuri che il thread in attesa verrà subito eseguito, mentre con la <strong>notify</strong> non possiamo darlo per certo, infatti altri thread potrebbero rubargli il posto possibilmente intaccando la correttezza del programma senza i giusti controlli.</p>
<p>La <strong>notify</strong> è quindi meno restrittiva in quanto lascia il compito allo scheduler di sbloccare i thread, mentre la <strong>signal</strong> forza un cambio di thread allo scheduler.</p>
<h2 id="produttore-e-consumatore-con-i-monitor">Produttore e consumatore con i monitor</h2>
<p>Definiamo una pseudo-classe Monitor come segue</p>
<pre class=" language-c"><code class="prism  language-c">Monitor mon <span class="token punctuation">{</span>
	<span class="token keyword">int</span> buffer<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>
	
	<span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	<span class="token comment">//conta il numero di celle piene, da consumare</span>
	<span class="token keyword">int</span> write_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> read_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

	condition piene<span class="token punctuation">;</span>
	condition vuote<span class="token punctuation">;</span>

	<span class="token keyword">void</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>counter <span class="token operator">==</span> MAX<span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">// se non ci sono celle libere</span>
			vuote<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		buffer<span class="token punctuation">[</span>write_index<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">;</span>
		write_index <span class="token operator">=</span> <span class="token punctuation">(</span>write_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX<span class="token punctuation">;</span>
		counter<span class="token operator">++</span><span class="token punctuation">;</span>
		piene<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">int</span> <span class="token function">consuma</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>couter <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>		<span class="token comment">// se non ci sono celle da leggere</span>
			piene<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		d <span class="token operator">=</span> buffer<span class="token punctuation">[</span>read_index<span class="token punctuation">]</span><span class="token punctuation">;</span>
		read_index <span class="token operator">=</span> <span class="token punctuation">(</span>read_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX<span class="token punctuation">;</span>
		counter<span class="token operator">--</span><span class="token punctuation">;</span>
		vuote<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> d<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Usiamo il monitor appena creato nel codice del Produttore e Consumatore:</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token function">Produttore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* produce un elemento d */</span>
    mon<span class="token punctuation">.</span><span class="token function">produce</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">Consumatore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    d <span class="token operator">=</span> mon<span class="token punctuation">.</span><span class="token function">consuma</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* consuma d */</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="signal-vs-notify">Signal vs notify</h3>
<p>È importante l’uso della <code>signal()</code> e non della <code>notify()</code> in quanto:<br>
immaginiamo un consumatore che lancia una <code>wait</code> perché non ci sono celle da leggere.<br>
Arriva un produttore che incrementa il <code>counter</code> e lancia una <code>signal</code>, questo fa si che il consumatore che era nella <code>wait</code> riparta immediatamente (correttamente, infatti il counter adesso vale 1, che lui riporterà a 0).</p>
<p>Se usassimo la <code>notify()</code> potremmo avere il seguente comportamento:<br>
immaginiamo un consumatore che lancia una <code>wait</code> perché non ci sono celle da leggere.<br>
Arriva un produttore che incrementa il <code>counter</code> e lancia una <code>notify</code>, questo comunica allo scheduler che può avviare il consumatore quando possibile. Se però un altro consumatore entra in esecuzione trova il counter a 1 e quindi esegue tranquillamente portando il counter di nuovo a 0. Poi lo scheduler fa ripartire il consumatore che era bloccato, ma adesso non c’è più un dato da leggere (il counter è a 0 e lui lo porterà erroneamente a -1)</p>
<h3 id="versione-corretta-con-notify">Versione corretta con notify</h3>
<p>Una corretta implementazione con la <code>notify</code> richiede le seguenti modifiche</p>
<pre class=" language-c"><code class="prism  language-c">Monitor mon <span class="token punctuation">{</span>
	<span class="token keyword">int</span> buffer<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>
	
	<span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> write_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> read_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

	condition piene<span class="token punctuation">;</span>
	condition vuote<span class="token punctuation">;</span>

	<span class="token keyword">void</span> <span class="token function">produce</span> <span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>counter <span class="token operator">==</span> MAX<span class="token punctuation">)</span> <span class="token punctuation">{</span>		<span class="token comment">//MODIFICA</span>
			vuote<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		buffer<span class="token punctuation">[</span>write_index<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">;</span>
		write_index <span class="token operator">=</span> <span class="token punctuation">(</span>write_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX<span class="token punctuation">;</span>
		counter<span class="token operator">++</span><span class="token punctuation">;</span>
		piene<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">//MODIFICA</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">int</span> <span class="token function">consuma</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>couter <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>			<span class="token comment">// MODIFICA</span>
			piene<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		d <span class="token operator">=</span> buffer<span class="token punctuation">[</span>read_index<span class="token punctuation">]</span><span class="token punctuation">;</span>
		read_index <span class="token operator">=</span> <span class="token punctuation">(</span>read_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX<span class="token punctuation">;</span>
		counter<span class="token operator">--</span><span class="token punctuation">;</span>
		vuote<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">//MODIFICA</span>
		<span class="token keyword">return</span> d<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Fare il controllo in un ciclo <code>while</code> permette di accertarsi che il counter sia effettivamente come richiesto prima di riprendere l’esecuzione.<br>
Nota che <strong>non</strong> si tratta di <em>busy waiting</em> in quanto la <code>wait</code> sospende il thread.</p>
<h2 id="filosofi-a-cena-con-i-monitor">Filosofi a cena con i monitor</h2>
<p>Vediamo come implementare i filosofi a cena con la soluzione della <strong>raccolta atomica di entrambe le bacchette</strong>, questa soluzione non era facile con i semafori in quanto dovremmo rilasciare il mutex nel caso una delle bacchette non fosse disponibile.<br>
Con i monitor risolviamo questo problema:</p>
<pre class=" language-c"><code class="prism  language-c">Monitor tavola <span class="token punctuation">{</span>
  boolean bacchetta<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>true<span class="token punctuation">,</span> true<span class="token punctuation">,</span> true<span class="token punctuation">,</span> true<span class="token punctuation">,</span> true<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// presenza bacchette</span>
  condition filosofo<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// code di attesa per i filosofi</span>

  <span class="token keyword">void</span> <span class="token function">raccogli</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>bacchetta<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token operator">!</span>bacchetta<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      filosofo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// attende se una delle bacchette non è disponibile</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// raccoglie le bacchette in modo atomico</span>
    bacchetta<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>
    bacchetta<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">deposita</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// deposita le bacchette</span>
    bacchetta<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>
    bacchetta<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>

    <span class="token comment">// notifica il filosofo a sx e quello a dx</span>
    filosofo<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    filosofo<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Utilizzo del monitor</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token function">Filosofo</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">&lt;</span> pensa <span class="token operator">&gt;</span>

    tavola<span class="token punctuation">.</span><span class="token function">raccogli</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token operator">&lt;</span> mangia <span class="token operator">&gt;</span>
    
    tavola<span class="token punctuation">.</span><span class="token function">deposita</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Vediamo come implementare i filosofi a cena con la soluzione di <strong>limitare a 4 i filosofi che possono mangiare contemporaneamente</strong>.<br>
Dobbiamo simulare un semaforo inizializzato a 4.</p>
<p>Aggiorniamo il Monitor con due procedure: <code>siediti</code> e <code>alzati</code></p>
<pre class=" language-c"><code class="prism  language-c">Monitor tavola <span class="token punctuation">{</span>
  boolean bacchetta<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>true<span class="token punctuation">,</span> true<span class="token punctuation">,</span> true<span class="token punctuation">,</span> true<span class="token punctuation">,</span> true<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// presenza bacchette</span>
  condition filosofo<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// code di attesa per i filosofi</span>

  <span class="token keyword">int</span> sedie <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
  condition sedia<span class="token punctuation">;</span>

  <span class="token keyword">void</span> <span class="token function">siediti</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	  <span class="token keyword">while</span><span class="token punctuation">(</span>sedie <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">//se non ci sono sedia disponibili ne attende una</span>
		  sedia<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	  <span class="token punctuation">}</span>
	  sedie<span class="token operator">--</span><span class="token punctuation">;</span>	<span class="token comment">//occupa una sedia</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">alzati</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	  sedie<span class="token operator">++</span><span class="token punctuation">;</span>	<span class="token comment">//libera la sedia</span>
	  sedia<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//notifica il primo filosofo in attesa della sedia</span>
  <span class="token punctuation">}</span>
 
  <span class="token keyword">void</span> <span class="token function">raccogli</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">deposita</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Questi due metodi che abbiamo aggiunto simulano il comportamento della <code>sem_post()</code> e <code>sem_wait()</code> dei semafori.</p>
<h2 id="lettori-e-scrittori-notifyall">Lettori e scrittori, <code>notifyAll</code></h2>
<p>Possiamo schematizzare il comportamento di lettori e scrittori nel seguente modo</p>
<p>(<code>rw</code> è il monitor)</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token function">Lettore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    rw<span class="token punctuation">.</span><span class="token function">ini_leggi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token operator">&lt;</span> legge i dati <span class="token operator">&gt;</span>

    rw<span class="token punctuation">.</span><span class="token function">end_leggi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">Scrittore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    rw<span class="token punctuation">.</span><span class="token function">ini_scrivi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token operator">&lt;</span> modifica i dati <span class="token operator">&gt;</span>

    rw<span class="token punctuation">.</span><span class="token function">end_scrivi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Lo scopo è sempre quello di garantire l’accesso o a più lettori o ad un solo scrittore.</p>
<p>Le informazioni di cui abbiamo bisogno sono:</p>
<ul>
<li>Il numero di lettori all’interno della sezione critica</li>
<li>Se uno scrittore è all’interno della zona critica</li>
</ul>
<pre class=" language-c"><code class="prism  language-c">Monitor rw <span class="token punctuation">{</span>
  <span class="token keyword">int</span> n_lettori <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// n. lettori in sezione critica</span>
  boolean scrittore <span class="token operator">=</span> false<span class="token punctuation">;</span> <span class="token comment">// scrittore in sezione critica</span>
  condition c<span class="token punctuation">;</span> <span class="token comment">// coda di attesa</span>

  <span class="token keyword">void</span> <span class="token function">ini_leggi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>scrittore<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      c<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// attende se c'è uno scrittore</span>
    <span class="token punctuation">}</span>
    n_lettori<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// il lettore entra</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">end_leggi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    n_lettori<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// il lettore esce</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n_lettori <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      c<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// l'ultimo lettore sblocca eventuali scrittori in attesa</span>
	<span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">ini_scrivi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>scrittore <span class="token operator">||</span> n_lettori <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      c<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// attende se c'è uno scrittore o dei lettori</span>
    <span class="token punctuation">}</span>
    scrittore <span class="token operator">=</span> true<span class="token punctuation">;</span> <span class="token comment">// lo scrittore entra</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">end_scrivi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    scrittore <span class="token operator">=</span> false<span class="token punctuation">;</span> <span class="token comment">// lo scrittore esce</span>
    c<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lo scrittore sblocca tutti i thread in attesa</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>in <code>end_scrivi</code> abbiamo per la prima volta una <code>notifyAll()</code>, questa funzione permette di sbloccare tutti i thread che sono in una <code>wait</code>.<br>
In questo contesto specifico viene fatto perchè se il primo ad entrare è un altro scrittore allora non ci sarebbero problemi: infatti tutti i lettori si riboccherebbero.<br>
Se invece entra un lettore allora anche i successivi lettori possono entrare. Se in quest’ultima situazione avessimo semplicemente usato <code>notify</code> il primo lettore potrebbe entrare ma gli altri sono ancora bloccati dalla <code>wait</code>, c’è quindi il bisogno di sbloccare indistintamente tutti.</p>
<p>Sarà lo <em>scheduler</em> a decidere il prossimo thread da far eseguire.</p>
<h1 id="thread-in-java">Thread in Java</h1>
<p>Vediamo i due modi principali di creare ed usare thread in Java</p>
<h2 id="estendendo-la-classe-thread">Estendendo la classe Thread</h2>
<p>Il primo modo è quello di definire una propria classe che estende la classe <code>Thread</code> della JDK.<br>
All’interno della nostra classe va sovrascritto il metodo <code>run()</code> che conterrà il codice che eseguirà il thread</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CreaThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Saluti dal thread "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        CreaThread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreaThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//crea il thread</span>
        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//fa partire il thread</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Alternativamente è possibile creare un thread usando il costruttore di <code>Thread</code> che prende in input un oggetto che implementa <code>Runnable</code>, tramite classe anonima, lambda oppure esplicitamente istanziando la nuova classe che implementa <code>Runnable</code> e passarla al costruttore di <code>Thread</code><br>
<a href="https://gabritorre.github.io/uni/year2/prog_ogg2/web_notes/Thread.html">Appunti Programmazione ad oggetti 2 (Thread)</a></p>
<h2 id="creazione-interruzione-e-attesa">Creazione, Interruzione e attesa</h2>
<p>Vediamo un programma in cui creiamo dei thread, li facciamo “dormire” tramite una <code>sleep()</code>, li svegliamo tramite un <code>interrupt()</code>e attendiamo la loro terminazione con <code>join()</code></p>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CreaTantiThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NTHREAD <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>     <span class="token comment">// numero di thread da creare</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> index<span class="token punctuation">;</span>                <span class="token comment">// indice del thread appena creato</span>

    <span class="token comment">// costruttore: memorizza l'indice del thread </span>
    <span class="token function">CreaTantiThread</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        index <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// codice da eseguire allo startup del thread </span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// NOTA: se l'interruzione arriva prima della sleep viene bufferizzata!</span>
            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// dorme per 2 secondi</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>InterruptedException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"["</span><span class="token operator">+</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"]"</span><span class="token operator">+</span><span class="token string">" Ah mi hanno interrotto!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>
        
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Saluti dal thread "</span> <span class="token operator">+</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* main: crea i NTHREAD thread ne interrompe alcuni e attende la
       terminazione.
       NOTA: con join devo gestire InterruptedException,
       ma nessuno interrompera' mai le join di questo main quindi la 
       ignoriamo */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
        <span class="token keyword">int</span> i<span class="token punctuation">;</span>
        Thread t<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">[</span>NTHREAD<span class="token punctuation">]</span><span class="token punctuation">;</span>
        
        <span class="token comment">// crea 5 thread e li esegue</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NTHREAD<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreaTantiThread</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token comment">// interrompe il terzo thread</span>
        t<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// attende la terminazione dei thread</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NTHREAD<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Saluti dal thread "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="monitor-1">Monitor</h2>
<p>Java implementa una versione semplificata dei monitor:</p>
<ul>
<li>Ogni oggetto ha un mutex implicito utilizzato per garantire la mutua esclusione</li>
<li>I metodi sono eseguiti in mutua esclusione solo se vengono dichiarati <code>synchronized</code></li>
<li>Ogni oggetto è dotato di una unica <code>condition</code> sulla quale sono definiti 3 metodi: <code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code></li>
<li>se il metodo è statico allora il mutex è a livello di classe e non di oggetto</li>
<li>è possibile sincronizzare singole porzioni di codice definendole all’interno di un blocco <code>synchronized</code><pre class=" language-java"><code class="prism  language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//codice sincronizzato</span>
<span class="token punctuation">}</span>
</code></pre>
dove “mutex” è un qualsiasi <code>Object</code> utilizzato per fare il <strong>lock</strong> del blocco di codice.</li>
</ul>
<h2 id="esempio">Esempio</h2>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Interferenze</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX<span class="token operator">=</span><span class="token number">1000000</span><span class="token punctuation">;</span>           <span class="token comment">// iterazioni massime</span>
    Contatore c<span class="token punctuation">;</span>                            <span class="token comment">// Monitor passato dal main</span>

    <span class="token comment">// costruttore, memorizza il monitor nel campo c</span>
    <span class="token function">Interferenze</span><span class="token punctuation">(</span>Contatore cont<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        c <span class="token operator">=</span> cont<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//   i thread incrementano MAX volte il contatore</span>
    <span class="token comment">//   NOTA: non possono fare c.count++ perché è privato! </span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> i<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            c<span class="token punctuation">.</span><span class="token function">incrementa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// questo metodo è in MUTEX perché synchronized</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//   il main crea i thread, attende la terminazione e stampa il contatore </span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
        Thread t<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        Contatore cont <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Contatore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// crea un singolo monitor</span>
        
        <span class="token comment">// crea i 2 thread e li esegue</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            t<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Interferenze</span><span class="token punctuation">(</span>cont<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// passa il monitor ai thread</span>
            t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// attende la terminazione</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	        t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        <span class="token comment">// stampa il contatore, il valore atteso ed esce</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"FINITO "</span> <span class="token operator">+</span> cont<span class="token punctuation">.</span><span class="token function">valore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" mi aspettavo "</span> <span class="token operator">+</span> MAX<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token comment">/*  questa classe implementa un Monitor in cui e' possibile incrementare il valore 
 *  di un contatore da diversi thread in mutua esclusione.
 *  provare a togliere il 'synchronized' dal metodo incrementa per osservare 
 *  le interferenze */</span>
<span class="token keyword">class</span> <span class="token class-name">Contatore</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// privato: no accessi diretti</span>

    <span class="token comment">// il metodo synchronized garantisce mutua esclusione sullo stesso oggetto</span>
    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">incrementa</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* non serve sincronizzarlo visto che lo usiamo alla fine dal main: gli altri
    thread sono già terminati (la join garantisce che il main e' l'unico 
     thread in esecuzione)
     inoltre la lettura non crea mai interferenze
     */</span>
    <span class="token keyword">int</span> <span class="token function">valore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="deadlock">Deadlock</h1>
<p>Nel tentativo di sincronizzare processi o thread ci si può imbattere in degli stalli o <strong>deadlock</strong> cioè delle situazioni in cui dei thread rimangono in attesa reciproca gli uni degli altri, non riuscendo mai a sbloccarsi perché colui che dovrebbe causare l’evento di sblocco è in attesa (si forma quindi una <strong>attesa circolare</strong>).</p>
<p>Più formalmente possiamo dire che:<br>
Un insieme <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.05764em;">S</span></span></span></span></span> di processi o thread è in stallo se ogni <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span></span> in <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.05764em;">S</span></span></span></span></span> attende un evento che può essere causato solo da processi o thread appartenenti ad <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.05764em;">S</span></span></span></span></span>.</p>
<h2 id="condizioni-per-generare-uno-stallo">Condizioni per generare uno stallo</h2>
<p>Uno stallo può avvenire sotto il verificarsi di tutte le seguenti condizioni:</p>
<ul>
<li><strong>Mutua esclusione</strong><br>
In assenza di mutua esclusione: se una risorsa può essere utilizzata senza problemi contemporaneamente da più processi o thread non è necessario attendere e quindi non si forma una situazione di stallo. Ad esempio la lettura simultanea di dati condivisi.</li>
<li><strong>Possesso e attesa</strong><br>
Se i processi o thread non allocano mai le risorse in modo incrementale, cioè acquisendo una risorsa (possesso) e poi chiedendone altre in seguito (attesa). Se ciò non si verifica allora non può succedere che si formi un attesa circolare (e quindi uno stallo).</li>
<li><strong>Assenza di preemption</strong><br>
Se il sistema può far rilasciare in modo forzato le risorse a thread o processi, allora è possibile risolvere situazioni di stallo tramite preemption.</li>
<li><strong>Attesa circolare</strong><br>
Per definizione, lo stallo avviene quando c’è una attesa circolare che fa sì che nessun processo o thread uscirà mai dallo stato di attesa.</li>
</ul>
<h2 id="gestire-le-situazioni-di-stallo">Gestire le situazioni di stallo</h2>
<p>Lo stallo può essere gestito in vari modi a seconda di se e quando si evidenziano (potenziali) situazioni si attesa circolare.</p>
<ul>
<li><strong>Prevenzione</strong>: vengono messe in atto alcune strategie che prevengono la formazione di stalli</li>
<li><strong>Controllo</strong>: l’assegnamento delle risorse è consentito solo nel caso in cui il sistema possa garantire che tale assegnamento non porterà a una situazione di stallo;</li>
<li><strong>Riconoscimento</strong>: il sistema individua situazioni di stallo e cerca di ripristinare uno stato precedente senza stallo;</li>
<li><strong>Nessuna azione</strong>: il sistema ignora lo stallo e lascia ai programmatori l’onere di evitarlo o gestirlo.</li>
</ul>
<h2 id="prevenzione">Prevenzione</h2>
<p>Analizziamo il caso di prevenzione dello stallo, per prevenire uno stallo dobbiamo negare almeno una delle condizioni necessaria di prima:</p>
<h3 id="negare-la-mutua-esclusione">Negare la mutua esclusione</h3>
<p>Il fatto che l’accesso a una risorsa sia in mutua esclusione dipende dalla risorsa stessa e dal tipo di accesso, quando è necessaria non possiamo evitarla per prevenire lo stallo, ne risentirebbe la correttezza del programma.</p>
<h3 id="evitare-il-possesso-e-attesa">Evitare il possesso e attesa</h3>
<p>Possiamo evitare possesso e attesa allocando tutte le risorse assieme (vedi la raccolta atomica nei filosofi a cena). Questo non è però sempre possibile perché non è detto che si conoscano tutte le risorse necessarie a un thread o processo a priori.<br>
Inoltre allocare tutte le risorse all’inizio può essere <strong>inefficiente</strong> in quanto priva gli altri thread o processi di tali risorse.<br>
Questa soluzione può anche provocare <strong>starvation</strong>.</p>
<h3 id="preemption">Preemption</h3>
<p>La preemption, come la mutua esclusione, dipende dal tipo di risorsa. Ci sono risorse per loro natura sono preemptable e altre no. Tipicamente, se la risorsa può salvare completamente il proprio stato e ripristinarlo può essere preemptable come la CPU.<br>
Non possiamo quindi imporre la preemption a priori.</p>
<h3 id="prevenire-lattesa-circolare">Prevenire l’attesa circolare</h3>
<p>È possibile evitare l’attesa circolare con opportune strategie di allocazione delle risorse.<br>
Ne è un esempio la soluzione dei filosofi a cena con un filosofo mancino</p>
<h2 id="controllo">Controllo</h2>
<p>Analizziamo il caso di controllo a <em>run-time</em> dello stallo.<br>
Per poter controllare ed evitare la formazione degli stalli a run-time l’idea è di consentire l’assegnamento delle risorse solo nel caso in cui il sistema possa garantire che tale assegnamento non porterà a una situazione di stallo.</p>
<h2 id="grafo-di-assegnazione">Grafo di assegnazione</h2>
<p>Per svolgere il controllo è necessario memorizzare lo <strong>stato di una risorsa</strong>, cioè se è assegnata o libera, e la presenza di <strong>richieste</strong> da parte dei thread (o processi).<br>
Il <strong>grafo di assegnazione</strong> mantiene queste informazioni</p>
<ul>
<li>arco da P a R: il processo richiede la risorsa</li>
<li>arco da R a P: la risorsa è assegnata al processo</li>
<li>arco tratteggiato da P a R: il processo potrà richiedere in futuro la risorsa</li>
</ul>
<p>Una risorsa può avere più istanze di se stessa così da poter soddisfare più processi contemporaneamente.</p>
<p>Vediamo un esempio grafico<br>
<img src="https://i.ibb.co/1rzKJz7/image.png" alt="enter image description here"></p>
<p>Descrizione:</p>
<ul>
<li>P1 richiede la risorsa R1</li>
<li>R2 è assegnata a P1</li>
<li>R1 è assegnata a P2 e P3</li>
<li>P3 richiede la risorsa R2</li>
<li>P2 potrebbe richiedere la risorsa R2 in futuro</li>
</ul>
<h3 id="grafo-sicuro">Grafo sicuro</h3>
<p>Un grafo di assegnazione è detto <strong>sicuro</strong> se è privo di stalli anche considerando le richieste future.<br>
Per determinare se in un grafo esiste una situazione di stallo bisogna controllare le seguenti condizioni:</p>
<ul>
<li>ogni risorsa ha <strong>una sola istanza</strong>: <strong>se il grafo ha un ciclo allora esiste uno stallo</strong>.</li>
<li>le risorse hanno <strong>più istanze</strong>: <strong>la presenza dello stallo implica la presenza di un ciclo</strong>, ma la presenza di un ciclo non basta per dire se ci può essere uno stallo o meno. Bisogna usare un particolare algoritmo</li>
</ul>
<h2 id="algoritmo-con-grafo-di-assegnazione">Algoritmo con grafo di assegnazione</h2>
<p>Analizziamo prima il caso con risorse a istanza singola: basta verificare la presenza di un ciclo</p>
<p>Per ogni richiesta, se la risorsa non è disponibile il processo va in attesa, altrimenti:</p>
<ol>
<li>simula sul grafo, l’assegnamento della risorsa al processo</li>
<li>verifica la presenza di cicli, considerando anche le richieste future:
<ul>
<li>se viene trovato un ciclo: il processo viene messo in attesa</li>
<li>altrimenti: la risorsa viene assegnata</li>
</ul>
</li>
</ol>
<p>Esempio con i filosofi a cena:<br>
<img src="https://i.ibb.co/cL6pf7q/image.png" alt="enter image description here"></p>
<p>Immaginiamo di trovarci nella situazione sopra descritta, in cui i primi 4 filosofi hanno preso la bacchetta di sinistra e l’ultimo filosofo <code>F4</code> vorrebbe la sua bacchetta sinistra, in quanto quell’assegnamento creerebbe un ciclo l’assegnazione non viene fatta e il filosofo viene messo in attesa.</p>
<h2 id="algoritmo-del-banchiere">Algoritmo del banchiere</h2>
<p>Analizziamo ora il caso in cui le risorse hanno più istanze, in questo caso verificare la presenza di un ciclo non basta, ne è un esempio il seguente grafo, che, pur avendo un ciclo non ha uno stallo (si tratta quindi di un <strong>grafo sicuro</strong>)</p>
<p><img src="https://i.ibb.co/h9TJkXZ/image.png" alt="enter image description here"></p>
<p>In questo caso un possibile ordine di terminazione dei processi è &lt;P2, P0, P1&gt;, tale sequenza viene detta <strong>sicura</strong>.</p>
<p>In generale una sequenza di terminazione di processi è detta <strong>sicura</strong> se ogni processo della sequenza può ottenere tutte le risorse che necessita tra quelle disponibili inizialmente e quelle possedute dai processi che lo precedono (cioè quelli che terminano prima di lui)</p>
<p>Quindi la sequenza deve garantire che ogni processo abbia le risorse che necessita per poi rilasciarle ai processi successivi.</p>
<p>Per verificare se esiste una sequenza sicura si utilizza il seguente algoritmo:</p>
<ol>
<li>Cerca un processo che possa ottenere tutte le risorse necessarie (incluse quelle future) da quelle disponibili. Se tale processo non c’è allora non esiste una sequenza sicura</li>
<li>Rilascia tutte le risorse possedute dal processo, aggiungilo alla sequenza sicura e toglilo dal grafo</li>
<li>Se ci sono ancora processi nel grafo ripeti il punto 1, altrimenti dai in output la sequenza sicura</li>
</ol>
<p><strong>L’algoritmo del banchiere</strong> utilizza la non esistenza di una sequenza sicura per individuare potenziali stalli:</p>
<p>Per ogni richiesta, se la risorsa non è disponibile il processo attende, altrimenti:</p>
<ol>
<li>simula sul grafo l’assegnamento della risorsa al processo</li>
<li>verifica se il grafo contiene uno stallo, verificando che non esista una sequenza sicura
<ul>
<li>in caso di stallo il processo viene messo in attesa</li>
<li>altrimenti: la risorsa viene assegnata e la modifica sul grafo viene confermata</li>
</ul>
</li>
</ol>
<h3 id="esempio-3">Esempio</h3>
<p>Partiamo da una situazione di questo tipo, con 3 processi e 2 risorse.</p>
<p>Una istanza di R1 viene assegnata a P2.<br>
Le future richieste sono segnate tramite archi tratteggiati (non sappiamo a prescindere l’ordine delle richieste)</p>
<p><img src="https://i.ibb.co/XzS7TPZ/image.png" alt="enter image description here"></p>
<p>Se lasciamo l’assegnamento incontrollato potrebbe verificarsi uno stallo.<br>
Simuliamo invece l’algoritmo del banchiere.</p>
<p>P1 richiede R1, simuliamo l’assegnamento sul grafo: dobbiamo verificare che esista una sequenza sicura e &lt;P1, P2, P3&gt; lo è in quanto: P1 può ottenere R2, rilasciando le proprie risorse permette a P2 di ottenere R2, che a sua volta può rilasciare le risorse permettendo a P3 di ottenere R1 e R2.</p>
<p>aggiorniamo il grafo<br>
<img src="https://i.ibb.co/zJPp1sT/image.png" alt="enter image description here"></p>
<p>P3 richiede R2, simuliamo l’assegnamento sul grafo: dobbiamo verificare che esista una sequenza sicura ma in questo caso non esiste in quanto nessuno dei tre processi può ottenere tutte le risorse necessarie.<br>
L’algoritmo mette P3 in attesa</p>
<p>aggiorniamo il grafo</p>
<p><img src="https://i.ibb.co/Y2DLCMm/image.png" alt="enter image description here"></p>
<p>P1 richiede R2, simuliamo l’assegnamento sul grafo: dobbiamo verificare che esista una sequenza sicura e &lt;P1, P2, P3&gt; lo è.<br>
aggiorniamo quindi il grafo.</p>
<p>successivamente</p>
<p>P2 richiede R2, simuliamo l’assegnamento sul grafo: dobbiamo verificare che esista una sequenza sicura e &lt;P1, P2, P3&gt; lo è.<br>
aggiorniamo quindi il grafo e otteniamo il seguente risultato</p>
<p><img src="https://i.ibb.co/71YJgjr/image.png" alt="enter image description here"></p>

    </div>
  </div>
</body>

</html>
