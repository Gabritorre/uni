# Alberi

In questo capitolo studieremo gli **alberi radicati**.
Un albero radicato una struttura dati definita come $T=(N, A)$ dove 

- $N$ è un insieme finito di **nodi**, in cui è presente un particolare nodo chiamato **radice**
- $A$ è un insieme di coppie ordinate di nodi chiamate **archi** (ordinate, nel senso che **l'arco ha un verso**)


## Caratteristiche e definizioni

### Figli di un nodo
- In un albero ogni **nodo** (tranne la radice) **possiede esattamente un padre**
- un nodo può avere zero o più figli
- il numero di figli è detto **grado del nodo**
- **foglia**: nodo senza figli (nodo di grado 0)
- **nodo interno**: nodo che ha almeno un figlio
- **nodi fratelli**: nodi che hanno lo stesso padre

### Cammini

Un **cammino** è una sequenza di nodi collegati da un arco che vanno da un nodo $u$ ad un nodo $u'$

la **lunghezza** di un cammino è il numero di archi di quel cammino.
Esiste sempre un cammino di lunghezza zero (cioè che va da un nodo al nodo stesso)

Gli **antenati** di un nodo sono tutti i nodi compresi nel cammino che va dalla radice al nodo stesso (compreso). Possiamo pensare che gli antenati di un figlio sono: padre, nonno, bisnonno, ecc...

I **discendenti** di un nodo sono tutte le "generazioni" figlie di quel nodo

**Ogni nodo è antenato e discendente di se stesso**

**profondità** di un nodo $x$ è il numero di archi dalla radice al nodo stesso

Un **livello** di un albero è l'insieme di tutti i nodi che stanno alla stessa profondità

L'**altezza** di un nodo è il numero di archi presenti dal nodo fino ad andare alla foglia più lontana
- l'altezza di un albero è l'altezza del nodo radice

## Rappresentazione grafica

![enter image description here](https://i.ibb.co/VBXGZ7w/albero.png)


## Alberi binari e k-ari

Un albero k-ario è un albero in cui ogni nodo ha al massimo $k$ figli

Un albero binario è un albero k-ario in cui $k = 2$ quindi in cui **ogni nodo ha al massimo 2 figli**
Quindi abbiamo una radice e due **sottoalberi** uno destro e uno sinistro

Un **albero k-ario completo** è un albero k-ario in cui tutte le foglie hanno la stessa profondità e ogni nodo interno ha esattamente k figli

### Esercizio 1

Trovare il numero di foglie e il numero di nodi interni di un albero k-ario completo di altezza $h$

- Per il numero di foglie graficamente si può giungere alla formula

	$$\# \text{foglie} = k^h$$

	Dimostriamolo per induzione sull'altezza dell'albero:

	**caso base**:
		il caso base avviene quando $h = 0$, quindi l'albero è costituito solo dalla radice (che è anche l'unica foglia) infatti abbiamo $k^0 = 1$

	**passo induttivo**:
	Assumo per ipotesi induttiva che la proprietà sia vera per l'altezza $h$

	$\#\text{foglie}(h) = k^h$

	voglio dimostrarla per $h+1$, cioè vogliamo dimostrare che vale

	$\#\text{foglie}(h+1) = k^{h+1}$

	Sappiamo per ipotesi induttiva che al livello $h$ dell'albero ci sono $k^h$ nodi e
dato che l'albero è completo sappiamo che tutti i nodi a livello $h$ hanno $k$ figli quindi

	$$k^h \cdot k = k^{h+1}$$

	otteniamo quindi

	$\#\text{foglie}(h+1) = k^{h+1}$

- Per il numero di nodi interni, possiamo fare la somma di tutti i nodi tranne quelli all'ultimo livello:

$$\#\text{nodi interni} =\sum_{i=0}^{h-1}k^i$$

è una serie geometrica che possiamo scrivere come:

$$\#\text{nodi interni} =\frac{k^n -1}{k-1}$$


### Esercizio 2

Trovare l'altezza di un albero k-ario completo avente $n$ foglie:

Sappiamo che il numero di foglie è dato da $k^h$

per ottenere $h$ facciamo il applichiamo il logaritmo su entrambi i membri

$$h = \log_k(\#\text{foglie})$$


## Implementazione degli alberi

Le operazioni che vogliamo implementare sugli alberi sono

- `padre(Tree P, Node v)` $\to$ Node oppure NIL
pre-condizione: il nodo deve appartenere all'albero
post-condizione: restituisce il padre di un nodo oppure NIL

- `figli(Tree P, Node v)` $\to$ Lista di Node
pre-condizione: il nodo deve appartenere all'albero
post-condizione: restituisce la lista contenente i figli del nodo


## Implementazione con array

Utilizziamo un array contenente una struttura contenente l'informazione e l'indice dell'array del padre `(info, parent)`

Quindi il seguente albero

![enter image description here](https://i.ibb.co/hy4Pp0R/alberello.png)

verrebbe rappresentato dal seguente array P

![enter image description here](https://i.ibb.co/RDyyGt3/array.png)

`P[<indice>].info` = contenuto del nodo dell'albero
`P[<indice>].parent` = indice del padre

Il parent della radice è -1
rappresentiamo la lunghezza dell'array con `P.length`
Lo spazio richiesto per questa implementazione è $\Theta(n)$

```c++
padre(Tree P, node v) {
	if (P[v].parent == -1) {
		return -1;
	}
	else {
		return P[v].parent
	}
}
```
La complessità di questo algoritmo è cotante

$$T(n) = \Theta(1)$$

```c++
figli(Tree P, node v) {
	l = []
	for(i = 0; i < P.length; i++) {
		if (P[i].parent == v) {
			l.append(i)
		}
	}
	return l
}
```

Assumendo che l'istruzione `append` sia di complessità costante la complessità del nostro algoritmo è $n$ dato che dobbiamo scorrere tutta la lista

$$T(n) = \Theta(n)$$
