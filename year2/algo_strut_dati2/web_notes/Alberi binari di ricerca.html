<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2023-11-09_Alberi binari di ricerca</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#alberi-binari-di-ricerca">Alberi binari di ricerca</a>
<ul>
<li><a href="#ricerca">ricerca</a></li>
<li><a href="#massimo">Massimo</a></li>
<li><a href="#minimo">Minimo</a></li>
<li><a href="#successore">Successore</a></li>
<li><a href="#predecessore">predecessore</a></li>
<li><a href="#inserimento">Inserimento</a></li>
<li><a href="#cancellazione">Cancellazione</a></li>
<li><a href="#costruzione">Costruzione</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="alberi-binari-di-ricerca">Alberi binari di ricerca</h1>
<p>Un albero binario di ricerca è un albero binario che soddisfa la seguente proprietà (chiamata proprietà di ricerca):</p>
<p>scelto un qualsiasi nodo <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> dell’albero deve valere che nel <strong>sottoalbero sinistro</strong> sono presenti nodi con <strong>valori minori o uguali</strong> a <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> mentre nel <strong>sottoalbero destro</strong> sono presenti nodi con <strong>valori maggiori o uguale</strong> a <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span></p>
<p>Un esempio di albero binario di ricerca è il seguente:</p>
<p><img src="https://i.ibb.co/V27PH2B/alberello.png" alt=""></p>
<p>La visita <strong>in-order</strong> di questo tipo di albero permette di rappresentare i valore in ordine da più piccolo al più grande</p>
<p>Andremo a vedere varie operazioni su questo tipo di albero.<br>
Un nodo <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> è formato da:</p>
<ul>
<li>la chiave <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">.</mi><mtext>key</mtext></mrow><annotation encoding="application/x-tex">x.\text{key}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord text"><span class="mord">key</span></span></span></span></span></span></li>
<li>il puntatore al padre<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">.</mi><mtext>p</mtext></mrow><annotation encoding="application/x-tex">x.\text{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord text"><span class="mord">p</span></span></span></span></span></span></li>
<li>il puntatore al figlio sinistro <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">.</mi><mtext>left</mtext></mrow><annotation encoding="application/x-tex">x.\text{left}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord text"><span class="mord">left</span></span></span></span></span></span></li>
<li>il puntatore al figlio destro <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">.</mi><mtext>right</mtext></mrow><annotation encoding="application/x-tex">x.\text{right}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord text"><span class="mord">right</span></span></span></span></span></span></li>
</ul>
<h2 id="ricerca">ricerca</h2>
<p>Scriviamo l’algoritmo per la ricerca di una nodo data la chiave</p>
<p><strong>versione ricorsiva</strong></p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token function">search</span><span class="token punctuation">(</span>node x<span class="token punctuation">,</span> value k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> NIL or x<span class="token punctuation">.</span>key <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> x
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>key <span class="token operator">&gt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> k<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token function">search</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> k<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="versione-iterativa">Versione iterativa</h3>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token function">search</span><span class="token punctuation">(</span>node x<span class="token punctuation">,</span> value k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>x <span class="token operator">!=</span> NIL and x<span class="token punctuation">.</span>key <span class="token operator">!=</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> x<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			x <span class="token operator">=</span> x<span class="token punctuation">.</span>left
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{</span>
			x <span class="token operator">=</span> x<span class="token punctuation">.</span>right
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> x
<span class="token punctuation">}</span>
</code></pre>
<p>Questi algoritmi sono corretti perché la proprietà ci permette di tagliare degli interi sottoalberi garantendoci che nel sottoalberi tagliati ci saranno solo valori maggiori (a destra) o minori (sinistra)</p>
<p>Per analizzare la complessità di questi due algoritmi possiamo pensare che quando cerchiamo il valore stiamo seguendo un cammino dell’albero, nel caso peggiore questo cammino è il più lontano di tutti (cioè l’altezza dell’albero) quindi possiamo concludere che</p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span></span></span></p>
<p>dove <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathnormal">h</span></span></span></span></span> è l’altezza dell’albero</p>
<h2 id="massimo">Massimo</h2>
<p>Scriviamo l’algoritmo per trovare il massimo di un albero binario di ricerca</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token comment">// pre-condizione: x deve appartenere all'albero</span>
<span class="token function">maximum</span><span class="token punctuation">(</span>node x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>right <span class="token operator">!=</span> NIL<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		x <span class="token operator">=</span> x<span class="token punctuation">.</span>right
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> x
<span class="token punctuation">}</span>
</code></pre>
<p>Il nodo con la chiave massima sarà il nodo più a destra nell’albero</p>
<h2 id="minimo">Minimo</h2>
<p>Scriviamo l’algoritmo per trovare il minimo di un albero binario di ricerca</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token comment">// pre-condizione: x deve appartenere all'albero</span>
<span class="token function">minimium</span><span class="token punctuation">(</span>node x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>left <span class="token operator">!=</span> NIL<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		x <span class="token operator">=</span> x<span class="token punctuation">.</span>left
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> x
<span class="token punctuation">}</span>
</code></pre>
<p>Il nodo con la chiave minima sarà il nodo più a sinistra nell’albero</p>
<p>la correttezza è sempre garantita dalla proprietà dell’albero binario di ricerca</p>
<p>Dato che stiamo sempre visitando un cammino dell’albero, il caso peggiore sarà il cammino più lungo quindi</p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span></span></span></p>
<h2 id="successore">Successore</h2>
<p>In un albero binario di ricerca che ha tutti i nodi con chiavi distinte, il successore di un nodo <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> è la più piccola chiave maggiore di <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">.</mi><mtext>key</mtext></mrow><annotation encoding="application/x-tex">x.\text{key}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord text"><span class="mord">key</span></span></span></span></span></span></p>
<p>Abbiamo due casi per determinare il successore.</p>
<ol>
<li>se <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> ha un figlio destro, allora il successore è il minimo nel sottoalbero destro</li>
<li>se <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> non ha un figlio destro, allora il successore (se esiste) si trova risalendo l’albero fino alla prima “svolta” a destra.<br>
(con svolta si intende che fino a che il nodo attualmente puntato è figlio destro allora bisogna continuare a salire, quando il nodo è figlio sinistro allora ci si perché suo padre sarà il successore)</li>
</ol>
<p>nota che se <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> è il nodo massimo, esso non ha successore.</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token comment">// pre-condizione: x deve appartenere all'albero</span>
<span class="token function">successore</span><span class="token punctuation">(</span>node x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>right <span class="token operator">!=</span> NIL<span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">//caso 1</span>
		<span class="token keyword">return</span> <span class="token function">minimum</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token punctuation">{</span>	<span class="token comment">//caso 2</span>
		y <span class="token operator">=</span> x<span class="token punctuation">.</span>p		<span class="token comment">//y sarà sempre il padre di x</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>y <span class="token operator">!=</span> NIL and x <span class="token operator">==</span> y<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">// continua fino a che o il padre non esiste oppure fino a che non si trova una "svolta" a destra</span>
			x <span class="token operator">=</span> y
			y <span class="token operator">=</span> x<span class="token punctuation">.</span>p
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> y
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Nel primo <code>if</code> abbiamo la complessità del metodo <code>minimum</code> che abbiamo visto essere <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span></span>. Anche per l’else però abbiamo la complessità di un cammino (che nel caso peggiore sarà il cammino più lungo) quindi anche qui abbiamo <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span></span></p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span></span></span></p>
<h2 id="predecessore">predecessore</h2>
<p>In un albero binario di ricerca che ha tutti i nodi con chiavi distinte, il predecessore di un nodo <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> è la più grande chiave minore di <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi mathvariant="normal">.</mi><mtext>key</mtext></mrow><annotation encoding="application/x-tex">x.\text{key}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord text"><span class="mord">key</span></span></span></span></span></span></p>
<p>nota che se <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> è il nodo minimo, esso non ha predecessore.</p>
<p>Il procedimento è molto simile a quello per trovare il successore</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token comment">// pre-condizione: x deve appartenere all'albero</span>
<span class="token function">predecessore</span><span class="token punctuation">(</span>node x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token operator">!=</span> NIL<span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">//caso 1</span>
		<span class="token keyword">return</span> <span class="token function">maximun</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token punctuation">{</span>	<span class="token comment">//caso 2</span>
		y <span class="token operator">=</span> x<span class="token punctuation">.</span>p		<span class="token comment">//y sarà sempre il padre di x</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>y <span class="token operator">!=</span> NIL and x <span class="token operator">==</span> y<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">// continua fino a che o il padre non esiste oppure fino a che non si trova una "svolta" a destra</span>
			x <span class="token operator">=</span> y
			y <span class="token operator">=</span> x<span class="token punctuation">.</span>p
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> y
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Analogamente abbiamo<br>
<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span></span></span></p>
<h2 id="inserimento">Inserimento</h2>
<p>Scriviamo l’algoritmo per inserire un nuovo nodo nell’albero rispettando la sua proprietà.</p>
<p>Ci serviamo di un puntatore alla radice (utile per gestire l’albero vuoto): <code>T.root</code></p>
<p>Assumiamo che il nuovo nodo da inserire <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.04398em;">z</span></span></span></span></span> sia già stato inizializzato con i puntatori a <code>NIL</code> e con la chiave già impostata.</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token function">inserimento</span><span class="token punctuation">(</span>Tree T<span class="token punctuation">,</span> node z<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	y <span class="token operator">=</span> NIL	<span class="token comment">//rappresenterà il padre del nodo z</span>
	x <span class="token operator">=</span> T<span class="token punctuation">.</span>root
	<span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> NIL<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		y <span class="token operator">=</span> x
		<span class="token keyword">if</span> <span class="token punctuation">(</span>z<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> x<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			x <span class="token operator">=</span> x<span class="token punctuation">.</span>left
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{</span>
			x <span class="token operator">=</span> x<span class="token punctuation">.</span>right
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	z<span class="token punctuation">.</span>p <span class="token operator">=</span> y
	<span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> NIL<span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">//se l'albero è vuoto allora z sarà la radice</span>
		T<span class="token punctuation">.</span>root <span class="token operator">=</span> z
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>z<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			y<span class="token punctuation">.</span>left <span class="token operator">=</span> z
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{</span>
			y<span class="token punctuation">.</span>right <span class="token operator">=</span> z
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>la complessità è data dal ciclo while, quel ciclo visita un cammino dell’albero, nel caso peggiore è il cammino più lungo, quindi</p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span></span></span></p>
<h2 id="cancellazione">Cancellazione</h2>
<p>Pre implementare la cancellazione ci serviamo di una proprietà fondamentale degli alberi binari di ricerca:</p>
<p><strong>proprietà</strong>: Se un nodo x in un albero binario di ricerca ha due figli, allora il suo successore non ha un figlio sinistro, e, in maniera analoga, il suo predecessore non ha un figlio destro.<br>
In questo caso siamo interessati al successore.</p>
<p><strong>dimostrazione</strong><br>
Sia <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> un nodo con due figli. In una visita simmetrica (<em>in-order</em>), i nodi del sottoalbero sinistro precedono <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> e quelli del sottoalbero destro seguono <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span>.<br>
Di conseguenza, il successore di <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> si trova nel suo sottoalbero destro.</p>
<p>Se <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">s</span></span></span></span></span> è il successore di <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span>, assumiamo per assurdo che <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">s</span></span></span></span></span> abbia un figlio sinistro, che chiamiamo <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathnormal" style="margin-right: 0.03588em;">y</span></span></span></span></span>. Allora, <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathnormal" style="margin-right: 0.03588em;">y</span></span></span></span></span> segue <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span> perché si trova nel suo sottoalbero destro, ma precede <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">s</span></span></span></span></span> perché si trova nel sottoalbero sinistro di <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">s</span></span></span></span></span>. Questo è assurdo, perché <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">s</span></span></span></span></span> non sarebbe più il successore di <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">x</span></span></span></span></span>, ma lo sarebbe <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathnormal" style="margin-right: 0.03588em;">y</span></span></span></span></span>.</p>
<p>Tornando alla cancellazione:<br>
Quando dobbiamo rimuovere un nodo <code>z</code> dall’albero possiamo distinguere tre casi distinti:</p>
<ol>
<li>se <code>z</code> è una foglia dell’albero allora basta impostare il puntatore al padre di <code>z</code> a NULL e impostare <code>z = NULL</code></li>
<li>se <code>z</code> ha un unico figlio, in questo caso si crea il collegamento tra il padre di <code>z</code> e il suo nodo figlio</li>
<li>se <code>z</code> ha due figli, dobbiamo trovare il suo successore e mettiamo il successore nella posizione del nodo <code>z</code>, avendo cura di aggiornare i rispettivi puntatori.</li>
</ol>
<p>Implementiamolo in pseudocodice:</p>
<p>innanzitutto ci serviamo di una funzione extra chiamata <code>transplant</code> che dato il puntatore alla radice, e due nodi <code>u</code> e <code>v</code> sostituisce il sottoalbero radicato in <code>u</code> con il sottoalbero radicato in <code>v</code></p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token function">transplant</span><span class="token punctuation">(</span>Tree T<span class="token punctuation">,</span> Node u<span class="token punctuation">,</span> Node v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>u<span class="token punctuation">.</span>p <span class="token operator">==</span> NIL<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		T<span class="token punctuation">.</span>root <span class="token operator">=</span> v<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> u<span class="token punctuation">.</span>p<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">//se u è figlio sinistro</span>
			u<span class="token punctuation">.</span>p<span class="token punctuation">.</span>left <span class="token operator">=</span> v<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{</span>		<span class="token comment">//se u è figlio destro</span>
			u<span class="token punctuation">.</span>p<span class="token punctuation">.</span>right <span class="token operator">=</span> v<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">!=</span> NIL<span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">//il nuovo sottoalbero punta al nuovo padre</span>
		v<span class="token punctuation">.</span>p <span class="token operator">=</span> u<span class="token punctuation">.</span>p<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>La complessità di questo metodo è costante <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>Implementiamo ora la cancellazione</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token function">tree_delete</span><span class="token punctuation">(</span>tree T<span class="token punctuation">,</span> Node z<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>z<span class="token punctuation">.</span>left <span class="token operator">==</span> NIL<span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">//caso 1</span>
		<span class="token function">transplant</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> z<span class="token punctuation">,</span> z<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>z<span class="token punctuation">.</span>right <span class="token operator">==</span> NIL<span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">//caso 2</span>
			<span class="token function">transplant</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> z<span class="token punctuation">,</span> z<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{</span>
			y <span class="token operator">=</span> <span class="token function">minimium</span><span class="token punctuation">(</span>z<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token punctuation">.</span>p <span class="token operator">!=</span> z<span class="token punctuation">)</span> <span class="token punctuation">{</span>		<span class="token comment">//caso 3.1</span>
				<span class="token function">transplant</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> y<span class="token punctuation">,</span> y<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
				y<span class="token punctuation">.</span>right <span class="token operator">=</span> z<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
				z<span class="token punctuation">.</span>right<span class="token punctuation">.</span>p <span class="token operator">=</span> y<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token function">transplant</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> z<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//caso 3.2</span>
			y<span class="token punctuation">.</span>left <span class="token operator">=</span> z<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
			y<span class="token punctuation">.</span>left<span class="token punctuation">.</span>p <span class="token operator">=</span> y<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="https://i.ibb.co/WBWHvCR/image.png" alt="enter image description here"></p>
<p>La complessità dell’algoritmo è data dalla complessità del metodo <code>minimum</code> che abbiamo già visto essere <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span></span></p>
<h2 id="costruzione">Costruzione</h2>
<p>tutte le operazioni che abbiamo visto possono essere realizzate in tempo <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span></span>, se l’albero è bilanciato allora <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">O(h)=\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathnormal">n</span></span></span></span></span>, mentre più l’albero tende ad essere sbilanciato più la complessità tende ad essere <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.</p>
<p>Avendo un array di elementi da inserire per creare un albero binario il caso peggiore che ci possa capitare è che gli elementi dell’array siano in ordine strettamente crescenti oppure strettamente decrescenti (questo perché l’albero prenderebbe la forma di una semplice lista).</p>
<p>Vediamolo nel seguente algoritmo:</p>
<pre class=" language-c"><code class="prism ++ language-c">Arr a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token function">build_BST</span><span class="token punctuation">(</span>Arr a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	t <span class="token operator">=</span> <span class="token function">newTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		u <span class="token operator">=</span> <span class="token function">creaNodo</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">inserimento</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> t
<span class="token punctuation">}</span>
</code></pre>
<p>Analizziamo la complessità</p>
<p>Supponendo che il metodo <code>creaNodo()</code> abbia complessità costante allora la complessità dipende dal metodo <code>inserimento</code> e dal ciclo for.</p>
<p>La complessità dell’inserimento è <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span></span>.<br>
Dato che abbiamo un array ordinato, l’albero sarà fortemente sbilanciato verso destra, questo significa che l’altezza dell’albero è uguale al numero di nodi, quindi la complessità dell’inserimento è <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>, ma dato che l’inserimento viene chiamato nel ciclo for <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">n</span></span></span></span></span> volte abbiamo una complessità di <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>Cerchiamo di migliorare l’algoritmo:</p>
<p>Dato che abbiamo un array ordinato al posto di scorrerlo da sinistra verso destra lo scorriamo a partire dal centro (similmente a come viene fatta la <em>binary search</em>)</p>
<pre class=" language-c"><code class="prism ++ language-c">Arr a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token function">build_BST_ott</span><span class="token punctuation">(</span>Arr a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	t <span class="token operator">=</span> <span class="token function">newTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t<span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token function">build_BST_ott_aux</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> NIL<span class="token punctuation">)</span>
	<span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">build_BST_ott_aux</span><span class="token punctuation">(</span>Arr a<span class="token punctuation">,</span> <span class="token keyword">int</span> inf<span class="token punctuation">,</span> <span class="token keyword">int</span> sup<span class="token punctuation">,</span> Node padre<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>inf <span class="token operator">&gt;</span> sup<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> NIL<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token punctuation">{</span>
		med <span class="token operator">=</span> <span class="token punctuation">(</span>inf <span class="token operator">+</span> sup<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
		r <span class="token operator">=</span> <span class="token function">creaNode</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>med<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		r<span class="token punctuation">.</span>p <span class="token operator">=</span> padre<span class="token punctuation">;</span>
		r<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">build_BST_ott_aux</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> inf<span class="token punctuation">,</span> med <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
		r<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">build_BST_ott_aux</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> med <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> sup<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> r<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Per funzionare questo metodo deve ricevere un <strong>array già ordinato</strong>, questo algoritmo ottimizzato permette di avere un albero di altezza uguale a <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathnormal">n</span></span></span></span></span></p>
<p>Calcoliamo la complessità dell’algoritmo.</p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3600em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>c</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>2</mn><mi>T</mi><mrow><mo fence="true">(</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo fence="true">)</mo></mrow><mo>+</mo><mi>d</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">T(n) = \begin{cases}
c &amp; n = 0\\
2T\left(\frac{n}{2}\right) + d &amp; n &gt; 0
\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 3.00003em; vertical-align: -1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.69em;"><span class="" style="top: -3.69em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord mathnormal">c</span></span></span><span class="" style="top: -2.25em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.695392em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord mathnormal">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.19em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.69em;"><span class="" style="top: -3.69em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord">0</span></span></span><span class="" style="top: -2.25em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.19em;"><span class=""></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p>
<p>Possiamo utilizzare il teorema master</p>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">a = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span></span></span></span></span><br>
<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">b = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span></span></span></span></span><br>
<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">f(n) = d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathnormal">d</span></span></span></span></span><br>
<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mn>2</mn></mrow></msup><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n^{\log_22} = n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.849108em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right: 0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.194446em;"><span class="" style="top: -2.23413em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.265869em;"><span class=""></span></span></span></span></span></span><span class="mspace mtight" style="margin-right: 0.195167em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">n</span></span></span></span></span></p>
<p>Verifichiamo di essere nel caso 1:</p>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><mn>1</mn><mo>−</mo><mi>ϵ</mi></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n) = O(n^{1-\epsilon})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">ϵ</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span><br>
se scelgo <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\epsilon = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span> ottengo <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>0</mn></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n^0 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span><br>
Dunque vale che <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = \Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
<p><strong>Nota</strong> per il momento è importante sapere che se l’array non è ordinato è più conveniente prima ordinarlo e poi utilizzare la funzione ottimizzata per creare l’albero, vedremo più avanti che ciò ha complessità <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>

    </div>
  </div>
</body>

</html>
