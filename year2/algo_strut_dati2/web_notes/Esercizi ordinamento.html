<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2023-12-21_Esercizi ordinamento</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#esercizi-su-ordinamento">Esercizi su ordinamento</a>
<ul>
<li><a href="#rimozione-da-max-heap">Rimozione da max heap</a></li>
<li><a href="#differenza-tra-max-heap">Differenza tra max heap</a></li>
<li><a href="#vettore-di-intervalli">Vettore di intervalli</a></li>
<li><a href="#somma-k">Somma k</a></li>
<li></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="esercizi-su-ordinamento">Esercizi su ordinamento</h1>
<h2 id="rimozione-da-max-heap">Rimozione da max heap</h2>
<p>Implementare la rimozione di un nodo da un max heap.</p>
<p>Per realizzare la rimozione, quello che facciamo è scambiare il nodo da eliminare con l’ultimo nodo dell’array.<br>
Decrementare la heap_size (cancellando così l’ultimo nodo).<br>
riposizionare il nodo scambiato per metterlo nella posizione tale da non violare la proprietà del max heap.</p>
<p>Quando andiamo a riposizionare il nodo ci possiamo trovare in due casi:</p>
<ul>
<li>caso 1: il nodo va messo in una posizione più alta nell’albero. Ciò si verifica quando il nodo da eliminare era più piccolo del nodo in ultima posizione (nell’immagine sotto infatti <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">0 &lt; 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68354em; vertical-align: -0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">7</span></span></span></span></span>)</li>
<li>caso 2: il nodo va messo in una posizione più bassa dell’albero. Ciò si verifica quando il nodo da eliminare era più grande del nodo in ultima posizione (nell’immagine sotto infatti <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">3 &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68354em; vertical-align: -0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>)</li>
</ul>
<p><img src="https://i.ibb.co/vdbP5nc/image.png" alt="enter image description here"></p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token comment">// precondizione: i deve appartenere all'heap</span>
<span class="token comment">// postcondizione: i non appartiene più all'heap</span>
<span class="token function">heap_delete</span><span class="token punctuation">(</span>Heap A<span class="token punctuation">,</span> Node i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>heap_size <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">//se c'è un solo elemento lo elimino e basta</span>
		A<span class="token punctuation">.</span>heap_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token punctuation">{</span>
		value_to_remove <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>A<span class="token punctuation">.</span>heap_size<span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">//metto l'ultimo elemento in posizione i</span>
		A<span class="token punctuation">.</span>heap_size<span class="token operator">--</span><span class="token punctuation">;</span>
	
		<span class="token keyword">if</span> <span class="token punctuation">(</span>value_to_remove <span class="token operator">&gt;</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>	<span class="token comment">//caso 2</span>
			<span class="token function">max_heapify</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{</span>	<span class="token comment">//caso 1</span>
			<span class="token function">heap_increase_key</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> i<span class="token punctuation">,</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Analisi della complessità:<br>
entrambi i secondi <code>if-else</code> eseguono un metodo che ha complessità <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> quindi la complessità è <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
<h2 id="differenza-tra-max-heap">Differenza tra max heap</h2>
<p>Dati due max heap <code>h1, h2</code> effettuare la differenza insiemistica <code>h1 - h2</code>. Quindi bisogna tenere tutti i nodi di <code>h1</code> tranne quelli che sono presenti anche in <code>h2</code></p>
<p><img src="https://i.ibb.co/0hRR5z7/image.png" alt="enter image description here"></p>
<p>Quello che andremo a fare è confrontare sempre le radici e:</p>
<ul>
<li>se la radice di <code>h1</code> è maggiore della radice di <code>h2</code>, allora la radice di <code>h1</code> farà parte dell’heap risultato e trovo la nuova radice di <code>h1</code> tramite <code>heap_extract_max</code></li>
<li>se la radice di <code>h1</code> è uguale alla radice di <code>h2</code>, non mi interessa quel valore e quindi trovo la nuova radice di entrambi gli heap tramite <code>heap_extract_max</code></li>
<li>se la radice di <code>h1</code> è minore della radice di <code>h2</code>, non posso determinare subito se la radice di <code>h1</code> è un valore che posso mantenere e quindi lo comparo con la successiva radice di <code>h2</code> tramite un <code>heap_extract_max</code></li>
</ul>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token function">differenza</span><span class="token punctuation">(</span>Heap h1<span class="token punctuation">,</span> Heap h2<span class="token punctuation">,</span> Heap ris<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> max_h1<span class="token punctuation">,</span> max_h2<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>h1<span class="token punctuation">.</span>heap_size <span class="token operator">&gt;=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> h2<span class="token punctuation">.</span>heap_size <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		max_h1 <span class="token operator">=</span> <span class="token function">heap_maximum</span><span class="token punctuation">(</span>h1<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//O(1)</span>
		max_h2 <span class="token operator">=</span> <span class="token function">heap_maximum</span><span class="token punctuation">(</span>h2<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//O(1)</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>max_h1 <span class="token operator">==</span> max_h2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">heap_extract_max</span><span class="token punctuation">(</span>h1<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//O(log n1)</span>
			<span class="token function">heap_extract_max</span><span class="token punctuation">(</span>h2<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//O(log n2)</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>max_h1 <span class="token operator">&gt;</span> max_h2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">heap_insert</span><span class="token punctuation">(</span>ris<span class="token punctuation">,</span> max_h1<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// *O(1)</span>
			<span class="token function">heap_extract_max</span><span class="token punctuation">(</span>h1<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// O(log n1)</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>max_h1 <span class="token operator">&lt;</span> max_h2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">heap_extract_max</span><span class="token punctuation">(</span>h2<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//O(log n2)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// nel caso h2 sia finito, inserisco nel risultato tutti i valori rimanenti di h1</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>h1<span class="token punctuation">.</span>heap_size <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		max_h1 <span class="token operator">=</span> <span class="token function">heap_extract_max</span><span class="token punctuation">(</span>h1<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// O(log n)</span>
		<span class="token function">heap_insert</span><span class="token punctuation">(</span>ris<span class="token punctuation">,</span> max_h1<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//O(1)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Nel caso peggiore l’algoritmo deve scorrere interamente entrambi gli heap.<br>
Dichiarando come <code>n1</code> il numero di elementi dell’heap <code>h1</code>, e come <code>n2</code> il numero di elementi dell’heap <code>h2</code></p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mn>1</mn><mo>⋅</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi><mn>2</mn><mo>⋅</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = O(n1\cdot \log(n1) + n2 \cdot \log (n2))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord mathnormal">n</span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">2</span><span class="mclose">))</span></span></span></span></span></span></p>
<p>la complessità è quindi data da <code>n1</code> chiamate a <code>heap_extract_max</code> e da <code>n2</code> chiamate a <code>heap_extract_max</code>.</p>
<h2 id="vettore-di-intervalli">Vettore di intervalli</h2>
<p>Dato un vettore di intervalli interi, creare un nuovo vettore di intervalli contenente gli stessi elementi ma gli intervalli devono essere disgiunti.</p>
<p>Vediamo un esempio grafico dell’array di partenza</p>
<p><img src="https://i.ibb.co/db1DLgC/image.png" alt="enter image description here"></p>
<p>L’array risultante dovrebbe essere:</p>
<p><img src="https://i.ibb.co/R4Kp9Qt/image.png" alt="enter image description here"></p>
<p>Vediamo i passaggi partendo dal vettore originale<br>
<code>A=[&lt;7,11&gt;, &lt;-1,3&gt;, &lt;5,10&gt;, &lt;9,12&gt;]</code></p>
<ol>
<li>ordinare il vettore<br>
<code>A=[&lt;-1,3&gt;, &lt;5,10&gt;, &lt;7,11&gt;, &lt;9,12&gt;]</code></li>
<li>Scorro il vettore con un ciclo while
<ul>
<li>metto la coppia attuale nel vettore risultato</li>
<li>faccio un altro ciclo while per determinare quale è il limite destro dell’intervallo più grande che posso considerare della coppia appena inserita</li>
<li>il limite destro viene trovato quando siamo arrivati alla fine del vettore oppure quando non c’è una sovrapposizione (una sovrapposizione accade quando il limite destro è maggiore del limite sinistro dell’elemento successivo)</li>
</ul>
</li>
</ol>
<pre class=" language-c"><code class="prism ++ language-c"> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">copertura</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	size_t i<span class="token punctuation">;</span>	<span class="token comment">//scorre gli elementi del vettore</span>
	<span class="token keyword">int</span> end_temp<span class="token punctuation">;</span>	<span class="token comment">// limite superiore dell'attuale intervallo</span>
	vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> ris<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> ris<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token function">ordina</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// ipotizziamo di fare un merge sort, θ(n*log(n))</span>
	
	i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		ris<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//assumiamo θ(1)</span>
		end_temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>
		i<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> end_temp <span class="token operator">&gt;=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second <span class="token operator">&gt;</span> end_temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				end_temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			i<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		ris<span class="token punctuation">[</span>ris<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>second <span class="token operator">=</span> end_temp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> ris<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Complessità: Abbiamo la complessità dell’orginamento che è <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> e poi abbiamo 2 cicli while innestati. Nonostante siano innestati essi lavorano sullo stesso indice continuando ad incrementarlo, ogni elemento del vettore viene quindi visitato solo una volta, la complessità del corpo del ciclo while esterno è quindi <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = \Theta(n\log n) + \Theta(n) = \Theta(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></span></p>
<h2 id="somma-k">Somma k</h2>
<p>Dato un intero <code>k</code> e un vettore <code>v</code> creare un algoritmo efficiente determinare se esiste una coppia di elementi <code>val1, val2</code>  con indice diverso la cui somma è uguale a <code>k</code></p>
<p>Abbiamo due approcci possibili per realizzare un algoritmo efficiente:</p>
<ol>
<li>chiamare la binary search per ogni elemento del vettore: <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></li>
<li>utilizzare due indici per confrontare in modo intelligente gli elementi: <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> (ma risulta essere comunque migliore rispetto al primo metodo)</li>
</ol>
<p>Analizziamo meglio il secondo metodo:</p>
<ol>
<li>andiamo ad ordinare il vettore</li>
<li>creiamo due indici <code>left, right</code> inizializzati rispettivamente al primo elemento e all’ultimo. Inizialmente <code>left</code> sarà l’indice dell’elemento più piccolo, mentre <code>right</code> sarà l’indice dell’elemento più grande</li>
<li>in un ciclo compariamo gli elementi negli indici <code>left</code> e <code>right</code>
<ul>
<li>se la somma è uguale a <code>k</code> abbiamo finito</li>
<li>se la somma è minore di <code>k</code>, allora la somma è troppo piccola, dobbiamo cercare di aumentarla il minimo possibile andando all’elemento <code>left</code> successivo</li>
<li>se la somma è maggiore di <code>k</code>, allora la somma è troppo grande, dobbiamo cercare di diminuirla il minimo possibile andando all’elemento <code>right</code> precedente</li>
</ul>
</li>
</ol>
<p>consideriamo ad esempio l’array già ordinato<br>
<code>v = [-7, -3, 0, 5, 10, 14, 21]</code><br>
con <code>k = 11</code><br>
la successione di confronti è la seguente:</p>
<ul>
<li>confronto il <code>-7</code> con il <code>21</code>: <code>-7 + 21 = 14 &gt; 11</code> Dato che la somma è maggiore di <code>k</code> posso escludere che il <code>21</code> possa far parte della coppia.<br>
Questo logicamente perchè se sommando l’elemento minimo (<code>-7</code>) con il 21 mi da un risultato maggiore di quello che cerco, non ha senso fare le somme tra elementi maggiori di <code>-7</code> con il <code>21</code> perché sicuramente mi daranno dei valori ancora maggiori di quello che cerco</li>
<li>confronto il <code>-7</code> con il <code>14</code>: <code>-7 + 14 = 7 &lt; 11</code> Dato che la somma è minore di <code>k</code> posso escludere che il <code>-7</code> possa far parte della coppia.<br>
similmente a prima perchè se sommando l’elemento massimo (<code>14</code>) con il <code>-7</code> mi da un risultato minore di quello che cerco, non ha senso fare le somme tra elementi minori di <code>14</code> con il <code>-7</code> perché sicuramente mi daranno dei valori ancora minori di quello che cerco</li>
<li>confronto il <code>-3</code> con il <code>14</code>: <code>-3 + 14 = 11</code> ho trovato la coppia che somma <code>k</code></li>
</ul>
<pre class=" language-c"><code class="prism ++ language-c">bool <span class="token function">sommaK</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> va1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> val2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">ordina</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//assumiamo di fare un merge sort, θ(n log(n))</span>
	bool trovati <span class="token operator">=</span> false<span class="token punctuation">;</span>
	<span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> right <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> trovati <span class="token operator">==</span> false<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			trovati <span class="token operator">=</span> true<span class="token punctuation">;</span>
			val1 <span class="token operator">=</span> v<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
			val2 <span class="token operator">=</span> v<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			left<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			right<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> trovati<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>complessità: l’ordinamento ha complessità <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>, mentre il ciclo while viene eseguito al massimo <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">n</span></span></span></span></span> volte ed è composto da sole istruzioni di complessità costante, quindi ha complessità <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = \Theta(n \log n) + O(n) = \Theta(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></span></p>
<h2 id="section"></h2>
<p>Sia A un array di lunghezza <code>n − k</code> con <code>k &gt;= 2</code> e <code>k &lt;= n</code>, privo di ripetizioni e contenente interi nell’intervallo <code>[n*n + 1, n*n + n]</code>. Si consideri il problema di determinare i <code>k</code> numeri interi appartenenti all’intervallo <code>[n*n + 1, n*n + n]</code> che non compaiono in <code>A</code>.<br>
Si scriva una procedura efficiente che, dati <code>A, n</code> e <code>k</code>, risolva il problema proposto stampando gli interi che non compaiono in A. Calcolarne la complessità.</p>
<p>Per esempio:<br>
<code>n = 5</code><br>
<code>k = 3</code><br>
Avremo un array di dimensione <code>5-3 = 2</code><br>
Questi 2 elementi possono assumere valori appartenenti al seguente range <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>5</mn><mo>⋅</mo><mn>5</mn><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mn>5</mn><mo>⋅</mo><mn>5</mn><mo>+</mo><mn>5</mn><mo stretchy="false">]</mo>  <mo>⟹</mo>  <mo stretchy="false">[</mo><mn>26</mn><mo separator="true">,</mo><mn>30</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[5\cdot5+1, 5\cdot5+5] \implies [26, 30]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">5</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">5</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">5</span><span class="mclose">]</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">⟹</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">26</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">30</span><span class="mclose">]</span></span></span></span></span>.<br>
Ipotizziamo che l’array assuma i seguenti valori: <code>A[27, 30]</code>. Vogliamo stampare gli altri elementi all’interno range che non sono presenti nell’array, in questo caso stamperemmo: <code>26, 28, 29</code></p>
<p><strong>Risoluzione</strong></p>
<p>Utilizziamo un vettore ausiliario di booleani grande <code>n</code> che rappresenta tutti i numeri del range.<br>
Scorriamo il vettore di input e per ogni elemento andiamo a impostare il relativo elemento nel vettore di booleani come <code>true</code> per indicare che tale elemento del range è presente nel vettore di input.<br>
Poi stampiamo tutti gli elementi del range che sono false nel vettore di booleani</p>
<pre class=" language-c"><code class="prism ++ language-c"><span class="token keyword">void</span> <span class="token function">determinaK</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span>bool<span class="token operator">&gt;</span> <span class="token function">occ</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//vettore di n elementi inizializzati a false</span>
	<span class="token keyword">int</span> min <span class="token operator">=</span> n<span class="token operator">*</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		occ<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>occ<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> false<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span>min <span class="token operator">+</span> i<span class="token punctuation">;</span>
			k<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		i<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>complessità</strong>: abbiamo un ciclo for che viene eseguito <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n-k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.03148em;">k</span></span></span></span></span> volte e un ciclo while che viene eseguito k volte. Abbiamo quindi una complessità lineare, in quanto vengono fatte <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>k</mi><mo>+</mo><mi>k</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n-k+k = n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">n</span></span></span></span></span> iterazioni.</p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = \Theta(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></span></p>

    </div>
  </div>
</body>

</html>
