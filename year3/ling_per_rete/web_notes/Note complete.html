<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2024-12-02_SVG e canvas</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#introduzione-a-javascript">Introduzione a JavaScript</a>
<ul>
<li><a href="#espressioni-e-statement">Espressioni e statement</a></li>
<li><a href="#struttura-lessicale">Struttura lessicale</a></li>
</ul>
</li>
<li><a href="#tipi-di-dato-e-valori">Tipi di dato e valori</a>
<ul>
<li><a href="#immutabilità">Immutabilità</a></li>
<li><a href="#type-conversion">Type conversion</a></li>
<li><a href="#conversioni-esplicite">Conversioni esplicite</a></li>
<li><a href="#const-let-var">Const, let, var</a></li>
<li><a href="#assegnamenti-destrutturati">Assegnamenti destrutturati</a></li>
<li><a href="#null-e-undefined">Null e undefined</a></li>
<li><a href="#infinity-value">Infinity value</a></li>
<li><a href="#nan-not-a-number">NaN (Not a number)</a></li>
<li><a href="#il-global-object">Il Global object</a></li>
</ul>
</li>
<li><a href="#espressioni">Espressioni</a>
<ul>
<li><a href="#espressioni-primarie">Espressioni primarie</a></li>
<li><a href="#espressioni-di-inizializzazione-di-oggetti-e-array">Espressioni di Inizializzazione di oggetti e array</a></li>
<li><a href="#espressioni-di-definizione-di-funzioni">Espressioni di definizione di funzioni</a></li>
<li><a href="#espressioni-di-accesso-alle-proprietà">Espressioni di accesso alle proprietà</a></li>
<li><a href="#espressioni-di-invocazione">Espressioni di invocazione</a></li>
<li><a href="#espressioni-di-creazione-di-oggetti">Espressioni di creazione di oggetti</a></li>
<li><a href="#espressioni-di-valutazione-di-stringhe-eval">Espressioni di valutazione di stringhe (eval)</a></li>
</ul>
</li>
<li><a href="#operatori">Operatori</a>
<ul>
<li><a href="#numero-di-operandi">Numero di operandi</a></li>
<li><a href="#tipi-degli-operandi">Tipi degli operandi</a></li>
<li><a href="#precedenza-degli-operatori">Precedenza degli operatori</a></li>
<li><a href="#associatività">Associatività</a></li>
<li><a href="#tabella-degli-operatori">Tabella degli operatori</a></li>
</ul>
</li>
<li><a href="#statement">Statement</a>
<ul>
<li><a href="#for-of">for of</a></li>
<li><a href="#for-in">for in</a></li>
<li><a href="#etichettare-gli-statement">Etichettare gli statement</a></li>
<li><a href="#throw">throw</a></li>
<li><a href="#try-catch-finally">try-catch-finally</a></li>
</ul>
</li>
<li><a href="#oggetti">Oggetti</a>
<ul>
<li><a href="#creazione-degli-oggetti">Creazione degli oggetti</a></li>
<li><a href="#accesso-alle-proprietà">Accesso alle proprietà</a></li>
<li><a href="#creazione-delle-proprietà">Creazione delle proprietà</a></li>
<li><a href="#cancellazione-delle-proprietà">Cancellazione delle proprietà</a></li>
<li><a href="#estendere-oggetti">Estendere oggetti</a></li>
<li><a href="#serializzazione-degli-oggetti">Serializzazione degli oggetti</a></li>
<li><a href="#metodi-dell’oggetto-object">Metodi dell’oggetto Object</a></li>
<li><a href="#metodi">Metodi</a></li>
<li><a href="#getter-e-setter">Getter e setter</a></li>
</ul>
</li>
<li><a href="#array">Array</a>
<ul>
<li><a href="#creazione">Creazione</a></li>
<li><a href="#accesso-agli-elementi">Accesso agli elementi</a></li>
<li><a href="#proprietà-length">Proprietà length</a></li>
<li><a href="#aggiungere-e-rimuovere-elementi">Aggiungere e rimuovere elementi</a></li>
<li><a href="#iterare-gli-array">Iterare gli array</a></li>
<li><a href="#array-multidimensionali">Array multidimensionali</a></li>
<li><a href="#oggetti-array-like">Oggetti array-like</a></li>
</ul>
</li>
<li><a href="#funzioni">Funzioni</a>
<ul>
<li><a href="#definire-le-funzioni">Definire le funzioni</a></li>
<li><a href="#invocare-le-funzioni">Invocare le funzioni</a></li>
<li><a href="#argomenti-e-parametri">Argomenti e parametri</a></li>
<li><a href="#funzioni-come-valori">Funzioni come valori</a></li>
<li><a href="#funzioni-come-namespace">Funzioni come Namespace</a></li>
<li><a href="#chiusure">Chiusure</a></li>
</ul>
</li>
<li><a href="#classi">Classi</a>
<ul>
<li><a href="#primo-modo-factory-function">Primo modo: factory function</a></li>
<li><a href="#secondo-modo-costruttore">Secondo modo: costruttore</a></li>
<li><a href="#terzo-modo-keyword-class">Terzo modo: keyword class</a></li>
<li><a href="#metodi-statici">Metodi Statici</a></li>
<li><a href="#campi-di-una-classe">Campi di una classe</a></li>
<li><a href="#sottoclassi">Sottoclassi</a></li>
<li><a href="#differenze-tra-un-linguaggio-orientato-agli-oggetti-e-javascript">Differenze tra un linguaggio orientato agli oggetti e JavaScript</a></li>
</ul>
</li>
<li><a href="#iteratori-e-generatori">Iteratori e generatori</a>
<ul>
<li><a href="#come-funzionano-gli-iteratori">Come funzionano gli iteratori</a></li>
<li><a href="#creare-oggetti-iterabili">Creare oggetti iterabili</a></li>
<li><a href="#generatori">Generatori</a></li>
</ul>
</li>
<li><a href="#javascript-nel-browser">JavaScript nel browser</a>
<ul>
<li><a href="#javascript-in-html">JavaScript in HTML</a></li>
<li><a href="#dom">DOM</a></li>
<li><a href="#global-object">Global object</a></li>
<li><a href="#esecuzione-degli-script">Esecuzione degli script</a></li>
<li><a href="#eventi">Eventi</a></li>
<li><a href="#registrare-gli-event-listener">Registrare gli event listener</a></li>
<li><a href="#propagazione-degli-eventi-bubbling">Propagazione degli eventi (bubbling)</a></li>
<li><a href="#selezione-degli-elementi-html">Selezione degli elementi HTML</a></li>
<li><a href="#attraversamento-del-documento">Attraversamento del documento</a></li>
<li><a href="#manipolare-gli-attributi">Manipolare gli attributi</a></li>
<li><a href="#modificare-la-struttura-del-documento">Modificare la struttura del documento</a></li>
</ul>
</li>
<li><a href="#svg-e-canvas">SVG e canvas</a>
<ul>
<li><a href="#svg">SVG</a></li>
<li><a href="#canvas">Canvas</a></li>
<li><a href="#differenze-tra-svg-e-canvas">Differenze tra SVG e Canvas:</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="introduzione-a-javascript">Introduzione a JavaScript</h1>
<p>Javascript è un linguaggio <strong>interpretato <em>general purpose</em> ad alto livello non tipato</strong> principalmente utilizzato nel mondo web ma non solo, ambienti che interpretano JavaScript come Node.js permettono di utilizzare JavaScript anche fuori dai browser.</p>
<p>JavaScript di per sé definisce solo delle api base per gestire i tipi di dato come numeri, testi, array, insiemi ecc… Non include funzioni di <strong>input e output</strong>, infatti queste sono fornite dall’ambiente ospitante, che nel nostro caso è il browser (o in altri casi può essere Node.js).</p>
<h2 id="espressioni-e-statement">Espressioni e statement</h2>
<p>Le <strong>espressioni</strong> sono del testo che viene <strong>valutato</strong> per <strong>produrre un valore</strong> di qualche tipo.</p>
<p>Le espressioni più semplici sono i letterali (<em>literal)</em>, operazioni matematiche (es. somma, sottrazione), operazioni aritmetiche (es. pre e post incremento), operazioni di confronto (es. maggiore, uguale), operazioni logiche (and, or). Tutte queste operazioni vengono valutate per produrre un output: numerico, booleano, testuale, ecc…</p>
<p>A basso livello le espressioni vengono salvate a <em>runtime</em> nella memoria <em>heap</em> sottoforma di blocco <strong>indivisibile</strong> nella forma: ****<code>|Tipo|Valore|</code>. Ad esempio il letterale <code>5</code> verrà salvato come <code>|Number|5|</code>.</p>
<p>Quando si assegna una espressione ad una variabile, ad esempio <code>let myVar = 5</code>, viene inserita una nuova informazione composta da <code>|"myVar"|Number|5|</code> in un grande dizionario contenente altri dati dello stesso <em>scope.</em></p>
<p>Lo <strong>scope</strong> è il contesto (blocco di codice) in cui una variabile o una funzione è definita e accessibile.</p>
<p>Il fatto che il nome della variabile sia salvato come stringa non è banale, infatti è possibile fare modifiche al nome della variabile oppure decidere il nome della variabile a <em>runtime</em>.</p>
<p>Lo <strong>statement</strong> è del testo che non produce un valore, ma altera lo stato dell’esecuzione, esempi di statement includono i cicli (<code>for</code>, <code>while</code>), i blocchi condizionali (<code>if</code>, <code>else</code>), le istruzioni <code>return</code>, <code>throw</code>, gli assegnamenti e le dichiarazioni di variabili o funzioni.</p>
<h2 id="struttura-lessicale">Struttura lessicale</h2>
<p>Vediamo le regole lessicali degli elementi basilari di JavaScript.</p>
<p>JavaScript è <strong>case-sensitive</strong>, cioè distingue tra lettere maiuscole e minuscole, quindi keyword e identificatori che differiscono anche solo per l’uso di lettere maiuscole o minuscole sono considerati nomi distinti.</p>
<p>JavaScript generalmente ignora gli spazi, le <em>new line</em> e le tabulazioni.</p>
<p>Supporta due stili di <strong>commento</strong>:</p>
<ul>
<li>il commento in-line con i caratteri <code>//</code></li>
<li>il commento multi-line con i caratteri <code>/* */</code></li>
</ul>
<p>I <strong>letterali</strong> (o <em>literal</em>) sono dei valori direttamente scritti nel codice, si oppongono ai valori derivanti dall’esterno (input utente, input da sensori, input da API, ecc…)</p>
<p>Gli <strong>identificativi</strong>, che includono nomi di variabili, nomi di funzioni, constanti ecc… devono iniziare con una lettera oppure un <em>underscore</em> (_) oppure un dollaro ($). Non possono quindi iniziare con un numero e devono essere diversi da parole chiave riservate.</p>
<p>Come <em>naming convention</em> per nomi di variabili e funzioni si usa il camel-case.</p>
<p>L’utilizzo del punto e virgola (<code>;</code>) per indicare la fine di uno <em>statement</em> è <strong>opzionale</strong>, anche se con particolari stili di programmazione aiuta a disambiguare la fine degli statement. Generalmente (ma ci sono dei casi particolari) JavaScript tratta un accapo come un punto e virgola solo quando non riesce a parsare il codice a meno di aggiungere un ‘;’</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> a
a
<span class="token operator">=</span>
<span class="token number">3</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
</code></pre>
<p>Verrà interpretato da JavaScript come:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> a<span class="token punctuation">;</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>nonostante <code>a;</code> possa essere un valido statement, l’interprete cerca sempre di creare lo statement più grande che può.</p>
<p>Si possono creare situazioni inaspettate come con il seguente codice:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> y <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token function">f</span>
<span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
<p>Questo codice può essere interpretato correttamente sia come due righe distinte sia come una riga unica, il comportamento finale però è diverso.</p>
<p>Forse l’interpretazione pensata dallo sviluppatore è quella di due righe distinte ma l’interprete di JavaScript <em>parserà</em> il codice come segue:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> y <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>In generale è quindi consigliato l’uso del punto e virgola per evitare comportamenti inaspettati.</p>
<h1 id="tipi-di-dato-e-valori">Tipi di dato e valori</h1>
<p>I tipi di JavaScript possono essere divisi in due categorie:</p>
<ul>
<li><strong>Tipi primitivi</strong>: sono i tipi classici, quindi stringhe, numeri e boolean
<ul>
<li>Ci sono anche due valori speciali, <code>null</code> e <code>undefined</code> che fanno parte dei tipi primitivi</li>
</ul>
</li>
<li><strong>Tipi oggetto</strong> (o <em>reference type</em>): sono tipi più complessi, un oggetto possiamo immaginarlo come una collezione di proprietà dotate di nome e valore (ad esempio, <code>Set</code>, <code>Map</code>, <code>Error</code>, array, dizionari, …)
<ul>
<li>Anche <strong>funzioni</strong> e <strong>classi</strong> sono un particolare tipo di oggetto.</li>
</ul>
</li>
</ul>
<p>JavaScript ha un garbage collector integrato, quindi quando degli oggetti non sono più raggiungibili vengono deallocati automaticamente.</p>
<p>JavaScript supporta uno stile di programmazione orientato agli oggetti, sia i tipi primitivi che i tipi oggetto possono comportarsi come degli oggetti e quindi invocare dei metodi su di loro (<code>null</code> e <code>undefined</code> sono l’unica eccezione).</p>
<h2 id="immutabilità">Immutabilità</h2>
<p>In JavaScript, i tipi primitivi sono immutabili, mentre gli oggetti sono mutabili. Questo significa che i valori primitivi (numeri, stringhe, booleani, ecc.) non possono essere modificati direttamente. Se si desidera modificarne il valore, è necessario creare un nuovo valore e assegnarlo a una variabile.</p>
<p>Quindi ogni volta che viene invocato un metodo su una stringa quel metodo restituirà una nuova stringa e non modifica se stessa.</p>
<p>Al contrario, gli oggetti possono essere modificati direttamente, aggiornando o aggiungendo proprietà al loro stato.</p>
<h2 id="type-conversion">Type conversion</h2>
<p>La principale filosofia di JavaScript è quella di continuare l’esecuzione nonostante tutto, cercando di ridurre al minimo l’apparizione di errori. Una conseguenza di questa filosofia è la <em>type conversion</em> molto spinta che possiede il linguaggio.</p>
<p>JavaScript esegue delle conversioni di tipo in modo automatico, ad esempio se un programma si aspetta una stringa ma gli viene passato un intero, esso viene convertito autonomamente in stringa.</p>
<p>Gli <strong>operatori sono polimorfi</strong>, quindi cambiano il loro comportamento in base ai tipi. Un esempio è sommare una stringa ad un numero che genererà una stringa concatenata al numero (il quale è stato convertito in stringa)</p>
<p>Da qui nasce la differenza tra l’eguaglianza <strong>con</strong> <em>type conversion</em>, chiamata <em>equality</em> (<code>==</code>) e quella <strong>senza</strong>, chiamata <em>strict equality</em> (<code>===</code>).</p>
<p>L’operatore <code>==</code> esegue una conversione per “avvicinare” il più possibile i tipi tra loro e poi fa il confronto, questo comportamento può portare a risultati inaspettati.</p>
<p>Mentre l’operatore <code>===</code> esegue un confronto diretto sui tipi e sul valore (questo è il confronto voluto nella maggior parte dei casi).</p>
<p>Nota che anche <code>===</code> sugli oggetti effettua un confronto <em>shallow</em> sui riferimenti, non vengono confrontate le proprietà interne degli oggetti. In altre parole due oggetti con lo stesso numero di proprietà, che hanno gli stessi nomi e gli stessi valori possono essere comunque due oggetti differenti.</p>
<h3 id="valori-di-verità">Valori di verità</h3>
<p>Le <code>type conversion</code> considerano i seguenti valori come valore booleano <code>false</code>:</p>
<ul>
<li><code>false</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>0</code></li>
<li><code>-0</code></li>
<li><code>NaN</code></li>
<li><code>""</code></li>
</ul>
<p>Mentre tutti gli altri valori, inclusi gli oggetti, sono convertiti con il valore booleano <code>true</code>.</p>
<h2 id="conversioni-esplicite">Conversioni esplicite</h2>
<p>Nonostante il linguaggio cerchi il più possibile di fare delle conversioni in automatico, è comunque consigliato fare delle conversioni esplicite per ridurre la possibilità di errori non previsti e mantenere un codice più chiaro.</p>
<p>Ad esempio si possono usare i costrutti <code>Number(), String(), Boolean()</code> per fare delle conversioni oppure i metodi <code>parseInt()</code>, <code>parseFloat()</code>.</p>
<p>Tutti i valori tranne <code>null</code> e <code>undefined</code> possiedono il metodo <code>toString()</code> per fare la conversione a una stringa che li rappresenta in qualche modo.</p>
<p>Un altro metodo è <code>valueOf()</code> che ogni oggetto possiede e il cui scopo è quello di restituire un valore di tipo primitivo che rappresenti l’oggetto su cui è chiamato il metodo.</p>
<h2 id="const-let-var">Const, let, var</h2>
<p>Abbiamo tre <code>keyword</code> per dichiarare variabili e in nessuna di esse si specifica il tipo di dato, viene infatti determinato dall’interprete basandosi sulla sintassi dei valori che gli vengono assegnati.</p>
<ul>
<li><code>const</code> usato per dichiarare costanti nel blocco di scope più stretto racchiuso tra <code>{}</code>, definito <em><strong>block scope</strong></em>
<ul>
<li>Una variabile dichiarata <code>const</code> non può essere riassegnata.</li>
<li>Se la costante è un oggetto è comunque possibile modificare i suoi attributi interni (ad esempio negli array è possibile modificare i valori, aggiungere e togliere elementi ecc…).</li>
</ul>
</li>
<li><code>let</code> usato per dichiarare variabili nel blocco di scope più stretto racchiuso tra <code>{}</code>, definito <em><strong>block scope</strong></em>
<ul>
<li>Generalmente è il modo di dichiarazione preferito.</li>
</ul>
</li>
<li><code>var</code> usato per dichiarare variabili nello scope della funzione, chiamato <em><strong>function scope</strong></em>
<ul>
<li>Hanno un comportamento particolare detto <em>hoisting,</em> cioè vengono salvate nello scope come <code>undefined</code> prima di raggiungere la riga di dichiarazione, solamente quando l’esecuzione raggiunge la riga di dichiarazione allora la variabile assume il suo valore.</li>
</ul>
</li>
<li>Si può anche dichiarare variabili senza le keyword precedenti, semplicemente scrivendo il nome della variabile e assegnandogli un valore. In questo caso il suo scope sarà globale (anche se dichiarata all’interno di funzioni)</li>
</ul>
<h2 id="assegnamenti-destrutturati">Assegnamenti destrutturati</h2>
<p>JavaScript supporta gli assegnamenti destrutturati, cioè un particolare tipo di assegnamento in cui a destra dell’uguale si ha un tipo strutturato (ad esempio un array o un oggetto) e sinistra si hanno un insieme di variabili. Quello che accade è che il valore strutturato di destra viene scomposto in più parti che vengono assegnate alle singole variabili.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// Same as let x=1, y=2</span>
<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// Same as x = x + 1, y = y + 1</span>
<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>y<span class="token punctuation">,</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// Swap the value of the two variables</span>
<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span>                     <span class="token comment">// =&gt; [3,2]: the incremented and swapped values</span>
</code></pre>
<p>Questa tecnica può tornare utile sul valore di ritorno delle funzioni e sui <em>for-loop</em>.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>          <span class="token comment">// The object we'll loop over</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// Prints "x 1" and "y 2"</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Se si mettono troppe variabili a sinistra, esse verranno impostate ad <code>undefined</code>, mentre se sono troppo poche, i valori in eccedenza (a destra dell’assegnamento) più a destra verranno ignorati.</p>
<p>Si possono però raccogliere tutti i rimanenti valori in questo modo:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> <span class="token operator">...</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// y == [2,3,4]</span>
</code></pre>
<h2 id="null-e-undefined">Null e undefined</h2>
<p>Quando viene dichiarata una variabile senza assegnamento, assume il <strong>tipo e il valore</strong> <code>undefined</code>, che serve proprio a rappresentare la non inizializzazione. Quindi può essere interpretato come una mancanza di valore non prevista, o proprio un errore.</p>
<p>il valore <code>null</code> (che ha tipo <code>object</code>) invece rappresenta la mancanza intenzionale di un valore.</p>
<p>Entrambi sono codificati come valore booleano falso e sono valori distinti per l’operatore di uguaglianza <code>===</code>.</p>
<p>Su entrambi non è possibile invocare metodi.</p>
<h2 id="infinity-value">Infinity value</h2>
<p>Operazioni aritmetiche non sollevano eccezioni in caso di <em>overflow</em>, <em>underflow</em> e divisione per zero, piuttosto viene usato il valore speciale <code>Infinity</code> oppure <code>-Infinity</code>.</p>
<h2 id="nan-not-a-number">NaN (Not a number)</h2>
<p>In casi particolari come <code>0/0</code> e altre operazioni particolari che non hanno un valore definito e viene assegnato un <code>NaN</code> (<em>Not a Number</em>).</p>
<p>Una caratteristica particolare di <code>NaN</code> è l’impossibilità di essere comparato con altri valori, per controllare che una variabile sia <code>NaN</code> si usa il metodo <code>Number.isNaN()</code></p>
<h2 id="il-global-object">Il Global object</h2>
<p>Esiste un particolare oggetto chiamato <strong>Global object</strong>, è un regolare oggetto che possiede delle proprietà accessibili globalmente.</p>
<p>Quando si carica un sito web viene creato questo oggetto che contiene costanti come <code>NaN</code> e <code>Infinity</code>, funzioni globali, costruttori globali, e oggetti globali come <code>Math</code> e <code>JSON</code>.</p>
<p>Nei browser il global object è riferibile tramite la proprietà <code>window</code> oppure <code>globalThis</code></p>
<h1 id="espressioni">Espressioni</h1>
<p>Le <strong>espressioni</strong> sono dei pezzi di codice che possono essere valutati per produrre un valore.</p>
<h2 id="espressioni-primarie">Espressioni primarie</h2>
<p>Le espressioni primarie sono il tipo di espressioni più semplici che non includono sotto-espressioni, essi sono i <strong>letterali</strong>, cioè dei valori scritti direttamente nel codice dal programmatore.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token number">1.23</span>      <span class="token comment">// A number literal</span>
<span class="token string">"hello"</span>   <span class="token comment">// A string literal</span>
<span class="token boolean">true</span>      <span class="token comment">// Evalutes to the boolean true value</span>
<span class="token boolean">false</span>     <span class="token comment">// Evaluates to the boolean false value</span>
<span class="token keyword">null</span>      <span class="token comment">// Evaluates to the null value</span>
<span class="token keyword">this</span>      <span class="token comment">// Evaluates to the "current" object</span>
sum       <span class="token comment">// Evaluates to the value of the variable "sum" in the global object.</span>
undefined <span class="token comment">// The value of the "undefined" property of the global object</span>
</code></pre>
<h2 id="espressioni-di-inizializzazione-di-oggetti-e-array">Espressioni di Inizializzazione di oggetti e array</h2>
<p>Queste sono delle espressioni il cui valore ritornato è l’oggetto o l’array appena creato, spesso chiamati <em>object literals</em> e <em>array literals</em>. Non fanno parte delle espressioni primarie perché la loro creazione prevede delle sotto-espressioni per specificare proprietà e valori.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token punctuation">[</span><span class="token punctuation">]</span>             <span class="token comment">// An empty array: no expressions inside brackets means no elements</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">]</span>     <span class="token comment">// A 2-element array. First element is 3, second is 7</span>
<span class="token keyword">let</span> matrix <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// The element expressions in an array initializer can themselves be array initializers</span>

<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">2.3</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1.2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">// An object with 2 properties</span>
<span class="token keyword">let</span> q <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                    <span class="token comment">// An empty object with no properties</span>
q<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">2.3</span><span class="token punctuation">;</span>
q<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1.2</span><span class="token punctuation">;</span>                    <span class="token comment">// Now q has the same properties as p</span>

<span class="token keyword">let</span> rectangle <span class="token operator">=</span> <span class="token punctuation">{</span>              <span class="token comment">// Object literals can be nested.</span>
 upperLeft<span class="token punctuation">:</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
 lowerRight<span class="token punctuation">:</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">5</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="espressioni-di-definizione-di-funzioni">Espressioni di definizione di funzioni</h2>
<p>Come per gli oggetti e gli array, anche quando creiamo una funzione possiamo definirla una <em>function literals</em>, in quanto la definizione di una funzione produce un valore che è la funzione stessa.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> <span class="token function-variable function">square</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>In questo caso la funzione è una variabile e verrà definita quando l’interprete giunge alla riga di codice corrispondente.</p>
<p>Diverso è il comportamento dello <em>statement</em> di creazione di funzione:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">function</span> <span class="token function">square</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">:</span><span class="token punctuation">}</span>
</code></pre>
<p>in questo caso si ha il fenomeno di <em>hoisting,</em> cioè la funzione viene creata ancora prima di iniziare lo script nel quale è definita.</p>
<h2 id="espressioni-di-accesso-alle-proprietà">Espressioni di accesso alle proprietà</h2>
<p>Queste espressioni ritornano un valore corrispondente ad una proprietà di un oggetto oppure ad un elemento di un array.</p>
<p>Ci sono due sintassi per l’accesso alle proprietà:</p>
<pre class=" language-jsx"><code class="prism  language-jsx">expression<span class="token punctuation">.</span>identifier   <span class="token comment">// first style</span>
expression<span class="token punctuation">[</span>expression<span class="token punctuation">]</span>  <span class="token comment">// second style</span>
</code></pre>
<p>Nel primo stile, l’<em>expression</em> specifica l’oggetto mentre l’<em>identifier</em> specifica il nome della proprietà.</p>
<p>Nel secondo stile, la prima <em>expression</em> specifica l’oggetto o l’array, e la seconda <em>expression</em> specifica la proprietà dell’oggetto (usando una stringa) o l’indice dell’array (usando un intero)</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token punctuation">{</span>z<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// An example object</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span>o<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// An example array that contains the object</span>

o<span class="token punctuation">.</span>x                        <span class="token comment">// =&gt; 1: property x of expression o</span>
o<span class="token punctuation">.</span>y<span class="token punctuation">.</span>z                      <span class="token comment">// =&gt; 3: property z of expression o.y</span>
o<span class="token punctuation">[</span><span class="token string">"x"</span><span class="token punctuation">]</span>                     <span class="token comment">// =&gt; 1: property x of object o</span>
a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                       <span class="token comment">// =&gt; 4: element at index 1 of expression a</span>
a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">]</span>                  <span class="token comment">// =&gt; 6: element at index 1 of expression a[2]</span>
a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x                     <span class="token comment">// =&gt; 1: property x of expression a[0]</span>
</code></pre>
<p>Se si accede ad una proprietà che non esiste verrà restituito un <code>undefined.</code></p>
<h3 id="accessi-condizionali-alle-proprietà">Accessi condizionali alle proprietà</h3>
<p>Nelle ultime versioni di JS sono stati aggiunti due nuovi modi di accedere alle proprietà, chiamati <strong>accessi condizionali</strong>:</p>
<pre class=" language-jsx"><code class="prism  language-jsx">expression<span class="token operator">?</span><span class="token punctuation">.</span>identifier
expression<span class="token operator">?</span><span class="token punctuation">.</span><span class="token punctuation">[</span>expression<span class="token punctuation">]</span>
</code></pre>
<p>Se l’accesso alle proprietà diretto (quello visto precedentemente, senza <code>?</code>) viene tentato sui valori <code>null</code> e <code>undefined</code> verrà lanciato un <code>TypeError</code>, gli accessi condizionali prevengono questo comportamento.</p>
<p>Nell’espressione <code>a?.b</code> se <code>a</code> è <code>null</code> oppure <code>undefined</code>, l’espressione viene valutata come <code>undefined</code> senza tentare di accedere alla proprietà <code>b</code> (evitando quindi di lanciare il <code>TypeError</code>), se invece <code>a</code> è un qualche altro valore allora il comportamento è il medesimo dell’accesso diretto.</p>
<p>Vediamo un particolare comportamento concatenando gli accessi:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> b<span class="token punctuation">:</span> <span class="token keyword">null</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span>b                 <span class="token comment">// =&gt; null</span>
a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c               <span class="token comment">// =&gt; TypeError</span>
a<span class="token punctuation">.</span>b<span class="token operator">?</span><span class="token punctuation">.</span>c              <span class="token comment">// =&gt; undefined</span>
<span class="token punctuation">(</span>a<span class="token punctuation">.</span>b<span class="token operator">?</span><span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span>d          <span class="token comment">// =&gt; TypeError</span>
a<span class="token punctuation">.</span>b<span class="token operator">?</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span>d            <span class="token comment">// =&gt; undefined</span>
</code></pre>
<p>Nota come appena si ha <code>null</code> o <code>undefined</code> sinistra dell’operatore <code>?.</code> viene fatto un “corto-circuito” e viene subito valutata l’espressione come <code>undefined</code> senza proseguire con la valutazione.</p>
<p>Il comportamento è del tutto analogo con l’operatore <code>?.[]</code>:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> a<span class="token punctuation">;</span>             <span class="token comment">// Oops, we forgot to initialize this variable!</span>
<span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
   a<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// Throws TypeError</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   index           <span class="token comment">// =&gt; 1: increment occurs before TypeError is thrown</span>
<span class="token punctuation">}</span>
a<span class="token operator">?</span><span class="token punctuation">.</span><span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span>       <span class="token comment">// =&gt; undefined: because a is undefined</span>
index              <span class="token comment">// =&gt; 1: not incremented because ?.[] short-circuits</span>
</code></pre>
<h2 id="espressioni-di-invocazione">Espressioni di invocazione</h2>
<p>Questo tipo di espressione è data dall’invocazione di un metodo o una funzione:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>               <span class="token comment">// f is the function expression; 0 is the argument expression.</span>
Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span>    <span class="token comment">// Math.max is the function; x, y, and z are the arguments.</span>
a<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token comment">// a.sort is the function; there are no arguments.</span>
</code></pre>
<p>Il valore generato dall’invocazione sarà il valore di ritorno della funzione, se non presente allora sarà <code>undefined</code>.</p>
<h3 id="invocazione-condizionale">Invocazione condizionale</h3>
<p>Come per l’accesso alle proprietà anche per le funzioni esiste una invocazione condizionale con la sintassi <code>?.()</code>.</p>
<p>In questo caso se l’espressione a sinistra dell’operatore <code>?.()</code> è <code>null</code> oppure <code>undefined</code> al posto di essere lanciato un <code>TypeError</code>, l’intera invocazione viene valutata come <code>undefined:</code></p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">function</span> <span class="token function">square</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> log<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// The second argument is an optional function</span>
   log<span class="token operator">?</span><span class="token punctuation">.</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// Call the function if there is one</span>
   <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>          <span class="token comment">// Return the square of the argument</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="espressioni-di-creazione-di-oggetti">Espressioni di creazione di oggetti</h2>
<p>Queste espressioni sono provocate dalla creazione di nuovi oggetti tramite l’invocazione di un particolare metodo chiamato <em>costruttore</em>.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
</code></pre>
<p>Il valore generato dall’espressione è l’oggetto appena creato.</p>
<h2 id="espressioni-di-valutazione-di-stringhe-eval">Espressioni di valutazione di stringhe (eval)</h2>
<p>JavaScript ha la possibilità di interpretare delle stringhe come del codice, valutandolo e producendo di conseguenza un valore.</p>
<p>Questo viene fatto attraverso la funzione globale <code>eval()</code></p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"5*3"</span> <span class="token punctuation">)</span>  <span class="token comment">// =&gt; 15 </span>
</code></pre>
<p>La funzione prende in input una stringa e tenta di fare un parsing in codice JavaScript, se ci riesce esegue poi il codice e ritorna l’ultima espressione (oppure <code>undefined</code>).</p>
<p>Il codice passato ad eval, può fare riferimento al codice locale JavaScript scritto in precedenza, permettendo così di leggere valori e anche modificarli.</p>
<p>L’uso di questa funzione può rappresentare un problema di sicurezza se si passa una stringa proveniente dallo user input in quanto è difficile sanitizzare completamente l’input.</p>
<p>Molti siti infatti utilizzano “Content-Security-Policy” nell’header HTTP per disabilitare l’uso della funzione <code>eval()</code>.</p>
<h1 id="operatori">Operatori</h1>
<p>Il modo più comune per creare delle espressioni complesse è tramite l’utilizzo di <strong>operatori</strong>, cioè dei simboli che operano su dei valori e ne producono uno nuovo.</p>
<p>Gli operatori sono utilizzati per: espressioni aritmetiche, espressioni di confronto, espressioni logiche, espressioni di assegnamento, ecc…</p>
<p>Molti operatori sono rappresentati con simboli particolari (<code>+</code>, <code>=</code>, <code>&gt;</code>, …), altri con delle <em>keyword</em> specifiche (<code>delete</code>, <code>instanceof</code>, …)</p>
<p>Analizziamo degli aspetti importanti che riguardano gli operatori.</p>
<h2 id="numero-di-operandi">Numero di operandi</h2>
<p>Gli operatori si possono categorizzare in base al numero di operandi su cui lavorano. La maggior parte degli operatori sono <strong>operatori binari</strong>, cioè che lavorano su due operandi. Ci sono anche <strong>operatori unari</strong> (<code>!</code> (<em>not</em> logico), <code>-</code> (simbolo di negazione), <code>++</code>, <code>--</code>, <code>typeof</code>) e un <strong>operatore ternario</strong> (<code>condizione ? valore_se_vero : valore_se_falso</code>)</p>
<h2 id="tipi-degli-operandi">Tipi degli operandi</h2>
<p>Alcuni operatori accettano un tipo di operandi qualsiasi, altri vogliono dei tipi particolari.</p>
<p>JavaScript tenta sempre di convertire un tipo sbagliato nel tipo che si aspetta.</p>
<p>Alcuni operatori però sono polimorfi, cioè si comportano in modo differente in base al tipo degli operatori (ad esempio l’operatore <code>+</code> può fare somma tra due numeri oppure la concatenazione tra stringhe)</p>
<h2 id="precedenza-degli-operatori">Precedenza degli operatori</h2>
<p>Quando si concatenano più operatori, essi hanno una priorità di valutazione, ad esempio in espressioni aritmetiche la precedenza degli operatori e la classica precedenza matematica.</p>
<p>L’operatore di assegnamento tendenzialmente ha la priorità più bassa.</p>
<p>L’uso delle parentesi tonde può forzare la precedenza degli operatori.</p>
<p><strong>L’accesso a proprietà, l’accesso a elementi di array e le invocazioni di funzioni hanno un priorità più alta di tutti gli operatori.</strong></p>
<h2 id="associatività">Associatività</h2>
<p>L’associatività descrive l’ordine di esecuzione con operatori di uguale priorità.</p>
<p>Possiamo avere una associatività <em>Left-to-right</em> oppure <em>Right-to-left.</em></p>
<p>Ad esempio:</p>
<pre class=" language-jsx"><code class="prism  language-jsx">w <span class="token operator">=</span> x <span class="token operator">-</span> y <span class="token operator">-</span> z<span class="token punctuation">;</span>    <span class="token comment">// Left-to-right: w = ((x - y) - z)</span>
w <span class="token operator">=</span> x <span class="token operator">&amp;&amp;</span> y <span class="token operator">&amp;&amp;</span> z<span class="token punctuation">;</span>  <span class="token comment">// Left-to-right: w = ((x &amp;&amp; y) &amp;&amp; z)</span>

w <span class="token operator">=</span> a <span class="token operator">**</span> b <span class="token operator">**</span> c<span class="token punctuation">;</span>  <span class="token comment">// Right-to-left: w = (a ** (b ** c))</span>
w <span class="token operator">=</span> x <span class="token operator">=</span> y <span class="token operator">=</span> z<span class="token punctuation">;</span>    <span class="token comment">// Right-to-left: w = (x = (y = z));</span>
</code></pre>
<h2 id="tabella-degli-operatori">Tabella degli operatori</h2>

<table>
<thead>
<tr>
<th>Simbolo</th>
<th>Operazione</th>
<th>Associatività</th>
<th>Esempio</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+</code></td>
<td>Addizione o concatenazione di stringhe</td>
<td>Left-to-right</td>
<td><code>3 + 2 // 5</code>, <code>'a' + 'b' // 'ab'</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>Sottrazione</td>
<td>Left-to-right</td>
<td><code>3 - 2 // 1</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>Moltiplicazione</td>
<td>Left-to-right</td>
<td><code>3 * 2 // 6</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td>Divisione</td>
<td>Left-to-right</td>
<td><code>6 / 2 // 3</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td>Modulo (resto della divisione)</td>
<td>Left-to-right</td>
<td><code>5 % 2 // 1</code></td>
</tr>
<tr>
<td><code>**</code></td>
<td>Esponenziale</td>
<td>Right-to-left</td>
<td><code>2 ** 3 // 8</code></td>
</tr>
<tr>
<td><code>++</code></td>
<td>Incremento</td>
<td>Right-to-left</td>
<td><code>let a = 1; a++ // a = 2</code></td>
</tr>
<tr>
<td><code>--</code></td>
<td>Decremento</td>
<td>Right-to-left</td>
<td><code>let a = 2; a-- // a = 1</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>Negazione unaria</td>
<td>Right-to-left</td>
<td><code>-5 // -5</code></td>
</tr>
<tr>
<td><code>+</code></td>
<td>Conversione in numero</td>
<td>Right-to-left</td>
<td><code>+"5" // 5</code></td>
</tr>
<tr>
<td><code>!</code></td>
<td>Negazione logica</td>
<td>Right-to-left</td>
<td><code>!true // false</code></td>
</tr>
<tr>
<td><code>~</code></td>
<td>Complemento a uno (NOT bit a bit)</td>
<td>Right-to-left</td>
<td><code>~5 // -6</code></td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>AND logico</td>
<td>Left-to-right</td>
<td><code>true &amp;&amp; false // false</code></td>
</tr>
<tr>
<td><code>||</code></td>
<td>OR logico</td>
<td>Left-to-right</td>
<td><code>true || false // true</code></td>
</tr>
<tr>
<td><code>??</code></td>
<td>sceglie il primo operando definito</td>
<td>Left-to-right</td>
<td><code>null ?? 'default' // 'default'</code></td>
</tr>
<tr>
<td><code>?:</code></td>
<td>Operatore ternario (condizionale)</td>
<td>Right-to-left</td>
<td><code>true ? 'yes' : 'no' // 'yes'</code></td>
</tr>
<tr>
<td><code>,</code></td>
<td>Valuta ogni operando e restituisce il risultato dell’ultimo</td>
<td>Left-to-right</td>
<td><code>let a = 1, 2; // a = 2</code></td>
</tr>
<tr>
<td><code>=</code></td>
<td>Assegnazione</td>
<td>Right-to-left</td>
<td><code>a = 5 // a = 5</code></td>
</tr>
<tr>
<td><code>+=</code></td>
<td>Assegnazione con addizione</td>
<td>Right-to-left</td>
<td><code>a += 5 // a = a + 5</code></td>
</tr>
<tr>
<td><code>-=</code></td>
<td>Assegnazione con sottrazione</td>
<td>Right-to-left</td>
<td><code>a -= 5 // a = a - 5</code></td>
</tr>
<tr>
<td><code>*=</code></td>
<td>Assegnazione con moltiplicazione</td>
<td>Right-to-left</td>
<td><code>a *= 5 // a = a * 5</code></td>
</tr>
<tr>
<td><code>/=</code></td>
<td>Assegnazione con divisione</td>
<td>Right-to-left</td>
<td><code>a /= 5 // a = a / 5</code></td>
</tr>
<tr>
<td><code>%=</code></td>
<td>Assegnazione con modulo</td>
<td>Right-to-left</td>
<td><code>a %= 5 // a = a % 5</code></td>
</tr>
<tr>
<td><code>**=</code></td>
<td>Assegnazione con esponenziale</td>
<td>Right-to-left</td>
<td><code>a **= 2 // a = a ** 2</code></td>
</tr>
<tr>
<td><code>==</code></td>
<td>Uguaglianza debole (con conversione di tipo)</td>
<td>Left-to-right</td>
<td><code>5 == '5' // true</code></td>
</tr>
<tr>
<td><code>===</code></td>
<td>Uguaglianza stretta (senza conversione di tipo)</td>
<td>Left-to-right</td>
<td><code>5 === '5' // false</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td>Diversità debole</td>
<td>Left-to-right</td>
<td><code>5 != '5' // false</code></td>
</tr>
<tr>
<td><code>!==</code></td>
<td>Diversità stretta</td>
<td>Left-to-right</td>
<td><code>5 !== '5' // true</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>Maggiore di</td>
<td>Left-to-right</td>
<td><code>5 &gt; 3 // true</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>Minore di</td>
<td>Left-to-right</td>
<td><code>3 &lt; 5 // true</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>Maggiore o uguale</td>
<td>Left-to-right</td>
<td><code>5 &gt;= 5 // true</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>Minore o uguale</td>
<td>Left-to-right</td>
<td><code>5 &lt;= 3 // false</code></td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>AND bit a bit</td>
<td>Left-to-right</td>
<td><code>5 &amp; 1 // 1</code></td>
</tr>
<tr>
<td><code>|</code></td>
<td>OR bit a bit</td>
<td>Left-to-right</td>
<td><code>5 | 1 // 5</code></td>
</tr>
<tr>
<td><code>^</code></td>
<td>XOR bit a bit</td>
<td>Left-to-right</td>
<td><code>5 ^ 1 // 4</code></td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>Shift a sinistra</td>
<td>Left-to-right</td>
<td><code>5 &lt;&lt; 1 // 10</code></td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>Shift a destra</td>
<td>Left-to-right</td>
<td><code>5 &gt;&gt; 1 // 2</code></td>
</tr>
<tr>
<td><code>&gt;&gt;&gt;</code></td>
<td>Shift a destra con estensione di zeri</td>
<td>Left-to-right</td>
<td><code>-5 &gt;&gt;&gt; 1 // 2147483645</code></td>
</tr>
<tr>
<td><code>in</code></td>
<td>Verifica se una proprietà è in un oggetto, o se un indice è in un array</td>
<td>Left-to-right</td>
<td><code>'length' in [] // true</code></td>
</tr>
<tr>
<td><code>instanceof</code></td>
<td>Verifica se un oggetto è istanza di una funzione costruttore di una classe</td>
<td>Left-to-right</td>
<td><code>[] instanceof Array // true</code></td>
</tr>
<tr>
<td><code>typeof</code></td>
<td>Restituisce il tipo di una variabile</td>
<td>Right-to-left</td>
<td><code>typeof 42 // 'number'</code></td>
</tr>
<tr>
<td><code>delete</code></td>
<td>Elimina una proprietà da un oggetto o un elemento di un array (negli array viene lasciato un “buco”, non cambia la dimensione dell’array)</td>
<td>Right-to-left</td>
<td><code>delete obj.key // true</code></td>
</tr>
</tbody>
</table><h1 id="statement">Statement</h1>
<p>Gli statement, non producono un valore ma servono a eseguire un determinato comportamento.</p>
<p>Alcune espressioni che hanno dei <em>side effect</em> sono ritenute essere anche degli statement, l’assegnamento ne è un esempio.</p>
<p>Gli statement più comuni sono quelli che modificano il normale flusso di esecuzione del codice:</p>
<ul>
<li><code>if</code> e <code>switch</code></li>
<li><code>while</code> e <code>for</code></li>
<li><code>break</code>, <code>return</code> e <code>throw</code></li>
</ul>
<p>Gli statement terminano con un <code>;</code>. È possibili racchiudere più statement in un blocco racchiuso tra parentesi graffe in modo che risulti uno statement unico:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token punctuation">{</span>
 x <span class="token operator">=</span> Math<span class="token punctuation">.</span>PI<span class="token punctuation">;</span>
 cx <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">cos</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"cos(π) = "</span> <span class="token operator">+</span> cx<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Questo viene utilizzano nelle istruzioni come <code>if</code> e cicli, i quali richiedono un singolo statatement, cosicché noi possiamo eseguire più sotto-statement in un singolo statement.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">if</span> <span class="token punctuation">(</span>expression<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//statement1 which is a statement block</span>
	sub<span class="token operator">-</span>statement1<span class="token punctuation">;</span>
	sub<span class="token operator">-</span>statement2<span class="token punctuation">;</span>
	sub<span class="token operator">-</span>statement3<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
 statement2
</code></pre>
<p>Possiamo avere anche uno statement vuoto:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token punctuation">;</span>
</code></pre>
<p>che può essere utilizzato ad esempio in cicli senza un <em>body</em>:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token comment">// Initialize an array a</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
</code></pre>
<h2 id="for-of">for of</h2>
<p>Il <code>for of</code> è un particolare tipo di ciclo for che torna utile con oggetti iterabili (come array, stringhe, mappe, insiemi, …) per ottenere i <strong>valori</strong> contenuti in tali oggetti.</p>
<h3 id="utilizzo-con-array">Utilizzo con array</h3>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> element <span class="token keyword">of</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   sum <span class="token operator">+=</span> element<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
sum        <span class="token comment">// =&gt; 45</span>
</code></pre>
<p>Ad ogni iterazione un elemento dell’oggetto <code>data</code> viene inserito nella variabile <code>element</code>.</p>
<p>Il valore che viene scelto dipende dall’implementazione dell’iteratore, negli array vengono scelti in ordine dall’indice minore all’indice maggiore.</p>
<p>Gli array sono iterati al momento, cioè se all’interno del ciclo appendiamo elementi all’array possiamo andare in loop infinito.</p>
<h3 id="utilizzo-con-oggetti">Utilizzo con oggetti</h3>
<p>Gli oggetti non sono iterabili di default, tentare di utilizzare un <code>for of</code> risulterà in un <code>TypeError</code>.</p>
<p>In alternativa si può utilizzare un metodo globale <code>Object.keys(obj)</code> su cui iterare:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> z<span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> keys <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   keys <span class="token operator">+=</span> k<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
keys <span class="token comment">// =&gt; "xyz"</span>
</code></pre>
<p><code>Object.keys(obj)</code> ritorna un array contenente i nomi delle proprietà dell’oggetto passato come parametro. Diversamente dagli array, in questo caso non viene iterato al momento, quindi aggiungere delle proprietà durante il ciclo non incide sull’iterazione.</p>
<p>Inoltre si può iterare sui valori dell’oggetto usando <code>Object.values(obj)</code>:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> z<span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   sum <span class="token operator">+=</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
sum <span class="token comment">// =&gt; 6</span>
</code></pre>
<p>Se invece si è interessati ad iterare le coppie chiave-valore si può utilizzare <code>Object.entries(obj)</code>:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> z<span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> pairs <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>k<span class="token punctuation">,</span> v<span class="token punctuation">]</span> <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 pairs <span class="token operator">+=</span> k <span class="token operator">+</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
pairs <span class="token comment">// =&gt; "x1y2z3"</span>
</code></pre>
<h2 id="for-in">for in</h2>
<p>Il <code>for in</code> è un particolare tipo di ciclo for che torna utili con oggetti anche non iterabili.</p>
<p>Il funzionamento è simile al <code>for of</code> ma questo ciclo itera attraverso le <strong>proprietà</strong> di un oggetto (tranne quelle marcate come non <code>enumerable</code>).</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> p <span class="token keyword">in</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// Assign property names of o to variable p</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Print the value of each property</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Ad esempio possiamo inserire in un array tutti i nomi delle proprietà di un oggetto</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> z<span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token keyword">in</span> o<span class="token punctuation">)</span> <span class="token punctuation">;</span>
</code></pre>
<p>Gli array sono un particolare tipo di oggetto, quindi si può usare <code>for in</code> anche su di loro, ottenendo così gli indici dell’array (e non i suoi valori, per quello va usato <code>for of</code>)</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> index <span class="token keyword">in</span> a<span class="token punctuation">)</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//0 1 2</span>
   
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> element <span class="token keyword">of</span> a<span class="token punctuation">)</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// x y z</span>
</code></pre>
<h2 id="etichettare-gli-statement">Etichettare gli statement</h2>
<p>È possibile dare dei nomi (<em>label</em>) agli statement, ovviamente non è molto sensato dare nomi a statement singoli ma piuttosto a blocchi di statement.</p>
<pre class=" language-jsx"><code class="prism  language-jsx">mainloop<span class="token punctuation">:</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>token <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	 <span class="token comment">// ...</span>
	 <span class="token keyword">continue</span> mainloop<span class="token punctuation">;</span> <span class="token comment">// Jump to the next iteration of the named loop</span>
	 <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Può essere utile dare nomi ai cicli quando ci sono dei cicli innestati e si vogliono utilizzare istruzioni come <code>break</code> o <code>continue</code> in riferimento al ciclo più esterno:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token comment">// Label for the outer loop</span>
outerLoop<span class="token punctuation">:</span> 
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span> outerLoop<span class="token punctuation">;</span> <span class="token comment">// Exits both the inner and outer loop</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="throw">throw</h2>
<p>lo statement <code>throw</code> ha la seguente sintassi</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">throw</span> expression<span class="token punctuation">;</span>
</code></pre>
<p>Viene utilizzato per segnalare l’accadimento di un errore o una eccezione.</p>
<p>L’espressione lanciata può essere di qualsiasi tipo, da un numero che identifica l’errore ad una stringa che lo descrive.</p>
<p>JavaScript lancia degli errori automaticamente quando ne incontra uno e in particolare lancia oggetti appartenenti alla classe <code>Error</code>.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">function</span> <span class="token function">factorial</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	 <span class="token comment">// If the input argument is invalid, throw an exception!</span>
	 <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"x must not be negative"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	 
	 <span class="token comment">// Otherwise, compute a value and return normally</span>
	 <span class="token keyword">let</span> f<span class="token punctuation">;</span>
	 <span class="token keyword">for</span> <span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> x <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span> f <span class="token operator">*=</span> x<span class="token punctuation">,</span> x<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
	 <span class="token keyword">return</span> f<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">// =&gt; 24</span>
</code></pre>
<p>Quando viene fatto un <code>throw</code>, il normale flusso di esecuzione viene interrotto, e l’interprete salta al più vicino gestore di eccezioni.</p>
<p>I gestori di eccezioni vengono creati con il costrutto <code>try-catch-finally</code>.</p>
<h2 id="try-catch-finally">try-catch-finally</h2>
<p>il costrutto <code>try-catch-finally</code> serve per gestire le eccezioni:</p>
<ul>
<li>il blocco <code>try</code> definisce un insieme di statement dove può verificarsi un errore.</li>
<li>il blocco <code>catch</code> è il codice che viene eseguito nel caso l’errore si verificasse.</li>
<li>il blocco <code>finally</code> contiene del codice di pulizia che viene eseguito indipendentemente dal verificarsi dell’errore</li>
</ul>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">try</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre>
<p>In combinazione con il codice del fattoriale precedente possiamo scrivere questo codice:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">try</span> <span class="token punctuation">{</span>
		 <span class="token comment">// Ask the user to enter a number</span>
		 <span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span><span class="token function">prompt</span><span class="token punctuation">(</span><span class="token string">"Please enter a positive integer"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		 <span class="token comment">// Compute the factorial of the number, assuming the	input is valid</span>
		 <span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
		 <span class="token function">alert</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token string">"! = "</span> <span class="token operator">+</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Display the result</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// If the user's input was not valid, we end up here</span>
	   <span class="token function">alert</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Tell the user what the error is</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Si può mettere opzionalmente delle parentesi con un identificatore dopo il <code>catch</code> (nell’esempio è <code>ex</code>), questo identificatore conterrà l’errore.</p>
<h1 id="oggetti">Oggetti</h1>
<p>Gli oggetti in JavaScript sono una collezioni non ordinata di proprietà, in altre parole un <strong>dizionario</strong> (coppie chiave-valore, con chiavi univoche).</p>
<p>Le proprietà sono valori primitivi, altri oggetti, oppure metodi.</p>
<p>Un oggetto può ereditare delle proprietà da un altro oggetto, quest’ultimo viene chiamato il suo <strong>prototipo</strong> (<em>prototype</em>), quando un oggetto eredità delle proprietà di un altro oggetto si parla di <em><strong>prototypal inheritance</strong></em>.</p>
<p>È possibile ottenere il prototipo di un oggetto in questi modi:</p>
<ul>
<li><code>&lt;Object&gt;.prototype</code> : da usare con le classi</li>
<li><code>Object.getPrototypeOf(&lt;obj&gt;)</code>: da usare con gli oggetti</li>
<li><code>&lt;obj&gt;.__proto__</code> (deprecato)</li>
</ul>
<p>È possibile verificare il <em>prototype</em> di un oggetto con il metodo <code>isPrototypeOf()</code> ad esempio:<br>
<code>&lt;Object&gt;.prototype.isPrototypeOf(&lt;obj&gt;)</code></p>
<p>Gli oggetti sono:</p>
<ul>
<li><strong>dinamici:</strong> è quindi possibile aggiungere e rimuovere proprietà</li>
<li><strong>mutabili</strong>: è possibile modificare i valori al suo interno senza bisogno di creare un nuovo oggetto</li>
<li><strong>Sono manipolati per reference</strong> (shallow copy): assegnare un oggetto copia il suo riferimento, non fa un copia dei valori dell’oggetto.</li>
</ul>
<p>Le proprietà di un oggetto possono avere degli attributi:</p>
<ul>
<li><code>writable</code>: specifica se la proprietà può essere modificata</li>
<li><code>enumerable</code>: specifica se la proprietà può apparire all’interno di un ciclo <code>for-in</code> e se può essere restituita dalla chiamata a <code>Object.keys()</code></li>
<li><code>configurable</code>: specifica se la proprietà può essere eliminata e se si possono modificare i suoi attributi</li>
</ul>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
	age <span class="token operator">=</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token comment">//proprietà 'age' come writable, configurable ed enumerable</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Definisco la proprietà 'nome' come writable, configurable e non-enumerable</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  value<span class="token punctuation">:</span> <span class="token string">'Mario'</span><span class="token punctuation">,</span>
  writable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Nota: di default gli attributi delle proprietà create direttamente con la creazione dell’oggetto sono tutti impostati a <code>true</code>. Mentre gli attributi delle proprietà definite con il metodo <code>Object.defineProperty()</code> sono impostate di default a <code>false</code>.</p>
<h2 id="creazione-degli-oggetti">Creazione degli oggetti</h2>
<p>Gli oggetti possono essere creati in tre modi: con un oggetto letterale (<em>object literal</em>), con la <code>new</code> keyword e con il metodo <code>Object.create()</code></p>
<h3 id="object-literal">Object literal</h3>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> empty <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// An object with no properties</span>
<span class="token keyword">let</span> point <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// Two numeric properties</span>
<span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> point<span class="token punctuation">.</span>x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> point<span class="token punctuation">.</span>y<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// More complex values</span>
</code></pre>
<p>Tutti gli oggetti creati in questo modo avranno come <strong>prototype</strong> il prototipo dell’oggetto Object, in particolare <code>Object.prototype</code>.</p>
<h3 id="new-operator">new operator</h3>
<p>Si crea un oggetto con la keyword <code>new</code> seguita dall’invocazione di un costruttore.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Create an empty object: same as {}.</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Create an empty array: same as [].</span>
<span class="token keyword">let</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Create a Date object representing the current time</span>
<span class="token keyword">let</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">;</span> <span class="token comment">// same as the previous line</span>
</code></pre>
<p>Nota: non è obbligatorio usare le parentesi tonde se il costruttore non richiede parametri.</p>
<p>Tutti gli oggetti creati in questo modo avranno come <strong>prototype</strong> il prototipo del costruttore, ad esempio<code>Object.prototype</code> per l’oggetto <code>o</code>, <code>Array.prototype</code> per l’oggetto <code>a</code> e <code>Date.prototype</code> per l’oggetto <code>d</code>.</p>
<p>Nota che esiste la cosi detta <em><strong>prototype chain</strong></em>, infatti tutti gli oggetti ereditano da <code>Object.prototype</code> e a loro volta possono estendere tale prototipo formando una catena di prototipi.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token keyword">extends</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Baz</span> <span class="token keyword">extends</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> baz <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// prototype chains:</span>
<span class="token comment">// foo: Foo --&gt; Object</span>
<span class="token comment">// bar: Bar --&gt; Foo --&gt; Object</span>
<span class="token comment">// baz: Baz --&gt; Bar --&gt; Foo --&gt; Object</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Baz<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>baz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Baz<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Baz<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Bar<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>baz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Bar<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>baz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>baz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre>
<h3 id="metodo-object.create">Metodo Object.create()</h3>
<p>In questo modo è possibile creare un nuovo oggetto specificando un prototipo da cui ereditare proprietà e metodi.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> o1 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// o1 inherits properties x and y.</span>
o1<span class="token punctuation">.</span>x <span class="token operator">+</span> o1<span class="token punctuation">.</span>y <span class="token comment">// =&gt; 3</span>
</code></pre>
<p>è possibile passare <code>null</code>, in questo caso si avrà un oggetto che non eredita nulla, nemmeno il prototipo di <code>Object</code>.</p>
<p>Alternativamente possiamo creare un oggetto come si farebbe con <code>{}</code> oppure <code>new Object()</code></p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> o3 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// o3 is like {} or new Object().</span>
</code></pre>
<h2 id="accesso-alle-proprietà">Accesso alle proprietà</h2>
<p>Per <strong>accedere alle proprietà</strong> di un oggetto si usano due modi:</p>
<ul>
<li><code>obj.property_name</code></li>
<li><code>obj[”property_name”]</code></li>
</ul>
<p>L’accesso alle proprietà attraverso la sintassi con parentesi quadre, utilizza delle stringhe che possono essere manipolate da JavaScript, è quindi legale un codice del tipo:</p>
<pre class=" language-jsx"><code class="prism  language-jsx">customer <span class="token operator">=</span> <span class="token punctuation">{</span>address0<span class="token punctuation">:</span><span class="token string">"ciao"</span><span class="token punctuation">,</span> address1<span class="token punctuation">:</span><span class="token string">"hello"</span><span class="token punctuation">,</span> address2<span class="token punctuation">:</span><span class="token string">"hi"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> addr <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 addr <span class="token operator">+=</span> customer<span class="token punctuation">[</span><span class="token string">"address"</span> <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
addr        <span class="token comment">// =&gt; "ciao hello hi "</span>
</code></pre>
<p>Nell’esempio viene manipolata la stringa di accesso alle proprietà dell’oggetto <code>customer</code>, in modo da accedere con un ciclo ad <code>address0</code>, <code>address1</code>, <code>address2</code>.</p>
<h3 id="prototype-chain">Prototype chain</h3>
<p>Ogni oggetto ha delle proprie proprietà proprie (<em><strong>own proprieties</strong></em>) e delle proprietà ereditate dal prototipo.</p>
<p>Quando si tenta di accedere ad una proprietà viene prima cercata tra le <em>own proprieties</em>, se non viene trovata allora si scorre la <em>prototype chain:</em> si cerca quindi nel prototipo dell’oggetto e se non viene trovata e il prototipo ha a sua volta un prototipo allora viene cercato anche lì.</p>
<h2 id="creazione-delle-proprietà">Creazione delle proprietà</h2>
<p>La stessa sintassi dell’accesso alle proprietà si può usare per <strong>creare delle nuove proprietà</strong>, se messe a sinistra di un assegnamento.</p>
<p>Se una proprietà con lo stesso nome è già presente nella <em>prototype chain</em> questa non viene sovrascritta, viene invece creata una nuova variabile come <em>own property</em> dell’oggetto, la quale “nasconde” la proprietà con lo stesso nome nella <em>prototype chain.</em></p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">const</span> proto <span class="token operator">=</span> <span class="token punctuation">{</span> 
  shared<span class="token punctuation">:</span> <span class="token string">"Sono nel prototipo"</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// obj eredita da proto</span>

obj<span class="token punctuation">.</span>shared <span class="token operator">=</span> <span class="token string">"Sono nell'oggetto"</span><span class="token punctuation">;</span> <span class="token comment">// Nasconde la proprietà del prototipo</span>
obj<span class="token punctuation">.</span>newProperty <span class="token operator">=</span> <span class="token string">"Proprietà propria dell'oggetto"</span><span class="token punctuation">;</span> <span class="token comment">// Crea una nuova proprietà</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>shared<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Sono nell'oggetto"</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>newProperty<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Proprietà propria dell'oggetto"</span>

</code></pre>
<h2 id="cancellazione-delle-proprietà">Cancellazione delle proprietà</h2>
<p>Attraverso l’operatore <code>delete</code> è possibile eliminare proprietà da un oggetto</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">delete</span> book<span class="token punctuation">.</span>author<span class="token punctuation">;</span>        <span class="token comment">// The book object now has no author property.</span>
<span class="token keyword">delete</span> book<span class="token punctuation">[</span><span class="token string">"main title"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Now it doesn't have "main title", either.</span>
</code></pre>
<p>È importante precisare che l’operatore <code>delete</code> può cancellare <strong>solo</strong> le <em>own properties</em>, non quelle ereditate.</p>
<p>Per cancellare una proprietà del prototipo bisogna eseguire il <code>delete</code> sulla proprietà specificando il prototipo, ma così facendo tutti gli oggetti che ereditano da quel prototipo ne saranno affetti.</p>
<h2 id="estendere-oggetti">Estendere oggetti</h2>
<p>Una pratica comune è quella di copiare il contenuto di un oggetto in un altro, il metodo <code>Object.assign()</code> permette di farlo facilmente.</p>
<p>Il metodo <code>Object.assign(destination_obj, source_obj)</code> si aspetta almeno due argomenti, il primo è l’oggetto che verrà modificato (e anche ritornato), mentre gli altri sono oggetti da cui ricavare le proprietà.</p>
<p>In pratica ogni <em>own property enumerable</em> dell’oggetto sorgente viene copiata nell’oggetto destinazione. Le proprietà già esistenti nell’oggetto destinazione vengono sovrascritte.</p>
<p>Nota: eventuali metodi getter e setter vengono invocati durante la copia (ma non copiati essi stessi)</p>
<p>Solamente con la creazione tramite gli <em>object literal</em>, è possibile utilizzare una sintassi particolare (<code>...</code>) per copiare le <em>own property enumerable</em> di un oggetto in un altro durante la sua creazione:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> position <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> dimensions <span class="token operator">=</span> <span class="token punctuation">{</span> width<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> height<span class="token punctuation">:</span> <span class="token number">7</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> rect <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>position<span class="token punctuation">,</span> <span class="token operator">...</span>dimensions <span class="token punctuation">}</span><span class="token punctuation">;</span>
rect<span class="token punctuation">.</span>x <span class="token operator">+</span> rect<span class="token punctuation">.</span>y <span class="token operator">+</span> rect<span class="token punctuation">.</span>width <span class="token operator">+</span> rect<span class="token punctuation">.</span>height <span class="token comment">// =&gt; 17</span>
</code></pre>
<p>Le proprietà degli oggetti <code>position</code> e <code>dimensions</code> vengono copiati nel nuovo oggetto <code>rect</code></p>
<h2 id="serializzazione-degli-oggetti">Serializzazione degli oggetti</h2>
<p>È possibile serializzare gli oggetti in modo da trasformarli in stringhe per poi successivamente de-serializzarli in oggetti.</p>
<p>Questo viene spesso fatto per scambiare le informazioni (come lo stato di un oggetto) nel web usando un formato comodo.</p>
<p>JavaScript mette a disposizione i seguenti metodi per lavorare con il formato <strong>JSON</strong> (<em>JavaScript Object Notation</em>):</p>
<ul>
<li><code>JSON.stringify(obj)</code>: serializza lo stato dell’oggetto (<strong>solo <em>own property enumerable</em></strong>) in una stringa in formato JSON</li>
<li><code>JSON.parse(str)</code>: de-serializza una stringa in formato JSON in un oggetto JavaScript</li>
</ul>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token punctuation">{</span>z<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s == '{"x":1,"y":{"z":[false,null,""]}}'</span>
<span class="token keyword">let</span> p <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// p == {x: 1, y: {z: [false, null, ""]}}</span>
</code></pre>
<p>JSON supporta solo una parte della sintassi che JavaScript offre, ad esempio <code>NaN, -Infinity, +Infinity</code> vengono convertiti a <code>null</code>. Oggetti come <code>Function, RegExp, Error</code> vengono ignorati dalla serializzazione. Infine <code>undefined</code> viene ignorato dalla serializzazione.</p>
<h2 id="metodi-dell’oggetto-object">Metodi dell’oggetto Object</h2>
<p>Vediamo alcuni metodi offerti dall’oggetto <code>Object</code>, da cui ogni altro oggetto eredita le proprietà.</p>
<ol>
<li><code>Object.hasOwnProperty(property)</code>
<ul>
<li>Verifica se l’oggetto ha una <em>own property</em> con il nome specificato, senza cercarla nella catena dei prototipi.</li>
</ul>
</li>
<li><code>Object.propertyIsEnumerable(property)</code>
<ul>
<li>Controlla se una proprietà specificata è enumerabile, cioè se appare nei cicli <code>for...in</code> e con <code>Object.keys()</code>.</li>
</ul>
</li>
<li><code>Object.create(prototype)</code>
<ul>
<li>Crea un nuovo oggetto con il prototipo specificato</li>
</ul>
</li>
<li><code>Object.keys(obj)</code>
<ul>
<li>Restituisce un array contenente i nomi delle <em>own property</em> <strong>enumerabili</strong> di un oggetto.</li>
</ul>
</li>
<li><code>Object.toString()</code>
<ul>
<li>Restituisce una rappresentazione in formato stringa dell’oggetto.</li>
</ul>
</li>
<li><code>Object.valueOf()</code>
<ul>
<li>Restituisce il valore primitivo che rappresenta l’oggetto.</li>
</ul>
</li>
<li><code>Object.toJSON()</code>
<ul>
<li>Restituisce una rappresentazione JSON dell’oggetto.</li>
</ul>
</li>
</ol>
<h2 id="metodi">Metodi</h2>
<p>Abbiamo due modi di definire le proprietà come metodi:</p>
<ol>
<li>
<p>modo originale:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> square <span class="token operator">=</span> <span class="token punctuation">{</span>
 area<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>side <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>side<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
 side<span class="token punctuation">:</span> <span class="token number">10</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
square<span class="token punctuation">.</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// =&gt; 100</span>
</code></pre>
</li>
<li>
<p>modo nuovo:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> square <span class="token operator">=</span> <span class="token punctuation">{</span>
 <span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>side <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>side<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
 side<span class="token punctuation">:</span> <span class="token number">10</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
square<span class="token punctuation">.</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// =&gt; 100</span>
</code></pre>
</li>
</ol>
<p>I due modi sono equivalenti, su entrambi il nome della proprietà è “area”.</p>
<h2 id="getter-e-setter">Getter e setter</h2>
<p>JavaScript supporta le così dette proprietà accessorie (<em>accessor properties</em>) che hanno due particolari metodi associati: un getter e/o un setter.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  internal_value<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>

  <span class="token comment">// Getter</span>
  <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>internal_value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token comment">// Setter</span>
  <span class="token keyword">set</span> <span class="token function">value</span><span class="token punctuation">(</span>new_value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> new_value <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>internal_value <span class="token operator">=</span> new_value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token comment">// Getter per nextVal</span>
  <span class="token keyword">get</span> <span class="token function">nextVal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>internal_value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

obj<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>      <span class="token comment">// Setter is used</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// =&gt; 10, Getter is used</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>nextVal<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// =&gt; 11, Getter is used</span>
</code></pre>
<p>Quando si tenta di ottenere il valore di una proprietà, l’interprete chiama il getter (se presente).</p>
<p>Quando si tenta di modificare il valore di una proprietà, l’interprete chiama il setter (se presente).</p>
<p>Se una proprietà ha solo un getter si dice che è una proprietà <strong>read-only</strong>, se ha solo il setter allora è <strong>write-only</strong> (la lettura restituisce un <code>undefined</code>)</p>
<p><strong>Attenzione</strong>: se si da lo stesso identico nome ai metodi getter e setter e alla variabile, il codice andrebbe in ricorsione infinita, è convenzione pre-pendere un <code>_</code> prima del nome della variabile per indicare che è una variabile di uso interno all’oggetto.</p>
<h1 id="array">Array</h1>
<p>Un array è un oggetto composto da una collezione ordinata di valori.</p>
<p>I valori sono chiamati <strong>elementi</strong>, e ogni elemento è in una determinata posizione chiamata <strong>indice</strong>.</p>
<p>Gli array sono degli <strong>oggetti specializzati</strong>: in quanto dietro le quinte sono un insieme di proprietà in cui il nome della proprietà è l’indice sotto forma di stringa, infatti possiamo creare manualmente un array in questo modo:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token comment">// Create a plain object</span>
o<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"one"</span><span class="token punctuation">;</span>    <span class="token comment">// Index it with an integer</span>
o<span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">]</span>           <span class="token comment">// =&gt; "one"; numeric and string property names are the same</span>
</code></pre>
<p>In JS un array può contenere valori di tipo qualsiasi.</p>
<p>Un aspetto particolare è che gli array possono essere <strong>sparsi</strong>, cioè ci possono essere dei buchi tra gli indici e non necessariamente il primo indice è 0. In questi array il campo <code>length</code> non corrisponde al numero reale di elementi nell’array.</p>
<p>Nota: le <strong>stringhe</strong> sono trattabili come <strong>array read-only di caratteri</strong></p>
<h2 id="creazione">Creazione</h2>
<p>Ci sono vari modi per creare array, in ogni modo gli array creati possiedono come prototype l’oggetto <code>Array.prototype</code> in cui ci sono molti metodi utili per operare sugli array.</p>
<h3 id="array-letterali">Array letterali</h3>
<p>Il modo più semplici è quello di creare gli array come letterali:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> empty <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                 <span class="token comment">// An array with no elements</span>
<span class="token keyword">let</span> primes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// An array with 5 numeric elements</span>
<span class="token keyword">let</span> misc <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 3 elements of various types + trailing comma</span>
</code></pre>
<p>è possibile creare array sparsi in questo modo:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Elements at indexes 0 and 2. No element at index 1. length:3</span>
</code></pre>
<p>Se si accede all’elemento con indice <code>1</code> si otterrà <code>undefined</code> (in generale questo accade quando si tenta di accedere ad una proprietà non esistente di un oggetto)</p>
<h3 id="operatore-di-spread">Operatore di spread</h3>
<p>Si può usare lo spread operator <code>...</code> per includere gli elementi di un oggetto iterabile (come un array) nella definizione di un array come letterale:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">...</span>a<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// b == [0, 1, 2, 3, 4]</span>
</code></pre>
<p>Può essere usato per fare una <strong>copia superficiale</strong> (shallow copy) degli elementi (cioè se gli elementi sono oggetti verrà copiato solo il riferimento)</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> original <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> copy <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>original<span class="token punctuation">]</span><span class="token punctuation">;</span>
copy<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// Modifying the copy does not change the original</span>
original<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>         <span class="token comment">// =&gt; 1</span>
</code></pre>
<h3 id="costruttore-array">Costruttore Array()</h3>
<p>Possiamo creare un array attraverso il costruttore <code>Array()</code>:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// array with no elements</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// array with the specified length (preallocate space)</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"testing"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// array with some elements</span>
</code></pre>
<h3 id="array.of-e-array.from">Array.of() e Array.from()</h3>
<p>Usando il solo costruttore <code>Array()</code> non è possibile creare un array con un solo elemento numerico.</p>
<p><code>Array.of()</code> è una funzione che ritorna un nuovo array con gli elementi specificati come argomento</p>
<pre class=" language-jsx"><code class="prism  language-jsx">Array<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment">// =&gt; []; returns empty array with no arguments</span>
Array<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>     <span class="token comment">// =&gt; [10]; can create arrays with a single numeric argument</span>
Array<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment">// =&gt; [1, 2, 3]</span>
</code></pre>
<p><code>Array.from()</code> è una funzione che si aspetta come argomento un oggetto iterabile e ritorna un nuovo array contenente gli elementi di quel oggetto</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> copy <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Questa funzione è particolarmente importante perché permette di fare una vera copia degli oggetti <strong>array-like</strong>, cioè oggetti che non sono propriamente array ma che hanno una lunghezza e le proprietà hanno un nome numerico.</p>
<h2 id="accesso-agli-elementi">Accesso agli elementi</h2>
<p>Si accede agli elementi dell’array con l’operatore <code>[]</code>:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"world"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// Start with a one-element array</span>
<span class="token keyword">let</span> value <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// Read element 0</span>
a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>           <span class="token comment">// Write element 1</span>
<span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>              <span class="token comment">// Write element 2</span>
a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>    <span class="token comment">// Write element 3</span>
a<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// Write element 3</span>
</code></pre>
<p>è possibile anche usare come indice numeri negativi, numeri con la virgola, stringhe… Questi verranno convertiti come stringhe e saranno dei nomi di proprietà valide.</p>
<p>È importante notare che però non verranno utilizzati come indici dell’array, ma solo come proprietà dell’oggetto</p>
<pre class=" language-jsx"><code class="prism  language-jsx">a<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1.23</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">// This creates a property named "-1.23"</span>
a<span class="token punctuation">[</span><span class="token string">"1000"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// This the 1001st element of the array</span>
a<span class="token punctuation">[</span><span class="token number">1.000</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// Array index 1. Same as a[1] = 1;</span>
</code></pre>
<h2 id="proprietà-length">Proprietà length</h2>
<p>Una differenza che distingue gli array dai normali oggetti JavaScript è la presenza di una proprietà <code>length</code>, che rappresenta il numero di elementi nell’array (solo con array non sparsi).</p>
<p>Tale proprietà viene calcolata come l’indice più grande trovato tra le proprietà a cui viene sommato 1.</p>
<p>Il valore di questo campo viene mantenuto aggiornato in automatico.</p>
<p>Se si aggiorna manualmente la proprietà <code>length</code> ad un valore minore dell’attuale, tutti gli elementi con indice maggiore o uguale a quello impostato vengono <strong>eliminati</strong>.</p>
<pre class=" language-jsx"><code class="prism  language-jsx">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// Start with a 5-element array.</span>
a<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>     <span class="token comment">// a is now [1,2,3].</span>
a<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// Delete all elements. a is [].</span>
a<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>     <span class="token comment">// Length is 5, but no elements, like new Array(5)</span>
</code></pre>
<h2 id="aggiungere-e-rimuovere-elementi">Aggiungere e rimuovere elementi</h2>
<p>Oltre ad aggiungere elementi esplicitandone l’indice è possibile usare:</p>
<ul>
<li><code>push(element)</code>: aggiunge un elemento alla fine dell’array</li>
<li><code>unshift(element)</code>: aggiunge un elemento all’inizio dell’array e fa shift degli elementi di una posizione avanti</li>
</ul>
<p>Analogamente possiamo rimuovere elementi usando:</p>
<ul>
<li><code>pop()</code>: rimuove l’elemento alla fine dell’array</li>
<li><code>shift()</code>: rimuove l’elemento all’inizio dell’array e shifta gli elementi di una posizione indietro</li>
</ul>
<p>Tutti i metodi mantengono coerente il valore di <code>length</code></p>
<p>È anche possibile usare <code>delete</code> per cancellare elementi, ma così facendo non viene aggiornato <code>length</code> e non avviene nessuno shift (l’array diventa sparso).</p>
<h2 id="iterare-gli-array">Iterare gli array</h2>
<p>Il modo più semplice per iterare un array è tramite il ciclo <code>for of</code> che ritorna gli elementi con indice crescente:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> letters <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token string">"Hello world"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// An array of letters</span>
<span class="token keyword">let</span> string <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> letter <span class="token keyword">of</span> letters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   string <span class="token operator">+=</span> letter<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
string <span class="token comment">// =&gt; "Hello world"; we reassembled the original text</span>
</code></pre>
<p>Si può utilizzare il metodo <code>entries()</code> per ottenere coppie indice-valore:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> everyother <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>index<span class="token punctuation">,</span> letter<span class="token punctuation">]</span> <span class="token keyword">of</span> letters<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> everyother <span class="token operator">+=</span> letter<span class="token punctuation">;</span> <span class="token comment">// letters at even indexes</span>
<span class="token punctuation">}</span>
everyother    <span class="token comment">// =&gt; "Hlowrd"</span>
</code></pre>
<p>Esiste anche un approccio più orientato alla programmazione funzionale usando il metodo <code>forEach()</code>. Questo metodo prende una funzione come argomento e tale funzione verrà chiamata su ogni elemento dell’array.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> uppercase <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
letters<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>letter <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token comment">// Note arrow function syntax here</span>
   uppercase <span class="token operator">+=</span> letter<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
uppercase <span class="token comment">// =&gt; "HELLO WORLD"</span>
</code></pre>
<p>Generalmente le funzioni come <code>forEach()</code> invocano la funzione passata come argomento con 3 parametri: il <strong>valore</strong> dell’elemento, <strong>l’indice</strong> dell’elemento e <strong>l’array stesso</strong>. Nell’esempio viene data una funzione che richiede un solo parametro (<code>letter</code>).</p>
<p>Altri metodi per iterare array sono i seguenti:</p>

<table>
<thead>
<tr>
<th>Metodo</th>
<th>Descrizione</th>
<th>Esempio</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>forEach()</code></td>
<td>Esegue una funzione per ogni elemento dell’array, ma non restituisce un nuovo array.</td>
<td><code>arr.forEach((val, idx) =&gt; console.log(val, idx));</code></td>
</tr>
<tr>
<td><code>map()</code></td>
<td>Restituisce un nuovo array con i risultati della funzione applicata a ogni elemento dell’array.</td>
<td><code>const doubled = arr.map(val =&gt; val * 2);</code></td>
</tr>
<tr>
<td><code>filter()</code></td>
<td>Restituisce un nuovo array con tutti gli elementi che soddisfano una condizione.</td>
<td><code>const evens = arr.filter(val =&gt; val % 2 === 0);</code></td>
</tr>
<tr>
<td><code>find()</code></td>
<td>Restituisce il primo elemento che soddisfa una condizione, o <code>undefined</code> se nessun elemento la soddisfa.</td>
<td><code>const firstEven = arr.find(val =&gt; val % 2 === 0);</code></td>
</tr>
<tr>
<td><code>findIndex()</code></td>
<td>Restituisce l’indice del primo elemento che soddisfa una condizione, o <code>-1</code> se nessun elemento la soddisfa.</td>
<td><code>const firstEvenIndex = arr.findIndex(val =&gt; val % 2 === 0);</code></td>
</tr>
<tr>
<td><code>every()</code></td>
<td>Restituisce <code>true</code> se tutti gli elementi dell’array soddisfano una condizione, altrimenti <code>false</code>.</td>
<td><code>const allPositive = arr.every(val =&gt; val &gt; 0);</code></td>
</tr>
<tr>
<td><code>some()</code></td>
<td>Restituisce <code>true</code> se esiste almeno un elemento che soddisfa una condizione, altrimenti <code>false</code>.</td>
<td><code>const hasEven = arr.some(val =&gt; val % 2 === 0);</code></td>
</tr>
</tbody>
</table><p>Nota: Nessuno di quei metodi modifica l’array originale di per sè</p>
<h2 id="array-multidimensionali">Array multidimensionali</h2>
<p>Si possono creare array multidimensionali come array di array, cioè dove gli elementi di un array sono a loro volta array:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token comment">// Create a multidimensional array</span>
<span class="token keyword">let</span> table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10 rows of the table</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> table<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	 table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Each row has 10 columns</span>
<span class="token punctuation">}</span>
<span class="token comment">// Initialize the array</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> row <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> row <span class="token operator">&lt;</span> table<span class="token punctuation">.</span>length<span class="token punctuation">;</span> row<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> col <span class="token operator">&lt;</span> table<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> col<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		 table<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> row<span class="token operator">*</span>col<span class="token punctuation">;</span>
	 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// Use the multidimensional array to compute 5*7</span>
table<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token comment">// =&gt; 35</span>
</code></pre>
<h2 id="oggetti-array-like">Oggetti array-like</h2>
<p>Gli oggetti <strong>array-like</strong> sono oggetti che non sono propriamente array ma che hanno una lunghezza e le proprietà hanno un nome numerico.</p>
<p>Tali oggetti non hanno come prototipo <code>Array.prototype</code> quindi non si possono chiamare i relativi metodi e nemmeno aspettarsi l’aggiornamento automatico di <code>length</code>.</p>
<p>D’altra parte molti algoritmi che funzionano sugli array funzionano anche sugli oggetti array-like a causa di come sono fatti.</p>
<p>In questo codice viene creato un oggetto normale e viene trattato come un oggetto array-like:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// Start with a regular empty object</span>

<span class="token comment">// Add properties to make it "array-like"</span>
<span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	 a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
a<span class="token punctuation">.</span>length <span class="token operator">=</span> i<span class="token punctuation">;</span>

<span class="token comment">// Now iterate through it as if it were a real array</span>
<span class="token keyword">let</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	 total <span class="token operator">+=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Nella realtà molti metodi che interagiscono con pagine HTML ritornano oggetti array-like.</p>
<h1 id="funzioni">Funzioni</h1>
<p>Una <strong>funzione</strong> in JavaScript è un blocco di codice che viene definito una sola volta, ma può essere  invocato più volte. Le funzioni possono accettare un elenco di identificatori chiamati <strong>parametri</strong>, che fungono da variabili locali per la funzione. Quando si invoca una funzione, si possono fornire degli <strong>argomenti</strong> ai suoi parametri. Le funzioni possono terminare ritornando un valore, detto <strong>valore di ritorno</strong> (se non è specificato viene ritornato <code>undefined</code>).</p>
<p>Una funzione può accedere ai campi dell’oggetto che l’ha invocata con la keyword <code>this</code>.</p>
<p>Quando una funzione viene assegnata come proprietà di un oggetto, la funzione prende il nome di <strong>metodo</strong>.</p>
<p>Quando una funzione viene utilizzata per inizializzare un nuovo oggetto, la funzione prende il nome di <strong>costruttore</strong>.</p>
<p>Per JavaScript le funzioni sono oggetti, quindi:</p>
<ul>
<li>possono essere assegnate a variabili</li>
<li>possono essere passate come argomento ad altre funzioni</li>
<li>puoi definirci delle proprietà al suo interno</li>
<li>puoi invocarci dei metodi</li>
</ul>
<h2 id="definire-le-funzioni">Definire le funzioni</h2>
<p>Vediamo vari modi per definire nuove funzioni.</p>
<p>Ci sono tre modi principali per definire le funzioni in JavaScript:</p>
<ul>
<li>
<p>Definizione come <strong>dichiarazione:</strong> Questo è il modo più diretto per definire una funzione. Si usa la parola chiave <code>function</code> seguita da:</p>
<ol>
<li>nome della funzione</li>
<li>una lista di parametri tra parentesi</li>
<li>il corpo della funzione tra parentesi graffe</li>
</ol>
<p>Le dichiarazioni di funzione sono <em>hoisted</em>, il che significa che possono essere invocate prima della loro dichiarazione nel codice.</p>
<p>Esempio:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">function</span> <span class="token function">distance</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">let</span> dx <span class="token operator">=</span> x2 <span class="token operator">-</span> x1<span class="token punctuation">;</span> 
    <span class="token keyword">let</span> dy <span class="token operator">=</span> y2 <span class="token operator">-</span> y1<span class="token punctuation">;</span> 
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>dx<span class="token operator">*</span>dx <span class="token operator">+</span> dy<span class="token operator">*</span>dy<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span> 
</code></pre>
</li>
<li>
<p>Definizione come <strong>espressioni:</strong> la definizione come espressioni assomiglia alla dichiarazione, ma appare all’interno di un’espressione più ampia. Il nome della funzione è opzionale in questo caso.</p>
<p>A differenza delle dichiarazioni, le espressioni di funzione non sono <em>hoisted</em> e devono essere definite prima di poter essere invocate.</p>
<p>Esempio:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token comment">// Note that we assign it to a variable</span>
<span class="token keyword">const</span> <span class="token function-variable function">square</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token operator">*</span>x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> 

<span class="token comment">// Function expressions can include names, which is useful for recursion.</span>
<span class="token keyword">const</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">fact</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	 <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>
		 <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	 <span class="token keyword">else</span>
		 <span class="token keyword">return</span> x <span class="token operator">*</span> <span class="token function">fact</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> 

<span class="token comment">// Function expressions can also be used as arguments to other functions:</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a<span class="token operator">-</span>b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</li>
<li>
<p><strong>Arrow function:</strong> Introdotte in ES6, le <em>arrow function</em> sono <strong>espressioni</strong> che offrono una sintassi più compatta. Non usano la parola chiave <code>function</code> e il nome viene sempre omesso. La lista dei parametri è separata da una freccia <code>=&gt;</code> dal corpo della funzione. Le <em>arrow function</em> ereditano il valore di <code>this</code> dall’ambiente in cui sono definite.</p>
<p>Esempio:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">const</span> <span class="token function-variable function">sum</span> <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>È possibile ridurre ulteriormente la sintassi nel caso in cui il corpo della funzione sia un singolo <code>return</code>:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">const</span> <span class="token function-variable function">sum</span> <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
</code></pre>
<p>Se la funzione ha esattamente un parametro si possono omettere le parentesi tonde. D’altra parte se non ci sono parametri bisogna mettere le parentesi tonde vuote:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">const</span> <span class="token function-variable function">polynomial</span> <span class="token operator">=</span> x <span class="token operator">=&gt;</span> x<span class="token operator">*</span>x <span class="token operator">+</span> <span class="token number">2</span><span class="token operator">*</span>x <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">constantFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">42</span><span class="token punctuation">;</span>
</code></pre>
</li>
</ul>
<p>Le funzioni possono essere <strong>innestate</strong>, cioè definite nel corpo di altre funzioni.</p>
<p>Un aspetto particolare è che le funzione interne possono accedere ai parametri e variabili locali delle funzioni più esterne (questo aspetto è chiamato <strong>chiusura</strong>):</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">function</span> <span class="token function">esterna</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
		<span class="token keyword">function</span> <span class="token function">interna</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">return</span> a<span class="token operator">*</span>b<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token function">interna</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
 <span class="token punctuation">}</span>
</code></pre>
<h2 id="invocare-le-funzioni">Invocare le funzioni</h2>
<p>Vediamo cinque modi in cui le funzioni JavaScript possono essere invocate.</p>
<h3 id="invocazione-come-funzione">Invocazione come funzione</h3>
<p>Questo è il modo più comune di invocare una funzione.</p>
<p>Un’espressione di invocazione consiste nel nome della funzione seguita da parentesi che racchiudono la lista di espressioni che vengono valutate e passate come argomento.</p>
<p>Il valore di ritorno della funzione diventa il valore dell’espressione di invocazione.</p>
<p>Il contesto di invocazione (il valore di <code>this</code>) è l’<strong>oggetto globale</strong>, ma in genere non viene utilizzato.</p>
<p>Esempio</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">function</span> <span class="token function">distance</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">let</span> dx <span class="token operator">=</span> x2 <span class="token operator">-</span> x1<span class="token punctuation">;</span> 
    <span class="token keyword">let</span> dy <span class="token operator">=</span> y2 <span class="token operator">-</span> y1<span class="token punctuation">;</span> 
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>dx<span class="token operator">*</span>dx <span class="token operator">+</span> dy<span class="token operator">*</span>dy<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">let</span> total <span class="token operator">=</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>é possibile fare anche una invocazione condizionale con la sintassi  <code>f?.(x)</code> che sarebbe equivalente a scrivere:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"> <span class="token punctuation">(</span>f <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> f <span class="token operator">!==</span> undefined<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">:</span> undefined
</code></pre>
<h3 id="invocazione-come-metodo">Invocazione come metodo</h3>
<p>Un metodo è semplicemente una funzione memorizzata come proprietà di un oggetto.</p>
<p>Si invoca un metodo usando la notazione col punto o le parentesi quadre per accedere alla proprietà corrispondente alla funzione.</p>
<p>Il contesto di invocazione in un’invocazione (il valore di <code>this</code>) è l’oggetto a cui appartiene il metodo.</p>
<p>Esempio:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> calculator <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token comment">// An object literal </span>
	operand1<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
	operand2<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
	<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		 <span class="token comment">// Note the use of the "this" keyword to refer to the containing object. </span>
		 <span class="token keyword">this</span><span class="token punctuation">.</span>result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>operand1 <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>operand2<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
calculator<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// A method invocation to compute 1+1.</span>
calculator<span class="token punctuation">.</span>result  <span class="token comment">// =&gt; 2</span>
</code></pre>
<p>Un aspetto importante è che le funzioni innestate dentro i metodi non possono usare <code>this</code> per riferirsi all’oggetto che le contiene (questo non vale per le arrow function, le quali ereditano il valore di <code>this</code>):</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>                 <span class="token comment">// An object o.            </span>
		m<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">// Method m of the object. </span>
			 <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>   <span class="token comment">// Save the "this" value in a variable. </span>
			 <span class="token keyword">this</span> <span class="token operator">===</span> o         <span class="token comment">// =&gt; true: "this" is the object o. </span>
			
			 <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// call the nested function f();              </span>
			 <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// define the nested function f </span>
				  <span class="token keyword">this</span> <span class="token operator">===</span> o      <span class="token comment">// =&gt; false: "this" is the global object</span>
				  self <span class="token operator">===</span> o      <span class="token comment">// =&gt; true: self is the outer "this" value. </span>
			 <span class="token punctuation">}</span>
			
			 <span class="token keyword">const</span> <span class="token function-variable function">f2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
				 <span class="token keyword">this</span> <span class="token operator">===</span> o       <span class="token comment">// true, since arrow functions inherit this</span>
		   <span class="token punctuation">}</span><span class="token punctuation">;</span>
	  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="invocazione-come-costruttore">Invocazione come costruttore</h3>
<p>Se un’invocazione di funzione o metodo è preceduta dalla parola chiave <code>new</code>, si tratta di un’invocazione di costruttore. Le invocazioni di costruttore creano un nuovo oggetto inizializzandone anche i campi.</p>
<p>Le funzioni costruttore in genere non usano la parola chiave <code>return</code>.</p>
<p>Esempio:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token comment">// the following two lines are equivalent</span>
o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="invocazione-indiretta">Invocazione indiretta</h3>
<p>I metodi <code>call()</code> e <code>apply()</code> consentono di invocare una funzione come se fosse un metodo di un altro oggetto.</p>
<p>Entrambi i metodi consentono di specificare esplicitamente il valore di this per l’invocazione.</p>
<p><code>call()</code> accetta gli argomenti da passare alla funzione come argomenti separati, mentre <code>apply()</code> accetta un array di argomenti.</p>
<p>Esempio:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">function</span> <span class="token function">introduce</span><span class="token punctuation">(</span>greeting<span class="token punctuation">,</span> punctuation<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>greeting<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, my name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>punctuation<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"Alice"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Invocation with call()</span>
introduce<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">"Hi"</span><span class="token punctuation">,</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output: Hi, my name is Alice!</span>

<span class="token comment">// Invocation with apply()</span>
introduce<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"Hi"</span><span class="token punctuation">,</span> <span class="token string">"!"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output: Hi, my name is Alice!</span>
</code></pre>
<h3 id="invocazione-implicita">Invocazione implicita</h3>
<p>Alcune funzionalità del linguaggio JavaScript, come getter e setter, conversioni di tipo implicite e iteratori, possono causare l’invocazione implicita di funzioni.</p>
<h2 id="argomenti-e-parametri">Argomenti e parametri</h2>
<p>In Javascript, le definizioni delle funzioni non specificano un tipo previsto per i parametri, non viene eseguito alcun controllo di tipo sugli argomenti passati e non viene controllato nemmeno il numero di argomenti che vengono passati.</p>
<h3 id="parametri-opzionali-e-valori-di-default">Parametri opzionali e valori di default</h3>
<p>Quando una funzione viene invocata con meno argomenti rispetto ai parametri dichiarati, quelli aggiuntivi vengono impostati sul loro valore di default, che normalmente è <code>undefined</code>.</p>
<p>È possibile definire un <strong>valore di default</strong> per ciascuno dei parametri della funzione direttamente nell’elenco dei parametri della funzione:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">function</span> <span class="token function">greet</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"Guest"</span><span class="token punctuation">,</span> language <span class="token operator">=</span> <span class="token string">"en"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> greeting<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>language <span class="token operator">===</span> <span class="token string">"en"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        greeting <span class="token operator">=</span> <span class="token template-string"><span class="token string">`Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>language <span class="token operator">===</span> <span class="token string">"it"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        greeting <span class="token operator">=</span> <span class="token template-string"><span class="token string">`Ciao, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        greeting <span class="token operator">=</span> <span class="token template-string"><span class="token string">`Hi, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">! (language not supported)`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> greeting<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>I valori di default si possono usare anche negli altri modi per definire le funzioni visti precedentemente.</p>
<h3 id="parametri-rest-ed-elenchi-di-argomenti-di-lunghezza-variabile">Parametri rest ed elenchi di argomenti di lunghezza variabile</h3>
<p>Mentre i valori di default permettono di chiamare la funzione con meno argomenti di quelli richiesti, i <strong>parametri <em>rest</em></strong> permettono di scrivere funzioni che possono essere invocate con un numero arbitrariamente maggiore di argomenti rispetto ai parametri.</p>
<p>Un parametro rest è preceduto da tre punti <code>...</code> e deve essere l’ultimo parametro in una dichiarazione di funzione.</p>
<p>Il valore di un parametro rest sarà sempre un <strong>array</strong>. L’array può essere vuoto, ma un parametro rest non sarà mai <code>undefined</code></p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">function</span> <span class="token function">max</span><span class="token punctuation">(</span>first<span class="token operator">=</span><span class="token operator">-</span><span class="token number">Infinity</span><span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
		<span class="token keyword">let</span> maxValue <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token comment">// Start by assuming the first arg is the biggest </span>
		
		<span class="token comment">// Then loop through the rest of the arguments, looking for bigger </span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> n <span class="token keyword">of</span> rest<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
				<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> maxValue<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
				maxValue <span class="token operator">=</span> n<span class="token punctuation">;</span> 
				<span class="token punctuation">}</span> 
		<span class="token punctuation">}</span> 

		<span class="token keyword">return</span> maxValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 

<span class="token function">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>  <span class="token comment">// =&gt; 1000</span>
</code></pre>
<h3 id="l’oggetto-arguments">L’oggetto Arguments</h3>
<p>I parametri rest sono stati introdotti nelle nuove versioni di JavaScript. Prima dei parametri rest, le funzioni che accettavano un numero arbitrario di parametri venivano scritte usando l’oggetto <code>Arguments</code>.</p>
<p>All’interno del corpo di una qualsiasi funzione, l’identificatore <code>arguments</code> si riferisce all’oggetto <code>Arguments</code> per quella chiamata. L’oggetto <code>Arguments</code> è un oggetto array-like che permette di recuperare i valori degli argomenti passati alla funzione tramite indice numerico.</p>
<h3 id="destrutturazione-degli-argomenti-di-funzione-nei-parametri">Destrutturazione degli argomenti di funzione nei parametri</h3>
<p>Se si definisce una funzione che ha i nomi dei parametri tra parentesi quadre, si sta dicendo alla funzione di aspettarsi che venga passato un array per ogni parametro tra parentesi quadre.</p>
<p>Nel processo di invocazione, gli argomenti dell’array saranno destrutturati nei singoli parametri nominati.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">function</span> <span class="token function">vectorAdd</span><span class="token punctuation">(</span><span class="token punctuation">[</span>x1<span class="token punctuation">,</span>y1<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>x2<span class="token punctuation">,</span>y2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Unpack 2 arguments into 4 parameters </span>
		<span class="token keyword">return</span> <span class="token punctuation">[</span>x1 <span class="token operator">+</span> x2<span class="token punctuation">,</span> y1 <span class="token operator">+</span> y2<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">vectorAdd</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// =&gt; [4,6]</span>
</code></pre>
<p>Allo stesso modo, se si sta definendo una funzione che si aspetta un argomento oggetto, è possibile destrutturare i parametri di quell’oggetto.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token comment">// Multiply the vector {x,y} by a scalar value</span>
<span class="token keyword">function</span> <span class="token function">vectorMultiply</span><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token punctuation">,</span> y<span class="token punctuation">}</span><span class="token punctuation">,</span> scalar<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
		<span class="token keyword">return</span> <span class="token punctuation">{</span>x<span class="token punctuation">:</span> x<span class="token operator">*</span>scalar<span class="token punctuation">,</span> y<span class="token punctuation">:</span> y<span class="token operator">*</span>scalar<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">vectorMultiply</span><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment">// =&gt; {x: 2, y: 4}</span>
</code></pre>
<h3 id="tipi-degli-argomenti">Tipi degli argomenti</h3>
<p>I parametri dei metodi Javascript non hanno tipi dichiarati e non viene eseguito alcun controllo di tipo sui valori passati a una funzione.</p>
<p>JavaScript esegue conversioni di tipo secondo le necessità. Quindi, se si scrive una funzione che si aspetta un argomento stringa e poi si chiama quella funzione con un valore di qualche altro tipo, il valore passato verrà convertito in una stringa quando dentro la funzione si cerca di usarlo come stringa.</p>
<p>È quindi buona pratica aggiungere del codice per controllare i tipi degli argomenti (usando <code>typeof</code> e l’operatore di confronto stretto <code>===</code>). È meglio che una funzione fallisca immediatamente con un errore chiaro, piuttosto che iniziare l’esecuzione e fallire in seguito con un messaggio di errore ambiguo.</p>
<h2 id="funzioni-come-valori">Funzioni come valori</h2>
<p>In JavaScript le funzioni sono anche <strong>valori</strong> veri e propri. Questo significa che possono essere:</p>
<ul>
<li><strong>Assegnate a variabili:</strong> Il nome della funzione diventa quindi solo un riferimento all’oggetto funzione.</li>
<li><strong>Memorizzate in proprietà di oggetti:</strong> in questo caso la chiamiamo “metodo”.</li>
<li><strong>Inserite in array:</strong> le funzioni possono essere elementi di un array.</li>
<li><strong>Passate come argomenti ad altre funzioni:</strong> Questo permette di creare funzioni generiche e flessibili.</li>
</ul>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">function</span> <span class="token function">square</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token operator">*</span>x<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> s <span class="token operator">=</span> square<span class="token punctuation">;</span>  <span class="token comment">// Now s refers to the same function that square does</span>
<span class="token function">square</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>        <span class="token comment">// =&gt; 16</span>
<span class="token function">s</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>             <span class="token comment">// =&gt; 16</span>
</code></pre>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token operator">=&gt;</span> x<span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// An array literal containing a function and 20</span>
a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>               <span class="token comment">// =&gt; 400</span>
</code></pre>
<h3 id="definire-proprietà-nelle-funzioni">Definire Proprietà nelle Funzioni</h3>
<p>Essendo oggetti, le funzioni possono avere anche <strong>proprietà</strong> al loro interno. Questo è utile per memorizzare informazioni statiche che devono persistere tra diverse chiamate alla funzione.</p>
<p>Un semplice esempio è la funzione utilizza una <strong>proprietà counter</strong> per tenere traccia dell’ultimo intero restituito, garantendo che ogni chiamata restituisca un valore univoco:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token comment">// Function declarations are hoisted so we really can</span>
<span class="token comment">// do this assignment before the function declaration.</span>
uniqueInteger<span class="token punctuation">.</span>counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  

<span class="token keyword">function</span> <span class="token function">uniqueInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
		<span class="token keyword">return</span> uniqueInteger<span class="token punctuation">.</span>counter<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">uniqueInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// =&gt; 0</span>
<span class="token function">uniqueInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// =&gt; 1</span>
</code></pre>
<h2 id="funzioni-come-namespace">Funzioni come Namespace</h2>
<p>Un <em>namespace</em> è un modo per organizzare il codice in gruppi logici, evitando collisioni di nomi tra variabili e funzioni globali.</p>
<p>Poiché le variabili dichiarate all’interno di una funzione non sono visibili all’esterno, le funzioni possono essere usate per creare <em>namespace</em> temporanei.</p>
<h3 id="funzioni-anonime-e-iife">Funzioni Anonime e IIFE</h3>
<p>È possibile utilizzare una <strong>funzione anonima</strong> e invocarla immediatamente. Questa tecnica è chiamata “<em>immediately invoked function expression</em>” (IIFE) e si usa la seguente sintassi:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// Chunk of code goes here</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// End the function literal and invoke it now.</span>
</code></pre>
<p>Le parentesi attorno alla definizione della funzione sono necessarie per farla interpretare come espressione, e le parentesi finali servono per invocarla subito.</p>
<p>L’uso delle IIFE è diventato meno comune con l’introduzione dei <strong>moduli</strong> in JavaScript.</p>
<h2 id="chiusure">Chiusure</h2>
<p>Le funzioni JS hanno uno scope lessicale, questo significa che <strong>quando vengono eseguite utilizzano lo scope di quando sono state definite</strong> e non solo lo scope di quando vengono invocate.</p>
<p>Quindi una funzione oltre ad includere il proprio codice deve anche mantenere un riferimento allo scope in cui la funzione era stata definita.</p>
<p>Questo concetto si chiama <strong>chiusura</strong>.</p>
<p>Tutti le funzioni JavaScript sono tecnicamente chiusure, ma la loro vera utilità si manifesta quando vengono invocate da un scope diverso da quello in cui sono state definite, come nel caso di funzioni annidate.</p>
<p>Vediamo un esempio:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> scope <span class="token operator">=</span> <span class="token string">"global scope"</span><span class="token punctuation">;</span>          <span class="token comment">// A global variable</span>
<span class="token keyword">function</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
		<span class="token keyword">let</span> scope <span class="token operator">=</span> <span class="token string">"local scope"</span><span class="token punctuation">;</span>       <span class="token comment">// A local variable</span>
		<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> scope<span class="token punctuation">;</span> <span class="token punctuation">}</span>   <span class="token comment">// Return the the local scope variable</span>
		<span class="token keyword">return</span> f<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> inner_func <span class="token operator">=</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">inner_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment">// =&gt; "local scope"</span>
</code></pre>
<p>La funzione <code>checkscope()</code> restituisce una funzione annidata <code>f</code>. Anche se <code>f()</code> viene invocata al di fuori di <code>checkscope()</code>, accede comunque alla variabile <code>scope</code> nel suo ambiente di definizione originale.</p>
<p>Vediamo un altro esempio, per una funzione che incrementa un contatore. Al posto di avere il contatore come una proprietà interna alla funzione (che chiunque potrebbe modificare) usiamo una funzione con uno scope privato:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">function</span> <span class="token function">createCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	 <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	 <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		 <span class="token keyword">return</span> value<span class="token operator">++</span><span class="token punctuation">;</span>
	 <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">let</span> uniqueInteger <span class="token operator">=</span> <span class="token function">createCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">uniqueInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// =&gt; 0</span>
<span class="token function">uniqueInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// =&gt; 1</span>
<span class="token function">uniqueInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// =&gt; 2</span>
</code></pre>
<p>In questo caso viene creata una funzione <code>createCounter()</code> che restituisce una nuova funzione. La funzione restituita ha un proprio stato privato contenente la variabile <code>value</code>. In questo modo la variabile (che è una funzione) <code>uniqueInteger</code> ha un accesso esclusivo alla variabile <code>value</code> (nessuno da fuori può modificare il valore del counter interno)</p>
<p>Un altro esempio molto comune è il seguente, in cui si vuole associare una funzione al verificarsi di un evento su un componente HTML.</p>
<p>Ad esempio se abbiamo due bottoni e vogliamo che uno incrementi un contatore e l’altro bottone che lo decrementi possiamo sfruttare le chiusure per farlo su un variabile condivisa <code>counter</code>:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">function</span> <span class="token function">setupCounterHandlers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Variabile privata nella closure</span>

    <span class="token comment">// Incrementa il counter</span>
    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"incrementBtn"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        counter<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Decrementa il counter</span>
    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"decrementBtn"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        counter<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Inizializza gli event listener</span>
<span class="token function">setupCounterHandlers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Quando i bottoni verranno premuti verranno eseguite le funzioni interne che fanno l’incremento/decremento.</p>
<p>Le chiusure offrono quindi i <strong>vantaggi</strong> di:</p>
<ul>
<li><strong>Stato privato:</strong> Le chiusure possono essere utilizzate per creare uno stato privato per le funzioni.</li>
<li><strong>Condivisione di stato tra le chiusure:</strong> Più chiusure definite nello stesso scope possono condividere l’accesso alle stesse variabili private.</li>
</ul>
<h1 id="classi">Classi</h1>
<p>In JavaScript una classe è un insieme di oggetti che ereditano delle proprietà dallo stesso oggetto prototype.</p>
<p>Non sono quindi dei template che rappresentano il tipo degli oggetti, come avviene nei linguaggi orientati agli oggetti.</p>
<p>Vediamo diversi modi per creare classi in JavaScript.</p>
<h2 id="primo-modo-factory-function">Primo modo: factory function</h2>
<p>Voglio costruire una classe di oggetti che rappresentano un range di valori.</p>
<p>Ricordiamo che un modo per creare nuovi oggetti era usare <code>Object.create(my_prototype)</code>.</p>
<p>Se costruiamo un nostro prototype e una funzione (generalmente riferita come <em>factory function</em>) che sfrutta <code>Object.create()</code> per creare nuovi oggetti a partire dal nostro prototype abbiamo creato una classe.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"> <span class="token comment">// This is a factory function that returns a new range object.</span>
 <span class="token keyword">function</span> <span class="token function">range</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">,</span> to<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
		<span class="token comment">// Use Object.create() to create an object that inherits from the </span>
		<span class="token comment">// prototype object defined below. The prototype object is stored as </span>
		<span class="token comment">// a property of this function</span>
		<span class="token keyword">let</span> r <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>range<span class="token punctuation">.</span>methods<span class="token punctuation">)</span><span class="token punctuation">;</span> 
		
		<span class="token comment">// Store the start and end points of this new range object. </span>
		<span class="token comment">// These are noninherited properties that are unique to this object.</span>
		r<span class="token punctuation">.</span><span class="token keyword">from</span> <span class="token operator">=</span> <span class="token keyword">from</span><span class="token punctuation">;</span> 
		r<span class="token punctuation">.</span>to <span class="token operator">=</span> to<span class="token punctuation">;</span> 
	
		<span class="token keyword">return</span> r<span class="token punctuation">;</span>
 <span class="token punctuation">}</span> 

<span class="token comment">// This prototype object defines methods inherited by all range objects.</span>
range<span class="token punctuation">.</span>methods <span class="token operator">=</span> <span class="token punctuation">{</span>
		<span class="token comment">// Return true if x is in the range, false otherwise </span>
		<span class="token function">includes</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">from</span> <span class="token operator">&lt;=</span> x <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>to<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> 
		
		<span class="token comment">// Return a string representation of the range</span>
		<span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string">"("</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">from</span> <span class="token operator">+</span> <span class="token string">"..."</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>to <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span> 

<span class="token comment">// Here are example uses of a range object.</span>
<span class="token keyword">let</span> r <span class="token operator">=</span> <span class="token function">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      
r<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>             <span class="token comment">// =&gt; true: 2 is in the range</span>
r<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>              <span class="token comment">// =&gt; "(1...3)"</span>
</code></pre>
<p>Nell’esempio viene definita una funzione <code>range</code> che crea nuovi oggetti.</p>
<p>Dato che la funzione range è a sua volta un oggetto, possiamo aggiungere alla funzione un campo <code>methods</code> in cui definire il prototype degli oggetti che verranno creati. Nota che <code>methods</code> è a sua volta un oggetto in cui vengono definiti dei campi (in particolare dei metodi) che ogni oggetto creato con prototype <code>methods</code> condividerà.</p>
<p>Vediamo quindi come gli <strong>oggetti ereditano direttamente da altri oggetti</strong>.</p>
<h2 id="secondo-modo-costruttore">Secondo modo: costruttore</h2>
<p>Questo modo è quello che veniva utilizzato prima dell’introduzione della keyword <code>class</code>.</p>
<p>Il <strong>costruttore</strong> è una funzione che si occupa di inizializzare gli oggetti appena creati.</p>
<p>I costruttori invocati con la keyword <code>new</code> creano automaticamente un nuovo oggetto, quindi nel corpo del costruttore è solo necessario inizializzare i campi.</p>
<p>È importante sottolineare che tra tutti gli oggetti <strong>solamente le funzioni possiedono un campo chiamato</strong> <code>prototype</code> <strong>che contiene l’oggetto prototype</strong>, che viene usato quando la funzione viene invocato con un <code>new</code> per impostare il prototype del nuovo oggetto creato. Mentre gli oggetti che non sono funzioni hanno un prototipo interno ma non hanno un campo <code>prototype</code>.</p>
<p>Voglio costruire una classe di oggetti che rappresentano un range di valori.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token comment">// This is a constructor function.</span>
<span class="token comment">// Note that it does not create or return the object. It just initializes 'this'.</span>
<span class="token keyword">function</span> <span class="token function">Range</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">,</span> to<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
	<span class="token comment">// Store the start and end points of this new range object. </span>
	<span class="token comment">// These are noninherited properties that are unique to this object. </span>
	<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">from</span> <span class="token operator">=</span> <span class="token keyword">from</span><span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>to <span class="token operator">=</span> to<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 

<span class="token comment">// All Range objects inherit from the following object.</span>
<span class="token comment">// Note that the property name must be "prototype" for this to work.</span>
Range<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span> 
	<span class="token comment">// Return true if x is in the range, false otherwise </span>
	includes<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">from</span> <span class="token operator">&lt;=</span> x <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>to<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> 
	
	<span class="token comment">// Return a string representation of the range </span>
	toString<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string">"("</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">from</span> <span class="token operator">+</span> <span class="token string">"..."</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>to <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> 

<span class="token comment">// Here are example uses of this new Range class</span>
<span class="token keyword">let</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
r<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>             <span class="token comment">// =&gt; true: 2 is in the range</span>
r<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>              <span class="token comment">// =&gt; "(1...3)"</span>
</code></pre>
<p>Nota come il costruttore per convenzione si indica con l’iniziale maiuscola.</p>
<p>L’oggetto viene creato sul <code>new</code>, e nel costruttore ci possiamo riferire all’oggetto tramite la keyword <code>this</code>.</p>
<p>Possiamo pensare che il <strong>nome del costruttore sia il nome della classe</strong>.</p>
<h3 id="instanceof">Instanceof</h3>
<p><code>Instanceof</code> è un operatore che alla sua sinistra ha un oggetto e a destra un costruttore (che in un certo senso da il nome alla classe).</p>
<p>Serve per testare l’appartenenza di un oggetto ad una classe:</p>
<pre class=" language-jsx"><code class="prism  language-jsx">r <span class="token keyword">instanceof</span> <span class="token class-name">Range</span>   <span class="token comment">// =&gt; true: r inherits from Range.prototype</span>
</code></pre>
<p>l’appartenenza non deve necessariamente essere diretta: cioè se <code>r</code> eredita da un oggetto, che a sua volta eredita da <code>Range.prototype</code> verrà valutata comunque come <code>true</code>.</p>
<p>Siccome si guarda il prototype del costruttore e non il costruttore in sè, anche il seguente caso restituisce <code>true</code>:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"> <span class="token keyword">function</span> <span class="token function">Strange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
 Strange<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Range<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
 
 s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Strange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 s <span class="token keyword">instanceof</span> <span class="token class-name">Range</span>   <span class="token comment">// =&gt; true</span>
</code></pre>
<h2 id="terzo-modo-keyword-class">Terzo modo: keyword class</h2>
<p>Questo è il modo moderno per fare le classi.</p>
<p>Nonostante il leggero cambio di sintassi il funzionamento alla base non cambia rispetto ai modi precedenti, la keyword <code>class</code> è solo un zucchero sintattico completamente equivalente al secondo modo con il costruttore che abbiamo visto.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">class</span> <span class="token class-name">Range</span> <span class="token punctuation">{</span> 
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">,</span> to<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token comment">// Store the start and end points of this new range object. </span>
        <span class="token comment">// These are noninherited properties that are unique to this object. </span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">from</span> <span class="token operator">=</span> <span class="token keyword">from</span><span class="token punctuation">;</span> 
        <span class="token keyword">this</span><span class="token punctuation">.</span>to <span class="token operator">=</span> to<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 
 
    <span class="token comment">// Return true if x is in the range, false otherwise  </span>
    <span class="token function">includes</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">from</span> <span class="token operator">&lt;=</span> x <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>to<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
 
    <span class="token comment">// Return a string representation of the range </span>
    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">from</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">...</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>to<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
 
<span class="token comment">// Here are example uses of this new Range class</span>
<span class="token keyword">let</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
r<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>             <span class="token comment">// =&gt; true: 2 is in the range</span>
r<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>              <span class="token comment">// =&gt; "(1...3)"</span>
</code></pre>
<p>In questo caso il corpo della classe contiene il costruttore e i campi aggiuntivi del prototype che avranno gli oggetti.</p>
<p>È importante sottolineare che “costructor” è il nome obbligatorio per indicare il costruttore ma non è il vero e proprio nome della funzione costruttore, questo perché viene creata automaticamente una variabile chiamata come la classe, in questo caso <code>Range</code>, e gli viene assegnata la funzione costruttore. Quindi si può invocare il costruttore sempre chiamando <code>new Range()</code>.</p>
<p>Nota che la dichiarazione di una classe in questo modo non è <em>hoisted</em>, non è quindi possibile istanziare un oggetto della classe prima di aver dichiarato la classe.</p>
<h2 id="metodi-statici"><strong>Metodi Statici</strong></h2>
<p>Un <strong>metodo statico</strong> (o metodo di classe) viene definito all’interno di una classe utilizzando <code>static</code> prima della dichiarazione del metodo.</p>
<p>I metodi statici definiti nella classe non vanno a finire dentro l’oggetto prototype, quindi gli oggetti di tale classe non avranno tali metodi nel loro prototype.</p>
<p>Per invocare i metodi statici bisogna passare attraverso la classe stessa (il suo costruttore).</p>
<p>Per esempio:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">class</span> <span class="token class-name">Range</span> <span class="token punctuation">{</span> 
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">,</span> to<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token comment">// Store the start and end points of this new range object. </span>
        <span class="token comment">// These are noninherited properties that are unique to this object. </span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">from</span> <span class="token operator">=</span> <span class="token keyword">from</span><span class="token punctuation">;</span> 
        <span class="token keyword">this</span><span class="token punctuation">.</span>to <span class="token operator">=</span> to<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 
 
    <span class="token comment">// Return true if x is in the range, false otherwise  </span>
    <span class="token function">includes</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">from</span> <span class="token operator">&lt;=</span> x <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>to<span class="token punctuation">;</span> <span class="token punctuation">}</span> 
 
    <span class="token comment">// Return a string representation of the range </span>
    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">from</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">...</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>to<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
		<span class="token keyword">static</span> <span class="token function">parse</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		    <span class="token keyword">let</span> matches <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/^\((\d+)\.\.\.(\d+)\)$/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>matches<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Cannot parse Range from "</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>s<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">".`</span></span><span class="token punctuation">)</span>
		    <span class="token punctuation">}</span>
		    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Range</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span>matches<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>matches<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span> 

<span class="token keyword">let</span> r <span class="token operator">=</span> Range<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">'(1...10)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Returns a new Range object</span>
r<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">'(1...10)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// TypeError: r.parse is not a function</span>
</code></pre>
<h2 id="campi-di-una-classe"><strong>Campi di una classe</strong></h2>
<p>Se si vuole <strong>definire un campo</strong> di classe, si può fare nel costruttore (tecnica vecchia) oppure nel corpo della classe assieme ai metodi (tecnica nuova).</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">class</span> <span class="token class-name">Buffer</span> <span class="token punctuation">{</span> 
		size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
		capacity <span class="token operator">=</span> <span class="token number">4096</span><span class="token punctuation">;</span> 
		buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uint8Array</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Nota che le inizializzazioni vengono comunque fatte all’interno di un costruttore implicito.</p>
<p>È comunque necessario usare <code>this</code> quando si vuole accedere ai campi.</p>
<p>È possibile anche definire <strong>campi privati</strong>, i cui nomi iniziano con <code>#</code>.</p>
<p>Questi campi sono <strong>utilizzabili solo all’interno del corpo della classe</strong>, e quindi inaccessibili per qualsiasi codice al di fuori del corpo della classe.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">class</span> <span class="token class-name">Buffer</span> <span class="token punctuation">{</span> 
		#size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
		capacity <span class="token operator">=</span> <span class="token number">4096</span><span class="token punctuation">;</span> 
		buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uint8Array</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token keyword">get</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#size<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment">// read-only getter</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Anche i <strong>campi</strong> possono essere <strong>statici</strong> e si comporteranno come i metodi statici, cioè si accedono tramite la classe.</p>
<h2 id="sottoclassi">Sottoclassi</h2>
<p>Se si vuole definire una classe come sottoclasse di un’altra si può usare la keyword <code>extends</code></p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token comment">// A Span is like a Range, but instead of initializing it with</span>
<span class="token comment">// a start and an end, we initialize it with a start and a length</span>
<span class="token keyword">class</span> <span class="token class-name">Span</span> <span class="token keyword">extends</span> <span class="token class-name">Range</span> <span class="token punctuation">{</span> 
	<span class="token function">constructor</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
		<span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
			<span class="token keyword">super</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> start <span class="token operator">+</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span> 
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token punctuation">{</span> 
			<span class="token keyword">super</span><span class="token punctuation">(</span>start <span class="token operator">+</span> length<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span> 
		<span class="token punctuation">}</span> 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In questo caso <code>Span</code> si dice <strong>sottoclasse</strong>, mentre <code>Range</code> si dice <strong>superclasse</strong>.</p>
<p>Le istanze di <code>Span</code> ereditano i metodi di <code>Range</code>. Inoltre <code>Span</code> può definire altri metodi e sovrascrivere quelli ereditati.</p>
<p>La keyword <code>super</code> viene utilizzata per invocare il costruttore della superclasse, inoltre in caso in cui dei metodi siano stati sovrascritti, utilizzando <code>super</code> si può invocare la versione del metodo della superclasse.</p>
<p>Note su <code>super</code>:</p>
<ul>
<li>Se si definisce una classe con <code>extends</code>, il costruttore della sottoclasse <strong>deve</strong> usare <code>super()</code> per invocare il costruttore della superclasse.</li>
<li>Se non si definisce un costruttore nella sottoclasse, ne verrà definito automaticamente uno che prende i valori passati e li passa a <code>super()</code>.</li>
<li>Non si può usare <code>this</code> nel costruttore prima di aver invocato <code>super()</code>.</li>
<li>Quando si usa <code>super()</code> all’interno del costruttore di una sottoclasse, il costruttore della superclasse vedrà il costruttore della sottoclasse come valore di <code>new.target</code>.</li>
</ul>
<h3 id="new.target">new.target</h3>
<p><code>new.target</code> è una espressione utile all’interno dei costruttori, essa assume valori diversi in base al tipo di invocazione:</p>
<ul>
<li>è <code>undefined</code> se la funzione viene invocata <strong>senza</strong> il <code>new</code>, quindi come funzione normale e non come costruttore</li>
<li>è il <strong>riferimento al costruttore</strong> quando viene invocato con <code>new</code></li>
<li>è il <strong>riferimento al costruttore della sottoclasse</strong> quando viene invocato con <code>super</code></li>
</ul>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">new</span><span class="token punctuation">.</span>target <span class="token operator">===</span> Base<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"La classe 'Base' non può essere direttamente istanziata."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Costruttore chiamato da una sottoclasse."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Nota: con la definizione di classe con la keyword <code>class</code> non è possibile invocare il costruttore senza <code>new</code>, quindi <code>new.target</code> potrà assumere il valore <code>undefined</code> solo nei modi vecchi di creare classi.</p>
<h2 id="differenze-tra-un-linguaggio-orientato-agli-oggetti-e-javascript"><strong>Differenze tra un linguaggio orientato agli oggetti e JavaScript</strong></h2>
<ol>
<li>
<p><strong>significato di classe</strong></p>
<p>In JavaScript una classe è un insieme di oggetti che ereditano delle proprietà dallo stesso oggetto prototype.</p>
<p>Non sono quindi dei template che rappresentano il tipo degli oggetti, come avviene nei linguaggi orientati agli oggetti.</p>
</li>
<li>
<p><strong>Le Funzioni sono Campi</strong></p>
<p>In JavaScript, un oggetto ha solo campi e anche le funzioni sono trattate come campi.</p>
<p>Le funzioni stesse sono oggetti, dove i parametri sono campi.</p>
</li>
<li>
<p><strong>Ereditarietà Basata su Prototipi</strong></p>
<p>In JavaScript non esistono classi vere e proprie che fungono da template per gli oggetti.</p>
<p>Gli oggetti ereditano direttamente da altri oggetti tramite il <strong>meccanismo dei prototipi</strong>.</p>
<p>Nei linguaggi OOP, invece, l’ereditarietà è basata su classi.</p>
</li>
<li>
<p><strong>Modificabilità Dinamica degli Oggetti e dei prototipi</strong></p>
<p>In OOP, gli oggetti sono istanze di una classe che definisce il loro <strong>tipo</strong>.</p>
<p>In JavaScript, gli oggetti possono essere modificati dinamicamente a runtime aggiungendo o rimuovendo proprietà e metodi.</p>
<p>Analogamente anche i <strong>prototipi</strong> in JavaScript possono essere modificati dinamicamente a runtime, permettendo di alterare l’ereditarietà anche dopo la creazione dell’oggetto.</p>
</li>
<li>
<p><strong>Mancanza di Overloading dei Metodi</strong></p>
<p>In JavaScript non è possibile effettuare l’<strong>overload</strong> dei metodi, ovvero definire più metodi con lo stesso nome ma con un numero o tipo diverso di parametri.</p>
<p>Se si ridefinisce un metodo con lo stesso nome, l’ultima definizione sovrascrive le precedenti.</p>
</li>
</ol>
<h1 id="iteratori-e-generatori">Iteratori e generatori</h1>
<p>Alcuni oggetti come Array, stringhe, Set, Map sono iterabili, cioè il loro contenuto può essere ottenuto attraverso un ciclo <code>for/of</code></p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
		sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
sum   <span class="token comment">// =&gt; 6</span>
</code></pre>
<p>Abbiamo anche visto come espandere un oggetto iterabile con l’operatore di spread <code>...</code></p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> chars <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token string">"abcd"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// chars == ["a", "b", "c", "d"]</span>
</code></pre>
<h2 id="come-funzionano-gli-iteratori">Come funzionano gli iteratori</h2>
<p>Gli <strong>Oggetti iterabili</strong> sono oggetti come Array, Set e Map che possono essere iterati, ovvero i loro contenuti possono essere “visitati” in sequenza. Questi oggetti hanno un metodo speciale chiamato <strong>iterator method</strong> che restituisce un <strong>Iteratore</strong>.</p>
<p>Un <strong>iteratore</strong> è un oggetto che esegue l’iterazione, ha un metodo <code>next()</code> che restituisce un nuovo oggetto con proprietà <code>value</code> e <code>done</code>. La proprietà <code>value</code> contiene il valore dell’iterazione corrente, mentre <code>done</code> è un booleano che indica se tutti gli elementi dell’iterable sono stati visitati.</p>
<p>Il metodo per ottenere l’iteratore è <code>Symbol.iterator</code>.</p>
<p>Il ciclo <code>for/of</code> e l’operatore spread utilizzano internamente questo meccanismo per iterare sugli oggetti:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">let</span> iterable <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> iterator <span class="token operator">=</span> iterable<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> result <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> result<span class="token punctuation">.</span>done <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">;</span> result <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Il ciclo <code>for</code> continua a chiamare il metodo <code>next()</code> dell’iteratore finché <code>result.done</code> non diventa <code>true</code>, stampando il valore di <code>result.value</code> a ogni iterazione.</p>
<p>I <strong>Symbol</strong> in JavaScript sono un tipo di dato primitivo. Un Symbol è un valore unico e immutabile che può essere utilizzato come chiave per le proprietà di un oggetto.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">const</span> sym1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"description"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> sym2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"description"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sym1 <span class="token operator">===</span> sym2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre>
<p><code>Symbol.iterator</code> è un Symbol predefinito nel linguaggio.</p>
<h2 id="creare-oggetti-iterabili">Creare oggetti iterabili</h2>
<p>Per rendere una classe iterabile bisogna creare un metodo <code>Symbol.iterator</code> che ritorna un oggetto iterator il quale possiede il metodo <code>next()</code> che ritorna un oggetto con i campi <code>value</code> e <code>done</code></p>
<p>Vediamo un esempio:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token comment">/* A Range object represents a range of numbers [from, ..., to]
Range is iterable and iterates all integers within the range.
*/</span>
<span class="token keyword">class</span> <span class="token class-name">Range</span> <span class="token punctuation">{</span>
	<span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">,</span> to<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
			<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">from</span> <span class="token operator">=</span> <span class="token keyword">from</span><span class="token punctuation">;</span> 
			<span class="token keyword">this</span><span class="token punctuation">.</span>to <span class="token operator">=</span> to<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
	
	<span class="token comment">// Make a Range iterable by returning an iterator object. </span>
		<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">// Each iterator instance must iterate the range independently of </span>
			<span class="token comment">// others. So we need a state variable to track our location in the </span>
			<span class="token comment">// iteration. We start at the first integer &gt;= from. </span>
			<span class="token keyword">let</span> next_val <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// This is the next value we return </span>
			<span class="token keyword">let</span> last <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>to<span class="token punctuation">;</span>               <span class="token comment">// We won't return anything &gt; this </span>
			
			<span class="token keyword">return</span> <span class="token punctuation">{</span>                     <span class="token comment">// This is the iterator object </span>
					<span class="token comment">// This next() method is what makes this an iterator object. </span>
					<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
						<span class="token keyword">return</span> <span class="token punctuation">(</span>next_val <span class="token operator">&lt;=</span> last<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">{</span> value<span class="token punctuation">:</span> next_val<span class="token operator">++</span> <span class="token punctuation">}</span> <span class="token punctuation">:</span> <span class="token punctuation">{</span> done<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span><span class="token punctuation">,</span> 
					<span class="token comment">// As a convenience, we make the iterator itself iterable. </span>
					<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> 
			<span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span> 

<span class="token keyword">let</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> x <span class="token keyword">of</span> r<span class="token punctuation">)</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Logs numbers 1 to 10</span>

<span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Range</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>       <span class="token comment">// =&gt; [-2, -1, 0, 1, 2]</span>
</code></pre>
<p>Nota: in generale se vogliamo utilizzare un valore dinamico o un’espressione come chiave di un oggetto o di un metodo, dobbiamo racchiuderlo tra <code>[]</code>. Questo vale anche per i Symbol, che non sono stringhe, ma tipi primitivi:</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token keyword">const</span> dynamicKey <span class="token operator">=</span> <span class="token string">"greet"</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>dynamicKey<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">"Hello"</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>greet<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// =&gt; "Hello"</span>
<span class="token comment">// se avessimo omesso le [], avremmo dovuto fare obj.dynamicKey</span>
</code></pre>
<p>Oltre al metodo <code>next()</code>, in un iteratore si può definire anche il metodo <code>return()</code>, il cui scopo è quello di gestire la <strong>pulizia e il rilascio di risorse</strong> quando l’iterazione non viene completata fino alla fine.</p>
<p>Ad esempio se l’iteratore sta leggendo mano a mano il contenuto da un file, e il ciclo di iterazione venisse interrotto improvvisamente da un <code>return</code>, <code>break</code>, o una exception, l’interprete va a cercare il metodo <code>return()</code> e lo chiama.</p>
<h2 id="generatori">Generatori</h2>
<p>Un <strong>generatore</strong> è un tipo di iteratore particolarmente utile quando gli elementi da iterare sono il risultato di una computazione.</p>
<p>Per creare un generatore bisogna creare una <em>generator function</em>, cioè una normale funzione solamente scritta con <code>function*</code>.</p>
<p>Quando viene invocata la <em>generator function</em> non viene eseguito il suo corpo, ma viene ritornato un oggetto generatore, che altro non è che un iteratore.</p>
<p>Chiamare il metodo <code>next()</code> del generatore, implica che viene eseguito il corpo della <em>generator function</em> fino a che non raggiunge un <code>yield</code> statement, che possiamo paragonare ad un <code>return</code>, e il valore dello <code>yield</code> sarà il valore inserito nel campo <code>value</code> dell’oggetto ritornato dalla <code>next()</code>.</p>
<p>Quando verrà chiamato nuovamente <code>next()</code> l’esecuzione ripartirà dal punto in cui si era fermata nella precedente chiamata.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token comment">// A generator function that yields the set of one digit primes.</span>
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">oneDigitPrimes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span> 
    <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">5</span><span class="token punctuation">;</span> 
    <span class="token keyword">yield</span> <span class="token number">7</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span> 
 
<span class="token comment">// When we invoke the generator function, we get a generator</span>
<span class="token keyword">let</span> gen <span class="token operator">=</span> <span class="token function">oneDigitPrimes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
 
<span class="token comment">// A generator is an iterator object that iterates the yielded values</span>
 gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value          <span class="token comment">// =&gt; 2</span>
 gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value          <span class="token comment">// =&gt; 3</span>
 gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value          <span class="token comment">// =&gt; 5</span>
 gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value          <span class="token comment">// =&gt; 7</span>
 gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>done           <span class="token comment">// =&gt; true </span>

<span class="token comment">// Generators have a Symbol.iterator method to make them iterable</span>
gen<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// =&gt; gen</span>

<span class="token comment">// We can use generators like other iterable types</span>
<span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">oneDigitPrimes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment">// =&gt; [2,3,5,7]</span>

<span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> prime <span class="token keyword">of</span> <span class="token function">oneDigitPrimes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	 sum <span class="token operator">+=</span> prime<span class="token punctuation">;</span>
sum                          <span class="token comment">// =&gt; 17</span>
</code></pre>
<h1 id="javascript-nel-browser">JavaScript nel browser</h1>
<p>JavaScript è stato pensato fin dall’inizio per introdurre dei comportamenti dinamici nei browser, con il passare degli anni i browser sono diventati delle piattaforme capaci di ospitare ogni tipo di applicazione web, includendo features grafiche, video, audio, animazioni, storage, networking, ecc…</p>
<p>Vediamo come sono strutturate le pagine web e come JavaScript riesce ad interagire con esse.</p>
<h2 id="javascript-in-html">JavaScript in HTML</h2>
<p>Le pagine web sono scritte in HTML, per includere codice JavaScript in queste pagine si utilizza il tag <code>&lt;script&gt; &lt;/script&gt;</code> inserendo il codice direttamente tra i due tag, oppure mettendo l’indirizzo del file JavaScript nell’attributo <code>src</code>.</p>
<pre class=" language-html"><code class="prism  language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>scripts/my_script.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre>
<p>Al tag <code>&lt;script&gt;</code> è anche possibile aggiungere gli attributi booleani <code>defer</code> e <code>async</code> (che funzionano solamente quando lo script viene ottenuto usando <code>src</code>):</p>
<ul>
<li>
<p><code>defer</code>: attende che il documento HTML sia stato completamente caricato e renderizzato prima di eseguire lo script.</p>
<p>più script con attributo <code>defer</code> vengono eseguiti nell’ordine in cui appaiono nel documento</p>
</li>
<li>
<p><code>async</code>: esegue lo script appena possibile e contemporaneamente viene caricato e renderizzato l’HTML</p>
<p>più script con <code>async</code> vengono eseguiti nell’ordine in cui vengono caricati (quindi non necessariamente viene seguito l’ordine in cui appaiono nel documento)</p>
</li>
</ul>
<p>È importante sottolineare che più script possono vedere e usare funzioni, classi, costanti e variabili create dagli altri script, quindi è come se tutti gli script appartenessero ad uno script più grande che li contiene tutti.</p>
<h2 id="dom">DOM</h2>
<p>Il <strong>Document Object Model (DOM)</strong> rappresenta il documento HTML attualmente caricato e visualizzato nel browser. Fornisce anche un insieme di API che permettono di interagire e manipolare la struttura, lo stile e il contenuto del documento HTML.</p>
<p>I documenti HTML contengono una serie di tag innestati che formano una struttura ad albero.</p>
<p>Il DOM rispecchia questa struttura, creando un oggetto JavaScript corrispondente ad ogni tag HTML. Ad esempio il tag <code>&lt;body&gt;</code> è rappresentato dalla classe <code>HTMLBodyElement</code>.</p>
<p>Le DOM API includono metodi per creare nuovi elementi e inserirli all’interno dell’albero come figli di altri elementi, analogamente ci sono metodi per spostare e rimuovere elementi dall’albero. Tutte le modifiche avvengono in tempo reale nella pagina web.</p>
<h2 id="global-object">Global object</h2>
<p>Per ogni tab del browser c’è un singolo <em>global object</em> condiviso tra tutti gli script importati dalla pagina web.</p>
<p>Il global object è dove la standard library è definita. All’interno di tale oggetto è anche presente la proprietà <code>document</code>, che contiene la struttura della pagina web, e la proprietà <code>window</code> il cui valore è l’oggetto globale stesso, che contiene il <code>document</code> come una sua proprietà interna (<code>window.document</code>).</p>
<h2 id="esecuzione-degli-script">Esecuzione degli script</h2>
<p>Possiamo dividere l’esecuzione in due fasi:</p>
<ol>
<li>la prima consiste nel caricamento della pagina e l’esecuzione degli script, in questi ultimi spesso si modifica la pagina web, si definiscono classi e funzioni ma, più importante, si impostano dei <strong>gestori di eventi</strong>, cioè delle funzioni che vengono invocate in risposta ad un input utente (oppure tramite timer, attività in rete, caricamento di risorse, al verificarsi di errori, …)</li>
<li>nella seconda fase il codice JavaScript viene invocato tramite il verificarsi di eventi specificati nella prima fase.</li>
</ol>
<p>due particolari eventi sono:</p>
<ul>
<li><code>DOMContentLoaded</code>: si triggera quando il documento html è caricato</li>
<li><code>load</code>: si triggera quando le risorse esterne del documento sono caricate</li>
</ul>
<p>Spesso si utilizzano questi due eventi per poi impostare altri eventi sulla pagina interamente caricata.</p>
<h2 id="eventi">Eventi</h2>
<p>Il browser è in grado di generare degli eventi quando determinate cose accadono, ad esempio quando il cursore dell’utente va sopra qualche elemento, quando viene premuto un tasto sulla tastiera ecc…</p>
<p>Con JavaScript è possibile far invocare una o più funzioni quando accade un evento specifico.</p>
<p>Vediamo alcune terminologie specifiche legate agli eventi:</p>
<ul>
<li>
<p><em><em><em>Event type</em> / <em>Event name</em></em>:</em> è una stringa che specifica il tipo di evento, ad esempio “mouseover”, “keydown”, “load”.</p>
</li>
<li>
<p><em><strong>Event target</strong>:</em> è l’elemento della pagina web a cui viene associato l’evento, ad esempio un <code>&lt;button&gt;</code></p>
</li>
<li>
<p><em><em><em>Event handler</em> / <em>Event listener</em></em>:</em> è la funzione che viene eseguita quando un determinato evento si verifica su un determinato target.</p>
<p>Questa funzione non ha un ritorno e nel suo body si può riferire al target con <code>this</code> (non per le arrow function).</p>
</li>
<li>
<p><em><strong>Event object</strong></em>: è un oggetto che rappresenta l’evento e che viene passato come argomento alla funzione, questo oggetto contiene delle proprietà specifiche per l’evento che possono essere utilizzate dalla funzione.</p>
</li>
</ul>
<h2 id="registrare-gli-event-listener">Registrare gli event listener</h2>
<p>Ci sono due modi per registrare degli event listener:</p>
<ol>
<li>aggiungere un attributo direttamente nell’elemento HTML o sull’oggetto JS corrispondente</li>
<li>usare il metodo <code>addEventListener()</code> (tecnica preferibile)</li>
</ol>
<h3 id="aggiungere-gli-attributi">1 aggiungere gli attributi</h3>
<p>In questo modo si assegna la funzione ad una particolare proprietà, per convenzione le proprietà sono scritte tutte in minuscolo e sono formate da “on” seguito da un nome specifico per l’evento: <code>onclick</code>, <code>onchange</code>, <code>onload</code>.</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token comment">// Set the onload property of the Window object to a function.</span>
<span class="token comment">// The function is the event handler: it is invoked when the document loads.</span>
window<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
	<span class="token comment">// Look up a &lt;form&gt; element </span>
	<span class="token keyword">let</span> form <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"form#shipping"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token comment">// Register an event handler function on the form that will be invoked </span>
	<span class="token comment">// before the form is submitted. </span>
	form<span class="token punctuation">.</span><span class="token function-variable function">onsubmit</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// When the user submits the form </span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isFormValid</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">// assume isFormValid is defined</span>
			event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// if form input was invalid prevent submission</span>
		<span class="token punctuation">}</span> 
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>In questo esempio sono stati aggiunti due event linstener rispettivamente agli eventi <code>onload</code> e <code>onsubmit</code>.</p>
<p>Con questo modo ogni <em>event target</em> può avere associato al massimo una funzione per tipo di evento.</p>
<p>Si può direttamente scrivere codice JavaScript in risposta ad un evento mettendolo direttamente nel tag HTML:</p>
<pre class=" language-html"><code class="prism  language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>console.log(<span class="token punctuation">'</span>Thank you<span class="token punctuation">'</span>);<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Please Click<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</code></pre>
<h3 id="usare-il-metodo-addeventlistener">2 Usare il metodo addEventListener</h3>
<p>Questa tecnica è preferibile perché isola completamente il codice HTML dal codice JavaScript e permette di assegnare <strong>più listener ad un stesso tipo di evento nello stesso target</strong>.</p>
<p>Ogni oggetto che può essere il target di un evento possiede un metodo <code>addEventListener</code> che prende 3 argomenti:</p>
<ol>
<li>una stringa che rappresenta il tipo di evento</li>
<li>la funzione che deve essere invocata quando si triggera l’evento</li>
<li>(opzionale) un booleano oppure un oggetto contenente dei booleani per configurare l’evento più nel dettaglio:
<ul>
<li>se si specifica direttamente <code>true</code> è equivalente a mettere solamente <code>capture</code> a <code>true</code></li>
<li>altrimenti si crea un oggetto contenente le seguenti proprietà:
<ul>
<li>
<p><code>capture</code>:</p>
<ul>
<li><code>true</code>: Evento sarà ascoltato prima dai listener più esterni del target (dalla radice del DOM al target specifico).</li>
<li><code>false</code> (default): Evento viene ascoltato prima dal target e poi risale l’albero del DOM.</li>
</ul>
</li>
<li>
<p><code>once</code>:</p>
<p>Se <code>true</code>, il listener verrà eseguito <strong>solo una volta</strong>, e poi sarà automaticamente rimosso.</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class=" language-html"><code class="prism  language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mybutton<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Click me<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">
  <span class="token keyword">let</span> b <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#mybutton"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  b<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Thanks again!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre>
<p>In modo simmetrico esiste il metodo <code>removeEventListener</code> che prende gli stessi parametri e serve a rimuovere un event listener.</p>
<h2 id="propagazione-degli-eventi-bubbling">Propagazione degli eventi (bubbling)</h2>
<p>Quando un evento viene triggerato su un particolare elemento della pagina, il segnale si propaga attraverso l’albero del DOM, partendo dall’elemento <strong>target</strong> e <strong>risalendo verso i suoi genitori</strong> fino alla radice del documento (<code>document</code>).</p>
<p>Questo processo è chiamato <strong>event bubbling</strong>.</p>
<p>Si può interrompere la propagazione chiamando <code>stopPropagation()</code>.</p>
<p>Si può sfruttare questo comportamento per registrare degli eventi su un target più generale in comune, piuttosto che registrare tanti eventi su target singoli (ad esempio registrare l’evento “change” direttamente sul form piuttosto che su ogni elemento interno al form).</p>
<h2 id="selezione-degli-elementi-html">Selezione degli elementi HTML</h2>
<p>Tramite l’oggetto <code>document</code>, che rappresenta la pagina HTML, si può selezionare un determinato elemento nella pagina, creare ed eliminare elementi, modificarne gli attributi, attraversare genitori, figli e fratelli degli elementi, ecc…</p>
<p>L’oggetto document possiede i campi <code>head</code> e <code>body</code> per selezionare i rispettivi tag HTML <code>&lt;head&gt;</code> e <code>&lt;body&gt;</code>, ma mette a disposizione metodi per ottenere elementi in vari modi:</p>
<ul>
<li>
<p><code>querySelector()</code> e <code>querySelectorAll()</code> permettono di selezionare elementi che possiedono uno specifico <em><strong>CSS selector</strong></em> (il nome del tag, l’id o la classe CSS)</p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token comment">// Find the document element for the HTML tag with attribute id="spinner"</span>
<span class="token keyword">let</span> spinner <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#spinner"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//return the first occurrence</span>
 
<span class="token comment">// Find all Element objects for &lt;h1&gt;, &lt;h2&gt;, and &lt;h3&gt; tags</span>
<span class="token keyword">let</span> titles <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">"h1, h2, h3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//return all occurrences</span>
</code></pre>
<p>Nota: querySelectorAll ritorna un oggetto array-like, quindi navigabile con gli indici e anche con il ciclo for-of.</p>
</li>
<li>
<p><code>getElementById</code>, <code>getElementsByName</code>, <code>getElementsByTagName</code>, <code>getElementsByClassName</code></p>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token comment">// Look up an element by id. The argument is just the id, without #</span>
<span class="token keyword">let</span> sect1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"sect1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
 
<span class="token comment">// Look up all elements (such as form checkboxes) that have a name="color" attribute.</span>
<span class="token keyword">let</span> colors <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByName</span><span class="token punctuation">(</span><span class="token string">"color"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token comment">// Look up all &lt;h1&gt; elements in the document.</span>
<span class="token keyword">let</span> headings <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"h1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token comment">// Look up all elements that have class "tooltip."</span>
<span class="token keyword">let</span> tooltips <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">"tooltip"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre>
<p>Nota l’uso della ‘s’ su <code>Elements</code> per suggerire che viene ritornato un oggetto array-like con tutti gli elementi selezionati.</p>
</li>
</ul>
<p>È anche possibile invocare tali metodi su un elemento specifico invece che su <code>document</code>, in questo modo gli elementi ottenuti saranno solo quelli figli dell’elemento specificato.</p>
<h2 id="attraversamento-del-documento">Attraversamento del documento</h2>
<p>Dopo aver selezionato l’elemento di interesse possiamo voler navigare l’albero a partire da quel nodo, ad esempio visitando il padre, i figli e i fratelli.</p>
<p>Possiamo fare questa navigazione tramite delle proprietà presenti negli elementi:</p>
<ul>
<li><code>parentNode</code>: si riferisce all’elemento padre</li>
<li><code>children</code>: contiene la lista degli elementi figli</li>
<li><code>childElementCount</code>: il numero di elementi figli (equivalente a <code>children.length</code>)</li>
<li><code>firstElementChild</code>, <code>lastElementChild</code>: contengono rispettivamente il primo elemento figlio e l’ultimo (sono <code>null</code> se non ci sono figli)</li>
<li><code>nextElementSibling</code>, <code>previousElementSibling</code>: contengono rispettivamente il successivo elemento fratello e il precedente (sono <code>null</code> se non ci sono fratelli)</li>
</ul>
<pre class=" language-jsx"><code class="prism  language-jsx"><span class="token comment">// Recursively traverse the Document or Element e, invoking the function</span>
<span class="token comment">// f on e and on each of its descendants</span>
<span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
		<span class="token function">f</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment">// Invoke f() on e </span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> child <span class="token keyword">of</span> e<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// Iterate over the children </span>
				<span class="token function">traverse</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// And recurse on each one </span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Tutte queste proprietà escludono nodi testuali presenti in HTML, tuttavia se si seleziona un elemento è possibile ottenere il testo che contiene, in 4 modi diversi:</p>
<pre class=" language-html"><code class="prism  language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ciao<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Ciao <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>none<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Mondo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">
    <span class="token keyword">let</span> a <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"ciao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"innerText:"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>innerText<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// "Ciao"</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"textContent:"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "CiaoMondo"</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"innerHTML:"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// "Ciao &lt;span style="display:none;"&gt;Mondo&lt;/span&gt;"</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"outerHTML:"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>outerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// Output: "&lt;div id="ciao"&gt;Ciao &lt;span style="display:none;"&gt;Mondo&lt;/span&gt;&lt;/div&gt;"</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre>
<ul>
<li><code>innerText</code>: Restituisce il <strong>testo visibile</strong> all’interno dell’elemento, escludendo gli elementi nascosti (ad esempio quelli con <code>display: none</code>).</li>
<li><code>textContent</code>: Restituisce tutto il testo contenuto nell’elemento, <strong>incluso il testo nascosto</strong> (ma senza i tag HTML).</li>
<li><code>innerHTML</code>: Restituisce l’intero contenuto HTML interno dell’elemento, <strong>compresi i tag</strong>.</li>
<li><code>outerHTML</code>: Restituisce l’intero contenuto HTML compreso l’elemento stesso, <strong>compresi i tag</strong>.</li>
</ul>
<h2 id="manipolare-gli-attributi">Manipolare gli attributi</h2>
<p>I tag HTML posso avere degli attributi che definiscono meglio il loro comportamento, ad esempio il tag <code>&lt;a&gt;</code> per inserire dei link nella pagina, utilizza l’attributo <code>href</code> per specificare la destinazione del link.</p>
<p>In JavaScript si possono manipolare anche questi attributi attraverso dei metodi:</p>
<ul>
<li><code>getAttribute()</code>: ottenere un attributo</li>
<li><code>setAttribute()</code>: impostare un attributo</li>
<li><code>hasAttribute()</code>: testare l’esistenza di un attributo</li>
<li><code>removeAttribute()</code>: rimuovere un attributo</li>
</ul>
<pre class=" language-html"><code class="prism  language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>myLink<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://www.example.com<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Example<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>updateLink<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Aggiorna Link<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>removeTarget<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Rimuovi Target<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">
	<span class="token keyword">const</span> link <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"myLink"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> updateButton <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"updateLink"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> removeButton <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"removeTarget"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>link<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"href"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// =&gt; "https://www.example.com"</span>
	
	updateButton<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	    link<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"href"</span><span class="token punctuation">,</span> <span class="token string">"https://www.google.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>link<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"href"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// =&gt; "https://www.google.com"</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	removeButton<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	    <span class="token keyword">if</span> <span class="token punctuation">(</span>link<span class="token punctuation">.</span><span class="token function">hasAttribute</span><span class="token punctuation">(</span><span class="token string">"target"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	        link<span class="token punctuation">.</span><span class="token function">removeAttribute</span><span class="token punctuation">(</span><span class="token string">"target"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre>
<p>Alcuni attributi dei tag HTML hanno un nome che è riservato in JavaScript, ad esempio l’attributo <code>class</code> in JavaScript diventa <code>className</code>.</p>
<p>In particolare l’attributo <code>class</code> in HTML è una stringa che contiene una serie di classi CSS separate da spazi. È comune su JavaScript voler aggiungere o rimuovere una singola classe agevolmente senza maneggiare l’intera stringa.</p>
<p>Per questo esiste la proprietà <code>classList</code> su cui è possibile chiamare i metodi:</p>
<ul>
<li><code>add()</code>: per aggiungere una classe</li>
<li><code>remove()</code>: per rimuovere una classe</li>
<li><code>contains()</code>: per verificare l’esistenza di una classe</li>
<li><code>toggle()</code>: per rimuovere se già presente o aggiungere se non presente</li>
</ul>
<pre class=" language-html"><code class="prism  language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>square<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>addClass<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Aggiungi Classe<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>removeClass<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Rimuovi Classe<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">
<span class="token keyword">const</span> box <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"box"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> addBtn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"addClass"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> removeBtn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"removeClass"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

addBtn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> box<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"border"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
removeBtn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> box<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"square"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre>
<h2 id="modificare-la-struttura-del-documento">Modificare la struttura del documento</h2>
<p>L’oggetto <code>document</code> fornisce dei metodi per creare nuovi elementi, e ogni elemento ha dei metodi per inserire, eliminare e rimpiazzare i nodi nell’albero.</p>
<p>È possibile creare nuovi elementi utilizzando il metodo <code>createElement()</code> e successivamente aggiungere altri elementi figli all’inizio o alla fine di questi ultimi tramite i metodi <code>prepend()</code> e <code>append()</code>, che servono rispettivamente per aggiungere contenuti all’inizio o alla fine.</p>
<p>Se si desidera inserire qualcosa in una posizione specifica, è necessario ottenere il riferimento a un nodo e utilizzare i metodi <code>before()</code> e <code>after()</code>.</p>
<pre class=" language-html"><code class="prism  language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Paragrafo iniziale<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">
<span class="token keyword">const</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"container"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> newParaBefore <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"p"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
newParaBefore<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">"Before"</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> newParaAfter <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"p"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
newParaAfter<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">"After"</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> newParaPrepend <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"p"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
newParaPrepend<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">"Prepend"</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> newParaAppend <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"p"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
newParaAppend<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">"Append"</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> original <span class="token operator">=</span> container<span class="token punctuation">.</span>firstElementChild<span class="token punctuation">;</span>
original<span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span>newParaBefore<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// Aggiungi prima del parafrafo iniziale</span>
original<span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span>newParaAfter<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// Aggiungi dopo il paragrafo iniziale</span>
container<span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span>newParaPrepend<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// aggiungi come primo elemento del container</span>
container<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>newParaAppend<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// aggiungi come ultimo elemento del container</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre>
<p>Risultato:</p>
<pre class=" language-html"><code class="prism  language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Prepend<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Before<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Paragrafo iniziale<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>After<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Append<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre>
<p>È possibile rimuovere un elemento con il metodo <code>remove()</code> ed è possibile rimpiazzarlo con il metodo <code>replaceWith()</code></p>
<pre class=" language-html"><code class="prism  language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Paragrafo da eliminare<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Paragrafo iniziale<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">
<span class="token keyword">const</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"container"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> newParaReplace <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"p"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
newParaReplace<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">"Questo paragrafo sostituisce il paragrafo iniziale"</span><span class="token punctuation">;</span>

container<span class="token punctuation">.</span>firstElementChild<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
container<span class="token punctuation">.</span>firstElementChild<span class="token punctuation">.</span><span class="token function">replaceWith</span><span class="token punctuation">(</span>newParaReplace<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre>
<p>Risultato:</p>
<pre class=" language-html"><code class="prism  language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Questo paragrafo sostituisce il paragrafo iniziale<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre>
<h1 id="svg-e-canvas">SVG e canvas</h1>
<h2 id="svg">SVG</h2>
<p><strong>SVG</strong> (<em>Scalable Vector Graphics</em>) è un formato di immagine, dove le immagini sono descritte da file di testo utilizzando il linguaggio XML contenenti gli step per rappresentare la grafica (differentemente da formati come PNG e JPEG che specificano valori di una matrice di pixel).</p>
<p>le SVG possono essere integrate in HTML in tre modi:</p>
<ol>
<li>usando il tag <code>&lt;img&gt;</code> inserendo un file con estensione <code>.svg</code></li>
<li>integrare le istruzioni XML direttamente nel codice HTML usando il tag <code>&lt;svg&gt;</code></li>
<li>usare delle API per modificare dinamicamente elementi SVG e crearne di nuovi da capo</li>
</ol>
<pre class=" language-html"><code class="prism  language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>This is a red square: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>svg</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rect</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">fill</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>svg</span><span class="token punctuation">&gt;</span></span>
</code></pre>
<h2 id="canvas">Canvas</h2>
<p><strong>Canvas</strong>, d’altra parte, crea una superficie di disegno all’interno del documento ed espone un’API di disegno a JavaScript. Un canvas si crea con il tag <code>&lt;canvas&gt;</code> e tramite JavaScript si può ottenere il canvas, e poi ottenere il contesto (tramite <code>getContext()</code>) per poi disegnare la grafica.</p>
<pre class=" language-html"><code class="prism  language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>This is a red square: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>canvas</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>square<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span>10</span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span>10</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>canvas</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">
	<span class="token keyword">let</span> canvas <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#square"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Get first canvas element</span>
	<span class="token keyword">let</span> context <span class="token operator">=</span> canvas<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">"2d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// Get 2D drawing context</span>
	context<span class="token punctuation">.</span>fillStyle <span class="token operator">=</span> <span class="token string">"#f00"</span><span class="token punctuation">;</span>                      <span class="token comment">// Set fill color to red</span>
	context<span class="token punctuation">.</span><span class="token function">fillRect</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// Fill a square</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre>
<h2 id="differenze-tra-svg-e-canvas">Differenze tra SVG e Canvas:</h2>
<p>SVG è più adatto per immagini vettoriali scalabili e interattive, mentre Canvas è più indicato per grafica raster, manipolazione di pixel e visualizzazioni dinamiche di dati.</p>
<ul>
<li><strong>Modalità di disegno:</strong> Con Canvas, si creano disegni <strong>chiamando metodi</strong>, mentre con SVG si crea un <strong>albero di elementi XML</strong>.</li>
<li><strong>Scalabilità:</strong> Le immagini SVG sono scalabili senza perdita di qualità, mentre le immagini create con Canvas possono diventare sfocate se ingrandite.</li>
<li><strong>Modificabilità:</strong> Gli elementi SVG possono essere facilmente modificati o rimossi dal loro albero, mentre in Canvas, le modifiche spesso richiedono di cancellare l’intero disegno e ridisegnarlo.</li>
<li><strong>Creazione:</strong> Gli elementi SVG possono essere inclusi direttamente in HTML o creati dinamicamente con il DOM API. Canvas viene creato con l’elemento <code>&lt;canvas&gt;</code> e il suo contenuto viene disegnato tramite l’API JavaScript.</li>
<li><strong>Grafica 3D:</strong> Canvas supporta anche la grafica 3D tramite WebGL. SVG non ha supporto nativo per la grafica 3D.</li>
</ul>

    </div>
  </div>
</body>

</html>
