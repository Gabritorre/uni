<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2024-10-15_Sicurezza della rete</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#sicurezza-della-rete">Sicurezza della rete</a>
<ul>
<li><a href="#servizi-di-sicurezza">Servizi di sicurezza</a></li>
<li><a href="#sicurezza-nella-comunicazione">Sicurezza nella comunicazione</a></li>
<li><a href="#crittografia">Crittografia</a></li>
<li><a href="#funzioni-hash">Funzioni hash</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="sicurezza-della-rete">Sicurezza della rete</h1>
<p>Con sicurezza della rete possiamo intendere un insieme di azioni che riguardano ogni aspetto per rendere una rete sicura e mantenerla sicura nel tempo.</p>
<p>Lo standard X.800 definisce tre aspetti chiave:</p>
<ul>
<li>
<p><strong>servizi di sicurezza</strong>:</p>
<p>Ci sono 6+1 servizi a cui dedicare risorse per rendere più sicuro un sistema:</p>
<ul>
<li><strong>Data availability</strong></li>
<li><strong>Data authentication</strong></li>
<li><strong>Data integrity</strong></li>
<li><strong>Confidentiality/Secrecy</strong></li>
<li><strong>Access control</strong></li>
<li><strong>Non repudiation</strong></li>
<li>(Anonymity)</li>
</ul>
</li>
<li>
<p><strong>meccanismi di sicurezza</strong>: sono delle funzioni che hanno lo scopo di implementare i servizi sopra citati, ad esempio:</p>
<ul>
<li>criptografia</li>
<li>firma digitale</li>
<li>hashing</li>
<li>meccanismi di controllo degli accessi</li>
<li>protocolli di autenticazione</li>
<li>…</li>
</ul>
</li>
<li>
<p><strong>attacchi</strong>: Un sistema al 100% sicuro non esiste, la sicurezza si applica per coprire determinati attacchi proporzionati all’importanza e alla grandezza del sistema da proteggere.</p>
</li>
</ul>
<h2 id="servizi-di-sicurezza">Servizi di sicurezza</h2>
<p>Approfondiamo i vari servizi di sicurezza.</p>
<h3 id="availability">Availability</h3>
<p>Significa che il sistema deve essere sostanzialmente raggiungibile.</p>
<p>Gli attacchi DoS minano questo servizio saturando le risorse fisiche necessarie al funzionamento del sistema.</p>
<p>Per garantire al più possibile l’availability è necessario avere un buon design della rete e minimizzare il danno da un possibile attacco DoS.</p>
<h3 id="confidentiality">Confidentiality</h3>
<p>Significa che i dati scambiati rimangono riservati ai soli partecipanti dello scambio.</p>
<p>Per garantire questo aspetto sono necessari meccanismi di crittografia.</p>
<h3 id="integrity">Integrity</h3>
<p>Significa che i dati devono raggiungere la destinazione senza subire modifiche nel tragitto.</p>
<p>Per garantire questo aspetto sono necessari meccanismi di hashing.</p>
<h3 id="authentication">Authentication</h3>
<p>Si divide in:</p>
<ul>
<li>
<p><strong>Autenticazione dell’origine dei dati</strong>: chi riceve i dati deve essere certo che chi ha dato origine ai dati sia chi dice di essere.</p>
<p>Ad esempio, se Alice riceve un’email da Bob, l’autenticazione dell’origine dei dati è il servizio che garantisce che il vero autore dell’email sia effettivamente Bob, indipendentemente da chi consegna l’email (ad esempio, Gmail).</p>
</li>
<li>
<p><strong>Autenticazione del peer</strong>: chi riceve i dati deve essere certo che chi consegna i dati sia chi dice di essere.</p>
<p>Ad esempio, tra Alice e Bob ci sono diversi router che trasportano le informazioni. Alice riceve da Carl (un intermediario lecito) i dati generati da Bob e deve essere sicura che le informazioni appena ricevute siano state effettivamente inviate da Carl e non siano state alterate da un’entità che finge di essere Carl.</p>
</li>
</ul>
<p>Per garantire questo aspetto sono necessari meccanismi di firma digitale.</p>
<h3 id="access-control">Access control</h3>
<p>L’accesso deve essere permesso solamente a chi è autorizzato ad accedere.</p>
<p>Non garantire questo servizio può permettere situazioni in cui il sistema viene sfruttato per attaccarne un altro a nostra insaputa. Potremmo quindi essere accusati di aver partecipato all’attacco anche se non è così.</p>
<p>Per garantire questo aspetto sono necessari meccanismi di autenticazione ed identificazione.</p>
<h3 id="non-repudiation">Non repudiation</h3>
<p>Il non ripudio previene che un mittente neghi di essere stato lui ad inviare un messaggio, oppure che chi riceve il messaggio neghi di averlo ricevuto.</p>
<p>Per garantire questo aspetto sono necessari meccanismi firma digitale</p>
<h3 id="anonymity">Anonymity</h3>
<p>Questo non è un servizio canonico dello standard X.800.</p>
<p>Indica l’abilità di usare un sistema senza che il sistema sia in grado di identificare l’utente.</p>
<p>Per garantire questo aspetto sono necessari meccanismi come Tor, freenet, ecc</p>
<p>Questo servizio ha una doppia faccia: da un lato può essere usato per commettere atti illegali, dall’altro permette di dar voce a chi non può usufruire dei propri diritti civili (a causa di guerre, politiche restrittive, ecc…)</p>
<h2 id="sicurezza-nella-comunicazione">Sicurezza nella comunicazione</h2>
<p>Quando si gestisce un sistema di comunicazione si fa riferimento ad una astrazione di questo tipo:</p>
<p><img src="https://i.ibb.co/H2Jjv8s/image.png" alt=""></p>
<p><strong>Alice</strong> e <strong>Bob</strong> vogliono comunicare tra loro, mentre <strong>Eve</strong> è l’attaccante che controlla il canale di comunicazione.</p>
<p>Alice e Bob devono scambiarsi dei messaggi e trattano il canale di comunicazione come un tubo in cui mandare o ricevere i messaggi.</p>
<p>Il canale di comunicazione può essere di qualsiasi tipo, ad esempio Internet.</p>
<p>Eve può fare qualsiasi cosa sul canale: intercettare i messaggi, duplicarli, non farli arrivare, modificarli (però non può rompere la crittografia dei messaggi).</p>
<p>Alice e bob trasformano i propri messaggi con dei meccanismi per non inviare il testo in chiaro, ma piuttosto messaggi cifrati.</p>
<p>Per fare in modo che Alice e Bob si accordino sul sistema di trasformazione devono ricevere delle credenziali da una entità terza affidabile (Anche Eve può interagire con questa entità)</p>
<p>Un workflow per rendere sicuro un sistema consiste nell’identificare gli attori del modello e fare delle scelte:</p>
<ul>
<li>di quali servizi di sicurezza ho bisogno?</li>
<li>in che modo possono attaccare il sistema?</li>
<li>da quali attacchi non vale la pena difendersi?</li>
<li>quali servizi mi posso permettere?</li>
<li>quali meccanismi adottare?</li>
<li>adottando troppe misure di sicurezza sto rendendo inutilizzabile il sistema?</li>
</ul>
<p>Si tratta sempre di un <strong>trade-off tra sicurezza e usabilità.</strong></p>
<h2 id="crittografia">Crittografia</h2>
<p>La crittografia è la scienza che studia come rendere segrete delle informazioni.</p>
<p>La crittografia permette di avere:</p>
<ul>
<li>integrità (tramite <strong>funzioni hash</strong>)</li>
<li>segretezza (tramite <strong>cifratura</strong>)</li>
<li>non ripudio (tramite <strong>firma digitale</strong>)</li>
<li>componendo varie funzioni sopra citate si può ottenere anche
<ul>
<li>controllo degli accessi</li>
<li>anonimità</li>
<li>autenticazione</li>
</ul>
</li>
</ul>
<p><strong>Algoritmo crittografico</strong>: Una sequenza di operazioni matematiche che possono essere applicate ad un messaggio</p>
<p><strong>Funzione crittografica</strong>: un blocco di codice che implementa l’algoritmo crittografico per fornire meccanismi di sicurezza.</p>
<p><strong>Protocollo di sicurezza</strong>: È un insieme di regole che definiscono come devono essere utilizzati algoritmi crittografici e funzioni crittografiche per garantire una comunicazione sicura.</p>
<p>Per minimizzare il rischio di falle di sicurezza è importante cercare di seguire queste regole:</p>
<ul>
<li>non usare algoritmi di crittografia sconosciuti e non inventarsene di nuovi per conto proprio</li>
<li>non usare funzione crittografiche closed source</li>
<li>usare le funzioni più utilizzate e aggiornate</li>
<li>usare protocolli standard</li>
<li>Restringere il servizio solo ad utenti che supportano la versione più recente dei protocolli</li>
</ul>
<h2 id="funzioni-hash">Funzioni hash</h2>
<p>Una <strong>funzione hash</strong> è una funzione unidirezionale (non invertibile) che viene applicata su dei dati di dimensione variabile e genera un <strong>digest</strong>, cioè una stringa di grandezza fissa. Più grande è la dimensione della stringa in output minori saranno le probabilità di collisioni.</p>
<p>Le funzioni hash vengono usate per garantire <strong>l’integrità dei dati</strong>: infatti inviando oltre che al messaggio anche il digest, il destinatario potrà ricalcolare la funzione hash sul messaggio e controllare che i due digest corrispondano.</p>
<p><img src="https://i.ibb.co/VNpWJ4W/image.png" alt=""></p>
<p>Funzioni hash sono ad esempio MD5, SHA 1, SHA 256, …</p>
<h3 id="proprietà-delle-funzioni-hash">Proprietà delle funzioni hash</h3>
<ol>
<li>
<p>l’input può essere di qualsiasi dimensione</p>
</li>
<li>
<p>l’output ha dimensione fissa</p>
</li>
<li>
<p>calcolare la funzione hash di un input deve essere computazionalmente efficiente</p>
</li>
<li>
<p>Dato che il dominio della funzione hash (l’input) è molto più grande rispetto al codominio (l’output) è possibile che si verifichino delle <strong>collisioni</strong> (input diversi generano lo stesso output)</p>
</li>
<li>
<p>possedendo l’output, trovare l’input che ha generato un tale output deve essere computazionalmente impossibile</p>
</li>
<li>
<p>dato un input, trovare un altro input che genera lo stesso output deve essere computazionalmente impossibile.</p>
<p>input simili non devono generare un output simile, l’output deve essere impredicibile.</p>
</li>
<li>
<p>trovare due input diversi che generano lo stesso output deve essere computazionalmente impossibile</p>
</li>
</ol>
<p>Nota: con <strong>computazionalmente impossibile</strong> si intende che ad oggi non si conosce un algoritmo di complessità polinomiale in grado di risolvere il problema.</p>
<p>Dato che la dimensione dell’output è fissa, se abbiamo un input grande sicuramente delle informazione vengono perse durante l’hashing.</p>
<p>Inoltre, data la presenza di collisioni, se un attaccante che possiede un output, trova un input che genera lo stesso output, non saprà se l’input è il messaggio originale o solo una collisione.</p>

    </div>
  </div>
</body>

</html>
