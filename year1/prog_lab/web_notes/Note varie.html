<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Note varie</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#note-varie">Note varie</a>
<ul>
<li><a href="#r-value-and-l-value">R-value and l-value</a></li>
<li><a href="#tipo-di-dato-variabile-e-oggetto">Tipo di dato, variabile e oggetto</a></li>
<li><a href="#dichiarazione-assegnamento-inizializzazione-e-definizione">Dichiarazione, assegnamento, inizializzazione e definizione</a></li>
<li><a href="#linguaggi-imperativi-e-funzionali">Linguaggi imperativi e funzionali</a></li>
<li><a href="#references">References</a></li>
<li><a href="#invariante-di-un-ciclo">Invariante di un ciclo</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="note-varie">Note varie</h1>
<h2 id="r-value-and-l-value">R-value and l-value</h2>
<p>l-value: rappresenta un oggetto che è identificabile attraverso un indirizzo</p>
<ul>
<li>una l-value <strong>non</strong> può essere una funzione, una espressione (<em>varibile</em> + 3) oppure una costante (1, 10.5, -5…).</li>
<li>Nelle operazioni di assegnamento (=) la l-value deve avere la capacità di immagazzinare dati.</li>
</ul>
<p>r-value rappresenta un oggetto che invece non è identificabile tramite un indirizzo</p>
<p>Sono un r-value le costanti e tutto quello che può restituire una costante</p>
<h3 id="operatori-di-indirizzo">operatori di indirizzo</h3>
<ul>
<li>
<p><strong>&amp;</strong> deve operare su una l-value e restituisce una r-value.</p>
<pre><code>  int *p = &amp;a;
</code></pre>
<p>a è una variabile e quindi una l-value e viene restituito l’indirizzo di a che è una costante, quindi una r-value.<br>
Infatti una operazione come “&amp;15” non è ammessa</p>
</li>
<li>
<p><strong>*</strong> opera su una r-value e restituisce una l-value.</p>
<pre><code>  *p = 15; 
</code></pre>
<p>abbiamo che ‘p’ rappresenta un indirizzo quindi una r-value e l’operatore <strong>*</strong> rappresenta la zona di memoria puntata dall’indirizzo quindi una l-value.</p>
</li>
</ul>
<h2 id="tipo-di-dato-variabile-e-oggetto">Tipo di dato, variabile e oggetto</h2>
<ul>
<li>Tipo di variabile: insieme di valori su cui vengono definite delle operazioni.</li>
<li>Oggetto: area di memoria dotata di tipo.</li>
<li>Variabile: oggetto (quindi un’area di memoria) a cui è assegnato un identificatore</li>
</ul>
<h2 id="dichiarazione-assegnamento-inizializzazione-e-definizione">Dichiarazione, assegnamento, inizializzazione e definizione</h2>
<ul>
<li>
<p><strong>Dichiarazione</strong>: Operazione che introduce un nuovo identificatore (nome della variabile), con il suo tipo di dato.</p>
<pre><code>  int a;
</code></pre>
</li>
<li>
<p><strong>Assegnamento</strong>: Significa dare un valore ad una variabile precedentemente dichiarata.</p>
<pre><code>  a = 5;
</code></pre>
</li>
<li>
<p><strong>Inizializzazione</strong>: Indica che si sta dichiarando una variabile e nello stesso passaggio si assegna anche un valore ad essa.</p>
<pre><code>  int b = 5;
</code></pre>
</li>
<li>
<p><strong>Definizione</strong>: significa in sostanza allocare dell’area di memoria</p>
</li>
</ul>
<h2 id="linguaggi-imperativi-e-funzionali">Linguaggi imperativi e funzionali</h2>
<ul>
<li>
<p>I linguaggi imperativi rappresentano la classica idea di programmazione con le caratteristiche principali come:</p>
<ul>
<li>OOP</li>
<li>flusso delle istruzioni ini ordine ben specifico</li>
<li>utilizzo e modifica di variabili durante il flusso del codice</li>
</ul>
<p>es. C, C++, Java</p>
</li>
<li>
<p>I linguaggi funzionali si basano su funzioni matematiche</p>
<ul>
<li>si basano principalmente nel definire funzioni che elaborano dei valori dati in input</li>
<li>non esiste l’assegnamento a “variabili” già definite</li>
</ul>
<p>es. scheme, scala, Prolog</p>
</li>
</ul>
<h2 id="references">References</h2>
<p>Una variabile dichiarata come reference di un’altra variabile è in sostanza un <em>alias</em> di quella variabile.</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
</code></pre>
<p>In questo caso <code>b</code> è una reference alla variabile <code>a</code>, quindi le variabili <code>a</code> e <code>b</code> sono la stessa cosa.</p>
<p>Quando una funzione richiede come parametri delle references si ha una chiamata a funzione con passaggio dei parametri per inidirizzo, per cui vengono utilizzate effettivamente le variabili passate alla funzione e non una loro copia</p>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">void</span> <span class="token function">function</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> var1<span class="token punctuation">)</span><span class="token punctuation">{</span>
	var1 <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token function">function</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">;</span>	<span class="token comment">//a vale 10</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="differenze-con-i-puntatori">Differenze con i puntatori</h3>
<ul>
<li>Una reference non può essere di tipo void, mentre un puntatore sì.</li>
<li>Una reference non può essere aggiornata dopo la sua inizializzazione, mentre un puntatore sì.</li>
<li>Una reference può riferirsi ad una altra reference ma rappresenterà sempre un alias della variabile originale, mentre un puntatore può puntare ad un altro puntatore ma ogni puntatore avrà un contenuto diverso (i vari indirizzi).</li>
</ul>
<h2 id="invariante-di-un-ciclo">Invariante di un ciclo</h2>
<p>L’invariante di un ciclo è una proprietà che deve essere vera prima e durante le iterazioni del ciclo.</p>
<p>L’utilità dell’invariante sta nel fatto che permette di verificare se il ciclo funziona correttamente. Se l’invariante è vera all’inizio del ciclo e rimane vera ad ogni iterazione, allora possiamo essere certi che il ciclo terminerà correttamente.</p>
<h3 id="esempio">Esempio</h3>
<p>Ad esempio in un programma che calcola il l’elemento maggiore  presente in una matrice.</p>
<p>All’inizio di ogni iterazione del ciclo,  una variabile, <code>max</code> contiene il valore massimo tra tutti gli elementi della matrice che abbiamo finora esaminato.</p>
<p>Alla fine di ogni iterazione del ciclo, l’invariante deve rimanere vero. In particolare, se abbiamo esaminato tutti gli elementi della matrice, allora <code>max</code> conterrà il valore massimo tra tutti gli elementi della matrice.</p>
<p>Quindi, l’invariante in questo caso è che la variabile <code>max</code> contenga sempre il valore massimo tra gli elementi della matrice che abbiamo finora esaminato. Alla fine del ciclo, <code>max</code> conterrà il valore massimo tra tutti gli elementi della matrice.</p>

    </div>
  </div>
</body>

</html>
