# ARMv8 ISA

Ci concentreremo sulla versione di ARM **ARMv8-A** che rappresenta la famiglia più utilizzata nei dispositivi mobili.

l'ARMv8-A supporta 3 *instruction set*, noi ci concentreremo sull'istruction set "A64" che è la versione a 64bit.

## Simple Sequential Execution (SSE)

Le istruzioni nelle architetture ARM seguono il modello SSE, cioè si comporta come se le istruzioni fossero caricate una alla volta e nell'ordine in cui sono scritte nel programma. cioè rende il programma più prevedibile e affidabile.
Anche se questa cosa può sembrare scontata non lo è perché altre architetture utilizzano un modello OOE (*out-of-order execution*).

In realtà le CPU ARM caricano 2 istruzioni alla volta e talvolta le eseguono in parallelo, l'implementazione però ci assicura che l'effetto è lo stesso di una esecuzione sequenziale in cui una istruzione non viene caricata finche la precedente non è stata completata.


## Registri

Abbiamo **31 registri *general purpose*** anche se alcuni registri è preferibile non modificarli.

ogni registro può essere utilizzato come un registro a 64bit (chiamandolo X\<n\>) oppure come un registro a 32bit (chiamandolo Q\<n\>)

```
add w0,w1,w2 // somma a 32bit
add x0,x1,x2 // somma a 64bit
```

Abbiamo **31 registri per le operazioni floating point e operazioni vettorizzate**. Questi registri possiedono vari prefissi in base alla dimensione sui cui si vuole lavorare.

```
fadd s0,s1,s2 // somma floating point a 32bit
fadd d0,d1,d2 // somma floating point a 64bit
```

Tabella dei prefissi
| prefisso | tipo di dato | dimensione |
|--|--|--|
| b | intero | 8bit |
| h | intero | 16bit |
| w | intero | 32bit |
| x | intero | 64bit |
| s | floating point | 32bit |
| d | floating point | 64bit |
| q | floating point | 128bit |
| v | vettori | variabile |


**Altri registri speciali**:
- **XZR** viene sempre letto come fosse 0
- **SP** (x28) stack pointer
- **FP** (x29) frame pointer
- **LR** (x30) link register
- **PC** Program counter, non è un registro *general purpose* e non può essere letto/scritto direttamente, può essere letto però utilizzando una pseudo-istruzione chiamata **ADR**
- **APSR** Application program status register, contiene una copia dello stato (condition codes) dell'ultima operazione effettuata dall'ALU
![](https://i.ibb.co/8PFdhCS/condition-codes-alu.png)
Siamo interessati particolarmente ai flag:
	- N: posto a 1 se il risultato dell'ultima operazione è **negativo**
	- Z: posto a 1 se il risultato dell'ultima operazione è **zero**
	- V: posto a 1 se nell'ultima operazione si è verificato **overflow**
	- C: posto a 1 se nell'ultima operazione c'è stato un **riporto**


## Formato istruzioni

Tutte le istruzioni sono a 32 bit
- Rn = source 1
- Rm = source 2
- Rd = destination
![](https://i.ibb.co/ZV9bNMX/formato-istru.png)

### Operazioni aritmetico-logiche

Una istruzione di questo tipo è formata come segue:

`<op>{s} Rd, Rn, operand2`

- `s`: è un carattere opzionale che si può aggiungere all'istruzione che serve ad settare i condition codes dell'ALU per quella istruzione. Essi tornano utili quando vogliamo fare delle operazioni in base ai codici dell'ALU.

- `operand2`: può essere
	- `Rm` un registro comune
	- `Rm, <shift> #x` un registro shiftato di un numero immediato
	- `Rm, <shift> Rs` un registro shiftato per un valore di un registro
	- `#imm` un numero immediato a 12bit (fino a 4096)
- `<shift>`:  sono presenti vari tipi di shift
	- LSL
	- LSR
	- ASR

Le principali operazioni aritmetico logiche sono: **`ADD, SUB, AND, XOR, ORR, MUL`**

### Shift

Lo scopo dello shift è quello di dividere e moltiplicare per potenze di 2 e anche per accedere a elementi di array.

- LSL (*Logical left shift*)
	fa uno shift a **sinistra** inserendo degli zeri a destra  (rappresenta la moltiplicazione)
	
| 4 | 3 | 2 | 1 | 0 |
|--|--|--|--|--|
| 1 | 0 | 0 | 1 | 1 |
| 0 | 0 | 1 | 1 | **0** $\leftarrow$|
| 0 | 1 | 1 | **0** | **0** $\leftarrow$|

- LSR (*Logical right shift*)
	fa uno shift a **destra** inserendo degli zeri a sinistra (rappresenta la divisione)
	
| $\hspace{3.5mm}$ 4 | 3 | 2 | 1 | 0 |
|--|--|--|--|--|
| $\hspace{3.5mm}$ 1 | 0 | 0 | 1 | 1 |
|$\rightarrow$ **0** | 1 | 0 | 0 | 1 |
| $\rightarrow$ **0** | **0**  | 1 | 0 | 0 |


- ARS (*Arithmetic right shift*)
	fa uno shift a **destra** inserendo degli zeri oppure uno a sinistra a seconda del segno  (rappresenta la divisione)
	con LSR se il numero era negativo, e quindi terminava per 1, questo dato veniva perso inserendo gli zeri.
	con LSL non è un problema perché se perdiamo l'uno più a destra significa che siamo andati in overflow
	con l'ARS riusciamo a mantenere il segno nelle divisioni

Quindi per recap

|tipo di shift| utilizzo |
|--|--|
| LSL | divisione per numeri senza segno |
| LSR | moltiplicazione per numeri con e senza segno segno |
| LSL | divisione per numeri con segno |

### Assegnamento

L'istruzione `MOV` serve per assegnare un valore ad un registro, oppure per copiare il valore di un registro in un altro.

- `MOVZ` permette di caricare un immediato di 16bit (fino a 65535) shiftato di 0, 16, 32, 48 settando tutti gli altri spazi del registro a zero.
- `MOVK`permette di caricare un immediato di 16bit (fino a 65535) shiftato di 0, 16, 32, 48 lasciando inalterati gli altri bit del registro.

esempio: `MOVZ X9, #255, LSL #16`

Se abbiamo un valore grande due byte (16bit) rappresentato in esadecimale "AB"

|n° byte $\to$| 1 | 2 | 3 | 4 | 5  | 6  | 7 | 8 |
|--|--|--|--|--|--|--|--|--|
|shift di 0 $\to$ | 0 | 0 | 0 | 0 | 0 | 0 | A | B |
|shift di 16 $\to$ | 0 | 0 | 0 | 0 | A | B | 0 | 0 |
|shift di 32 $\to$ | 0 | 0 | A | B | 0 | 0 | 0 | 0 |
|shift di 48 $\to$ | A | B | 0 | 0 | 0 | 0 | 0 | 0 |

è possibile combinare MOVZ e MOVK per creare registri che contengono numeri molto grandi


### ADR e ADRP

Queste due istruzioni servono a caricare degli indirizzi nei registri

ADR salva l'indirizzo di label a partire dal PC e un offset
`adr X1, label` 

ADRP salva l'indice della pagina che contiene l'indirizzo di label.
