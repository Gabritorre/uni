# ARMv8 ISA

Ci concentreremo sulla versione di ARM **ARMv8-A** che rappresenta la famiglia più utilizzata nei dispositivi mobili.

l'ARMv8-A supporta 3 *instruction set*, noi ci concentreremo sull'istruction set "A64" che è la versione a 64bit.

## Simple Sequential Execution (SSE)

Le istruzioni nelle architetture ARM seguono il modello SSE, cioè si comporta come se le istruzioni fossero caricate una alla volta e nell'ordine in cui sono scritte nel programma. cioè rende il programma più prevedibile e affidabile.
Anche se questa cosa può sembrare scontata non lo è perché altre architetture utilizzano un modello OOE (*out-of-order execution*).

In realtà le CPU ARM caricano 2 istruzioni alla volta e talvolta le eseguono in parallelo, l'implementazione però ci assicura che l'effetto è lo stesso di una esecuzione sequenziale in cui una istruzione non viene caricata finche la precedente non è stata completata.


## Registri

Abbiamo **31 registri *general purpose*** anche se alcuni registri è preferibile non modificarli.

ogni registro può essere utilizzato come un registro a 64bit (chiamandolo X\<n\>) oppure come un registro a 32bit (chiamandolo Q\<n\>)

```
add w0,w1,w2 // somma a 32bit
add x0,x1,x2 // somma a 64bit
```

Abbiamo **31 registri per le operazioni floating point e operazioni vettorizzate**. Questi registri possiedono vari prefissi in base alla dimensione sui cui si vuole lavorare.

```
fadd s0,s1,s2 // somma floating point a 32bit
fadd d0,d1,d2 // somma floating point a 64bit
```

Tabella dei prefissi
| prefisso | tipo di dato | dimensione |
|--|--|--|
| b | intero | 8bit |
| h | intero | 16bit |
| w | intero | 32bit |
| x | intero | 64bit |
| s | floating point | 32bit |
| d | floating point | 64bit |
| q | floating point | 128bit |
| v | vettori | variabile |


**Altri registri speciali**:
- **XZR** viene sempre letto come fosse 0
- **SP** (x28) stack pointer
- **FP** (x29) frame pointer
- **LR** (x30) link register
- **PC** Program counter, non è un registro *general purpose* e non può essere letto/scritto direttamente, può essere letto però utilizzando una pseudo-istruzione chiamata **ADR**
- **APSR** Application program status register, contiene una copia dello stato dell'ultima operazione effettuata dall'ALU
![](https://i.ibb.co/8PFdhCS/condition-codes-alu.png)
Siamo interessati particolarmente ai flag:
	- N: posto a 1 se il risultato dell'ultima operazione è **negativo**
	- Z: posto a 1 se il risultato dell'ultima operazione è **zero**
	- V: posto a 1 se nell'ultima operazione si è verificato **overflow**
	- C: posto a 1 se nell'ultima operazione c'è stato un **riporto**


